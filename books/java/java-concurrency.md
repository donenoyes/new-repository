<meta itemprop="name" content="Java Concurrency in Practice by Safari Books Online LLC (z-lib.org)"><meta itemprop="faviconUrl" content="https://ssl.gstatic.com/docs/documents/images/kix-favicon7.ico"><meta itemprop="url" content="https://docs.google.com/document/d/1AWnii-L0TFqvSDV8pAi59ahHaX_cuePTkpK93OoT8Mw/edit?usp=drive_web&amp;ouid=102861041933476548702&amp;usp=embed_googleplus"><meta itemprop="embedURL" content="https://docs.google.com/document/u/0/d/1AWnii-L0TFqvSDV8pAi59ahHaX_cuePTkpK93OoT8Mw/preview?usp=embed_googleplus">Some Word features can't be displayed in Google Docs and will be dropped if you make changesView details[](https://docs.google.com/document/u/0/?authuser=0&usp=docs_web)Java Concurrency in Practice by Safari Books Online LLC (z-lib.org)<input class="docs-title-input" spellcheck="false" type="text" autocomplete="off" guidedhelpid="editor_title" aria-describedby="docs-parent-collections-container-outer" value="Java Concurrency in Practice by Safari Books Online LLC (z-lib.org)" tabindex="0" dir="ltr" aria-label="Rename" data-tooltip="Rename" style="visibility: visible; width: 544px;"> Share[![](https://lh3.googleusercontent.com/ogw/ADGmqu9fBOGXCU0_GhNfyUJwWYTYwedS1MKiqMbNzcM5=s32-c-mo)](https://accounts.google.com/SignOutOptions?hl=en&continue=https://docs.google.com/document/d/1AWnii-L0TFqvSDV8pAi59ahHaX_cuePTkpK93OoT8Mw/edit%3Fusp%3Ddrive_web%26ouid%3D102861041933476548702&service=writely)![](data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw== "Profile")[](https://myaccount.google.com/?utm_source=OGB&authuser=0)Android Dev Notesawesomedevnotes@gmail.com[Manage your Google Account](https://myaccount.google.com/?utm_source=OGB&authuser=0&utm_medium=act)[![](data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==)DefaultAndroid Dev Notesawesomedevnotes@gmail.com](/document/d/1AWnii-L0TFqvSDV8pAi59ahHaX_cuePTkpK93OoT8Mw/edit?usp=drive_web&ouid=102861041933476548702&authuser=0)[![](data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==)Ashish Kharchethekharche@gmail.com](/document/d/1AWnii-L0TFqvSDV8pAi59ahHaX_cuePTkpK93OoT8Mw/edit?usp=drive_web&ouid=102861041933476548702&authuser=1)[![](data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==)Kim Worksjiayounokim@gmail.com](/document/d/1AWnii-L0TFqvSDV8pAi59ahHaX_cuePTkpK93OoT8Mw/edit?usp=drive_web&ouid=102861041933476548702&authuser=2)[![](data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==)Iu Dragoniudragon32@gmail.com](/document/d/1AWnii-L0TFqvSDV8pAi59ahHaX_cuePTkpK93OoT8Mw/edit?usp=drive_web&ouid=102861041933476548702&authuser=3)[![](data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==)AndroidDev Nuggetsmobiledevnuggets@gmail.com](/document/d/1AWnii-L0TFqvSDV8pAi59ahHaX_cuePTkpK93OoT8Mw/edit?usp=drive_web&ouid=102861041933476548702&authuser=4)[All Brand accounts](https://myaccount.google.com/brandaccounts?authuser=0&continue=https://docs.google.com/document/d/1AWnii-L0TFqvSDV8pAi59ahHaX_cuePTkpK93OoT8Mw/edit%3Fusp%3Ddrive_web%26ouid%3D102861041933476548702&service=/document/d/1AWnii-L0TFqvSDV8pAi59ahHaX_cuePTkpK93OoT8Mw/edit%3Fusp%3Ddrive_web%26ouid%3D102861041933476548702%26authuser%3D%24authuser)[Add another account](https://accounts.google.com/AddSession?service=wise&continue=https://docs.google.com/document/d/1AWnii-L0TFqvSDV8pAi59ahHaX_cuePTkpK93OoT8Mw/edit?usp%3Ddrive_web%26ouid%3D102861041933476548702&ec=GAlAGQ)[Sign out of all accounts](https://accounts.google.com/Logout?service=wise&continue=https://docs.google.com&ec=GAdAGQ)[Privacy Policy](https://policies.google.com/privacy?hl=en&authuser=0)•[Terms of Service](https://myaccount.google.com/termsofservice?hl=en&authuser=0)FileEditViewInsertFormatToolsAdd-onsHelpAccessibilityDebugLast edit was 13 minutes agoUnsaved changes to DriveSee new changes<input class="docs-omnibox-input jfk-textinput label-input-label" placeholder="Search the menus (Alt+/)" aria-label="Search the menus (Alt+/)" role="combobox" aria-autocomplete="list" style="user-select: none;"><input class="goog-toolbar-combo-button-input jfk-textinput" autocomplete="off" type="text" aria-autocomplete="both" tabindex="-1" aria-label="Zoom" style="user-select: none;">Normal text<input class="goog-toolbar-combo-button-input jfk-textinput" autocomplete="off" type="text" aria-autocomplete="both" tabindex="-1" aria-label="Font size" style="user-select: none;">Image optionsImage optionsReplace imageAccessibilityEditingTo enable screen reader support, press Ctrl+Alt+Z To learn about keyboard shortcuts, press Ctrl+slash

<table cellpadding="0" cellspacing="0" class="docs-findinput-container">

<tbody>

<tr>

<td class="docs-findinput-input-container"><input aria-label="Find in document" autocomplete="off" type="text" spellcheck="false" class="docs-findinput-input" placeholder="Find in document" dir="ltr"></td>

<td class="docs-findinput-count-container">5 of 11</td>

</tr>

</tbody>

</table>

Context:Introduction98765432112345678Table‌ ‌of‌ ‌Contents‌ ‌ ‌Copyright................................................................................................................................‌ ‌1‌ ‌Advance‌ ‌Praise‌ ‌for‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice...................................................................‌ ‌7‌ ‌Listings...................................................................................................................................‌ ‌7‌ ‌Preface..................................................................................................................................‌ ‌12‌ ‌Chapter‌ ‌1.‌ ‌Introduction.........................................................................................................‌ ‌16‌ ‌ ‌Section‌ ‌1.1.‌ ‌A‌ ‌(Very)‌ ‌Brief‌ ‌History‌ ‌of‌ ‌Concurrency.......................................................................................................................................................................‌ ‌16‌ ‌Section‌ ‌1.2.‌ ‌Benefits‌ ‌of‌ ‌Threads.....................................................................................................................................................................................................‌ ‌18‌ ‌Section‌ ‌1.3.‌ ‌Risks‌ ‌of‌ ‌Threads.........................................................................................................................................................................................................‌ ‌20‌ ‌Section‌ ‌1.4.‌ ‌Threads‌ ‌are‌ ‌Everywhere............................................................................................................................................................................................‌ ‌24‌ ‌ ‌Part‌ ‌I:‌ ‌Fundamentals............................................................................................................‌ ‌28‌ ‌Chapter‌ ‌2.‌ ‌Thread‌ ‌Safety...............................................................................................................................................................................................................‌ ‌30‌ ‌Section‌ ‌2.1.‌ ‌What‌ ‌is‌ ‌Thread‌ ‌Safety?..........................................................................................................................................................................................‌ ‌32‌ ‌Section‌ ‌2.2.‌ ‌Atomicity................................................................................................................................................................................................................‌ ‌34‌ ‌Section‌ ‌2.3.‌ ‌Locking...................................................................................................................................................................................................................‌ ‌38‌ ‌Section‌ ‌2.4.‌ ‌Guarding‌ ‌State‌ ‌with‌ ‌Locks....................................................................................................................................................................................‌ ‌42‌ ‌Section‌ ‌2.5.‌ ‌Liveness‌ ‌and‌ ‌Performance.....................................................................................................................................................................................‌ ‌44‌ ‌Chapter‌ ‌3.‌ ‌Sharing‌ ‌Objects...........................................................................................................................................................................................................‌ ‌48‌ ‌Section‌ ‌3.1.‌ ‌Visibility.................................................................................................................................................................................................................‌ ‌48‌ ‌Section‌ ‌3.2.‌ ‌Publication‌ ‌and‌ ‌Escape..........................................................................................................................................................................................‌ ‌54‌ ‌Section‌ ‌3.3.‌ ‌Thread‌ ‌Confinement..............................................................................................................................................................................................‌ ‌57‌ ‌Section‌ ‌3.4.‌ ‌Immutability...........................................................................................................................................................................................................‌ ‌61‌ ‌Section‌ ‌3.5.‌ ‌Safe‌ ‌Publication.....................................................................................................................................................................................................‌ ‌64‌ ‌Chapter‌ ‌4.‌ ‌Composing‌ ‌Objects......................................................................................................................................................................................................‌ ‌70‌ ‌Section‌ ‌4.1.‌ ‌Designing‌ ‌a‌ ‌Thread-safe‌ ‌Class...............................................................................................................................................................................‌ ‌70‌ ‌Section‌ ‌4.2.‌ ‌Instance‌ ‌Confinement............................................................................................................................................................................................‌ ‌73‌ ‌Section‌ ‌4.3.‌ ‌Delegating‌ ‌Thread‌ ‌Safety.......................................................................................................................................................................................‌ ‌77‌ ‌Section‌ ‌4.4.‌ ‌Adding‌ ‌Functionality‌ ‌to‌ ‌Existing‌ ‌Thread-safe‌ ‌Classes.........................................................................................................................................‌ ‌86‌ ‌Section‌ ‌4.5.‌ ‌Documenting‌ ‌Synchronization‌ ‌Policies................................................................................................................................................................‌ ‌89‌ ‌Chapter‌ ‌5.‌ ‌Building‌ ‌Blocks............................................................................................................................................................................................................‌ ‌94‌ ‌Section‌ ‌5.1.‌ ‌Synchronized‌ ‌Collections.......................................................................................................................................................................................‌ ‌94‌ ‌Section‌ ‌5.2.‌ ‌Concurrent‌ ‌Collections..........................................................................................................................................................................................‌ ‌99‌ ‌Section‌ ‌5.3.‌ ‌Blocking‌ ‌Queues‌ ‌and‌ ‌the‌ ‌Producer-consumer‌ ‌Pattern.......................................................................................................................................‌ ‌102‌ ‌Section‌ ‌5.4.‌ ‌Blocking‌ ‌and‌ ‌Interruptible‌ ‌Methods...................................................................................................................................................................‌ ‌107‌ ‌Section‌ ‌5.5.‌ ‌Synchronizers.......................................................................................................................................................................................................‌ ‌109‌ ‌Section‌ ‌5.6.‌ ‌Building‌ ‌an‌ ‌Efficient,‌ ‌Scalable‌ ‌Result‌ ‌Cache.......................................................................................................................................................‌ ‌116‌ ‌Summary‌ ‌of‌ ‌Part‌ ‌I....................................................................................................................................................................................................................‌ ‌125‌ ‌Part‌ ‌II:‌ ‌Structuring‌ ‌Concurrent‌ ‌Applications......................................................................‌ ‌126‌ ‌Chapter‌ ‌6.‌ ‌Task‌ ‌Execution...........................................................................................................................................................................................................‌ ‌128‌ ‌Section‌ ‌6.1.‌ ‌Executing‌ ‌Tasks‌ ‌in‌ ‌Threads.................................................................................................................................................................................‌ ‌128‌ ‌Section‌ ‌6.2.‌ ‌The‌ ‌Executor‌ ‌Framework....................................................................................................................................................................................‌ ‌132‌ ‌Section‌ ‌6.3.‌ ‌Finding‌ ‌Exploitable‌ ‌Parallelism..........................................................................................................................................................................‌ ‌138‌ ‌Summary..................................................................................................................................................................................................................................‌ ‌148‌ ‌Chapter‌ ‌7.‌ ‌Cancellation‌ ‌and‌ ‌Shutdown.......................................................................................................................................................................................‌ ‌150‌ ‌Section‌ ‌7.1.‌ ‌Task‌ ‌Cancellation..................................................................................................................................................................................................‌ ‌150‌ ‌Section‌ ‌7.2.‌ ‌Stopping‌ ‌a‌ ‌Thread-based‌ ‌Service.........................................................................................................................................................................‌ ‌165‌ ‌Section‌ ‌7.3.‌ ‌Handling‌ ‌Abnormal‌ ‌Thread‌ ‌Termination............................................................................................................................................................‌ ‌176‌ ‌Section‌ ‌7.4.‌ ‌JVM‌ ‌Shutdown.....................................................................................................................................................................................................‌ ‌179‌ ‌Summary...................................................................................................................................................................................................................................‌ ‌181‌ ‌Chapter‌ ‌8.‌ ‌Applying‌ ‌Thread‌ ‌Pools..............................................................................................................................................................................................‌ ‌182‌ ‌Section‌ ‌8.1.‌ ‌Implicit‌ ‌Couplings‌ ‌Between‌ ‌Tasks‌ ‌and‌ ‌Execution‌ ‌Policies.................................................................................................................................‌ ‌182‌ ‌Section‌ ‌8.2.‌ ‌Sizing‌ ‌Thread‌ ‌Pools..............................................................................................................................................................................................‌ ‌185‌ ‌Section‌ ‌8.3.‌ ‌Configuring‌ ‌ThreadPoolExecutor........................................................................................................................................................................‌ ‌186‌ ‌Section‌ ‌8.4.‌ ‌Extending‌ ‌ThreadPoolExecutor..........................................................................................................................................................................‌ ‌194‌ ‌Section‌ ‌8.5.‌ ‌Parallelizing‌ ‌Recursive‌ ‌Algorithms.....................................................................................................................................................................‌ ‌196‌ ‌Summary..................................................................................................................................................................................................................................‌ ‌203‌ ‌Chapter‌ ‌9.‌ ‌GUI‌ ‌Applications.......................................................................................................................................................................................................‌ ‌204‌ ‌Section‌ ‌9.1.‌ ‌Why‌ ‌are‌ ‌GUIs‌ ‌Single-threaded?..........................................................................................................................................................................‌ ‌204‌ ‌Section‌ ‌9.2.‌ ‌Short-running‌ ‌GUI‌ ‌Tasks....................................................................................................................................................................................‌ ‌207‌ ‌Section‌ ‌9.3.‌ ‌Long-running‌ ‌GUI‌ ‌Tasks.....................................................................................................................................................................................‌ ‌210‌ ‌Section‌ ‌9.4.‌ ‌Shared‌ ‌Data‌ ‌Models.............................................................................................................................................................................................‌ ‌213‌ ‌Section‌ ‌9.5.‌ ‌Other‌ ‌Forms‌ ‌of‌ ‌Single-threaded‌ ‌Subsystems......................................................................................................................................................‌ ‌217‌ ‌Summary..................................................................................................................................................................................................................................‌ ‌217‌ ‌Part‌ ‌III:‌ ‌Liveness,‌ ‌Performance,‌ ‌and‌ ‌Testing......................................................................‌ ‌218‌ ‌Chapter‌ ‌10.‌ ‌Avoiding‌ ‌Liveness‌ ‌Hazards.....................................................................................................................................................................................‌ ‌220‌ ‌Section‌ ‌10.1.‌ ‌Deadlock.............................................................................................................................................................................................................‌ ‌220‌ ‌Section‌ ‌10.2.‌ ‌Avoiding‌ ‌and‌ ‌Diagnosing‌ ‌Deadlocks.................................................................................................................................................................‌ ‌230‌ ‌Section‌ ‌10.3.‌ ‌Other‌ ‌Liveness‌ ‌Hazards.....................................................................................................................................................................................‌ ‌233‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌Summary..................................................................................................................................................................................................................................‌ ‌235‌ ‌Chapter‌ ‌11.‌ ‌Performance‌ ‌and‌ ‌Scalability....................................................................................................................................................................................‌ ‌236‌ ‌Section‌ ‌11.1.‌ ‌Thinking‌ ‌about‌ ‌Performance..............................................................................................................................................................................‌ ‌236‌ ‌Section‌ ‌11.2.‌ ‌Amdahl’s‌ ‌Law.....................................................................................................................................................................................................‌ ‌240‌ ‌Section‌ ‌11.3.‌ ‌Costs‌ ‌Introduced‌ ‌by‌ ‌Threads.............................................................................................................................................................................‌ ‌244‌ ‌Section‌ ‌11.4.‌ ‌Reducing‌ ‌Lock‌ ‌Contention.................................................................................................................................................................................‌ ‌247‌ ‌Section‌ ‌11.5.‌ ‌Example:‌ ‌Comparing‌ ‌Map‌ ‌Performance............................................................................................................................................................‌ ‌257‌ ‌Section‌ ‌11.6.‌ ‌Reducing‌ ‌Context‌ ‌Switch‌ ‌Overhead...................................................................................................................................................................‌ ‌258‌ ‌Summary..................................................................................................................................................................................................................................‌ ‌260‌ ‌Chapter‌ ‌12.‌ ‌Testing‌ ‌Concurrent‌ ‌Programs.................................................................................................................................................................................‌ ‌262‌ ‌Section‌ ‌12.1.‌ ‌Testing‌ ‌for‌ ‌Correctness.......................................................................................................................................................................................‌ ‌263‌ ‌Section‌ ‌12.2.‌ ‌Testing‌ ‌for‌ ‌Performance.....................................................................................................................................................................................‌ ‌275‌ ‌Section‌ ‌12.3.‌ ‌Avoiding‌ ‌Performance‌ ‌Testing‌ ‌Pitfalls..............................................................................................................................................................‌ ‌281‌ ‌Section‌ ‌12.4.‌ ‌Complementary‌ ‌Testing‌ ‌Approaches................................................................................................................................................................‌ ‌285‌ ‌Summary.................................................................................................................................................................................................................................‌ ‌288‌ ‌Part‌ ‌IV:‌ ‌Advanced‌ ‌Topics....................................................................................................‌ ‌290‌ ‌Chapter‌ ‌13.‌ ‌Explicit‌ ‌Locks...........................................................................................................................................................................................................‌ ‌292‌ ‌Section‌ ‌13.1.‌ ‌Lock‌ ‌and‌ ‌ReentrantLock....................................................................................................................................................................................‌ ‌292‌ ‌Section‌ ‌13.2.‌ ‌Performance‌ ‌Considerations..............................................................................................................................................................................‌ ‌297‌ ‌Section‌ ‌13.3.‌ ‌Fairness..............................................................................................................................................................................................................‌ ‌298‌ ‌Section‌ ‌13.4.‌ ‌Choosing‌ ‌Between‌ ‌Synchronized‌ ‌and‌ ‌ReentrantLock......................................................................................................................................‌ ‌300‌ ‌Section‌ ‌13.5.‌ ‌Read-write‌ ‌Locks................................................................................................................................................................................................‌ ‌301‌ ‌Summary..................................................................................................................................................................................................................................‌ ‌304‌ ‌Chapter‌ ‌14.‌ ‌Building‌ ‌Custom‌ ‌Synchronizers..............................................................................................................................................................................‌ ‌306‌ ‌Section‌ ‌14.1.‌ ‌Managing‌ ‌State‌ ‌Dependence..............................................................................................................................................................................‌ ‌306‌ ‌Section‌ ‌14.2.‌ ‌Using‌ ‌Condition‌ ‌Queues.....................................................................................................................................................................................‌ ‌313‌ ‌Section‌ ‌14.3.‌ ‌Explicit‌ ‌Condition‌ ‌Objects..................................................................................................................................................................................‌ ‌321‌ ‌Section‌ ‌14.4.‌ ‌Anatomy‌ ‌of‌ ‌a‌ ‌Synchronizer................................................................................................................................................................................‌ ‌323‌ ‌Section‌ ‌14.5.‌ ‌AbstractQueuedSynchronizer............................................................................................................................................................................‌ ‌326‌ ‌Section‌ ‌14.6.‌ ‌AQS‌ ‌in‌ ‌Java.util.concurrent‌ ‌Synchronizer‌ ‌Classes...........................................................................................................................................‌ ‌329‌ ‌Summary..................................................................................................................................................................................................................................‌ ‌332‌ ‌Chapter‌ ‌15.‌ ‌Atomic‌ ‌Variables‌ ‌and‌ ‌Nonblocking‌ ‌Synchronization.............................................................................................................................................‌ ‌334‌ ‌Section‌ ‌15.1.‌ ‌Disadvantages‌ ‌of‌ ‌Locking...................................................................................................................................................................................‌ ‌334‌ ‌Section‌ ‌15.2.‌ ‌Hardware‌ ‌Support‌ ‌for‌ ‌Concurrency..................................................................................................................................................................‌ ‌336‌ ‌Section‌ ‌15.3.‌ ‌Atomic‌ ‌Variable‌ ‌Classes.....................................................................................................................................................................................‌ ‌339‌ ‌Section‌ ‌15.4.‌ ‌Nonblocking‌ ‌Algorithms....................................................................................................................................................................................‌ ‌344‌ ‌Summary..................................................................................................................................................................................................................................‌ ‌351‌ ‌Chapter‌ ‌16.‌ ‌The‌ ‌Java‌ ‌Memory‌ ‌Model.........................................................................................................................................................................................‌ ‌352‌ ‌Section‌ ‌16.1.‌ ‌What‌ ‌is‌ ‌a‌ ‌Memory‌ ‌Model,‌ ‌and‌ ‌Why‌ ‌would‌ ‌I‌ ‌Want‌ ‌One?..................................................................................................................................‌ ‌352‌ ‌Section‌ ‌16.2.‌ ‌Publication.........................................................................................................................................................................................................‌ ‌359‌ ‌Section‌ ‌16.3.‌ ‌Initialization‌ ‌Safety............................................................................................................................................................................................‌ ‌364‌ ‌Summary..................................................................................................................................................................................................................................‌ ‌366‌ ‌Appendix‌ ‌A.‌ ‌Annotations‌ ‌for‌ ‌Concurrency.................................................................................................................................................................................‌ ‌368‌ ‌Section‌ ‌A.1.‌ ‌Class‌ ‌Annotations................................................................................................................................................................................................‌ ‌368‌ ‌Section‌ ‌A.2.‌ ‌Field‌ ‌and‌ ‌Method‌ ‌Annotations...........................................................................................................................................................................‌ ‌368‌ ‌Bibliography................................................................................................................................................................................................................................‌ ‌370‌ ‌bvdindexIndex....................................................................................................................‌ ‌374‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌Many‌ ‌of‌ ‌the‌ ‌designations‌ ‌used‌ ‌by‌ ‌manufacturers‌ ‌and‌ ‌sellers‌ ‌to‌ ‌distinguish‌ ‌their‌ ‌products‌ ‌are‌ ‌claimed‌ ‌as‌ ‌trade‌ ‌marks.‌ ‌Where‌ ‌those‌ ‌designations‌ ‌appear‌ ‌in‌ ‌this‌ ‌book,‌ ‌and‌ ‌the‌ ‌publisher‌ ‌was‌ ‌aware‌ ‌of‌ ‌a‌ ‌trademark‌ ‌claim,‌ ‌the‌ ‌designations‌ ‌have‌ ‌been‌ ‌printed‌ ‌with‌ ‌initial‌ ‌capital‌ ‌letters‌ ‌or‌ ‌in‌ ‌all‌ ‌capitals.‌ ‌ ‌The‌ ‌authors‌ ‌and‌ ‌publisher‌ ‌have‌ ‌taken‌ ‌care‌ ‌in‌ ‌the‌ ‌preparation‌ ‌of‌ ‌this‌ ‌book,‌ ‌but‌ ‌make‌ ‌no‌ ‌expressed‌ ‌or‌ ‌implied‌ ‌warranty‌ ‌of‌ ‌any‌ ‌kind‌ ‌and‌ ‌assume‌ ‌no‌ ‌responsibility‌ ‌for‌ ‌errors‌ ‌or‌ ‌omissions.‌ ‌No‌ ‌liability‌ ‌is‌ ‌assumed‌ ‌for‌ ‌incidental‌ ‌or‌ ‌consequential‌ ‌damages‌ ‌in‌ ‌connection‌ ‌with‌ ‌or‌ ‌arising‌ ‌out‌ ‌of‌ ‌the‌ ‌use‌ ‌of‌ ‌the‌ ‌information‌ ‌or‌ ‌programs‌ ‌contained‌ ‌herein.‌ ‌ ‌The‌ ‌publisher‌ ‌offers‌ ‌excellent‌ ‌discounts‌ ‌on‌ ‌this‌ ‌book‌ ‌when‌ ‌ordered‌ ‌in‌ ‌quantity‌ ‌for‌ ‌bulk‌ ‌purchases‌ ‌or‌ ‌special‌ ‌sales,‌ ‌which‌ ‌may‌ ‌include‌ ‌electronic‌ ‌versions‌ ‌and/or‌ ‌custom‌ ‌covers‌ ‌and‌ ‌content‌ ‌particular‌ ‌to‌ ‌your‌ ‌business,‌ ‌training‌ ‌goals,‌ ‌marketing‌ ‌focus,‌ ‌and‌ ‌branding‌ ‌interests.‌ ‌For‌ ‌more‌ ‌information,‌ ‌please‌ ‌contact:‌ ‌ ‌U.S.‌ ‌Corporate‌ ‌and‌ ‌Government‌ ‌Sales‌ ‌ ‌(800)‌ ‌382-3419‌ ‌ ‌corpsales@pearsontechgroup.com‌ ‌ ‌For‌ ‌sales‌ ‌outside‌ ‌the‌ ‌United‌ ‌States,‌ ‌please‌ ‌contact:‌ ‌ ‌International‌ ‌Sales‌ ‌ ‌international@pearsoned.com‌ ‌ ‌Visit‌ ‌us‌ ‌on‌ ‌the‌ ‌Web:‌ ‌www.awprofessional.com‌ ‌ ‌This‌ ‌Book‌ ‌Is‌ ‌Safari‌ ‌Enabled‌ ‌ ‌The‌ ‌Safari®‌ ‌Enabled‌ ‌icon‌ ‌on‌ ‌the‌ ‌cover‌ ‌of‌ ‌your‌ ‌favorite‌ ‌technology‌ ‌book‌ ‌means‌ ‌the‌ ‌book‌ ‌is‌ ‌ ‌available‌ ‌through‌ ‌Safari‌ ‌Bookshelf.‌ ‌When‌ ‌you‌ ‌buy‌ ‌this‌ ‌book,‌ ‌you‌ ‌get‌ ‌free‌ ‌access‌ ‌to‌ ‌the‌ ‌online‌ ‌ ‌edition‌ ‌for‌ ‌45‌ ‌days.‌ ‌ ‌Safari‌ ‌Bookshelf‌ ‌is‌ ‌an‌ ‌electronic‌ ‌reference‌ ‌library‌ ‌that‌ ‌lets‌ ‌you‌ ‌easily‌ ‌search‌ ‌thousands‌ ‌of‌ ‌technical‌ ‌books,‌ ‌find‌ ‌code‌ ‌samples,‌ ‌download‌ ‌chapters,‌ ‌and‌ ‌access‌ ‌technical‌ ‌information‌ ‌whenever‌ ‌and‌ ‌wherever‌ ‌you‌ ‌need‌ ‌it.‌ ‌ ‌To‌ ‌gain‌ ‌45-day‌ ‌Safari‌ ‌Enabled‌ ‌access‌ ‌to‌ ‌this‌ ‌book:‌ ‌ ‌•‌ ‌Go‌ ‌to‌ ‌http://www.awprofessional.com/safarienabled‌ ‌ ‌•‌ ‌Complete‌ ‌the‌ ‌brief‌ ‌registration‌ ‌form‌ ‌ ‌•‌ ‌Enter‌ ‌the‌ ‌coupon‌ ‌code‌ ‌UUIR-XRJG-JWWF-AHGM-137Z‌ ‌ ‌If‌ ‌you‌ ‌have‌ ‌difficulty‌ ‌registering‌ ‌on‌ ‌Safari‌ ‌Bookshelf‌ ‌or‌ ‌accessing‌ ‌the‌ ‌online‌ ‌edition,‌ ‌please‌ ‌e-mail‌ ‌customer-ser‌ ‌vice@safaribooksonline.com.‌ ‌ ‌Library‌ ‌of‌ ‌Congress‌ ‌Cataloging-in-Publication‌ ‌Data‌ ‌ ‌Goetz,‌ ‌Brian.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice‌ ‌/‌ ‌Brian‌ ‌Goetz,‌ ‌with‌ ‌Tim‌ ‌Peierls.‌ ‌.‌ ‌.‌ ‌[et‌ ‌al.]‌ ‌ ‌p.‌ ‌cm.‌ ‌ ‌Includes‌ ‌bibliographical‌ ‌references‌ ‌and‌ ‌index.‌ ‌ ‌ISBN‌ ‌0-321-34960-1‌ ‌(pbk.‌ ‌:‌ ‌alk.‌ ‌paper)‌ ‌ ‌1.‌ ‌Java‌ ‌(Computer‌ ‌program‌ ‌language)‌ ‌2.‌ ‌Parallel‌ ‌programming‌ ‌(Computer‌ ‌science)‌ ‌3.‌ ‌Threads‌ ‌(Computer‌ ‌ ‌programs)‌ ‌I.‌ ‌Title.‌ ‌ ‌QA76.73.J38G588‌ ‌2006‌ ‌ ‌005.13'3--dc22‌ ‌2006012205‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc.‌ ‌ ‌ISBN‌ ‌0-321-34960-1‌ ‌ ‌Text‌ ‌printed‌ ‌in‌ ‌the‌ ‌United‌ ‌States‌ ‌on‌ ‌recycled‌ ‌paper‌ ‌at‌ ‌Courier‌ ‌Stoughton‌ ‌in‌ ‌Stoughton,‌ ‌Massachusetts.‌ ‌9th‌ ‌Printing‌ ‌March‌ ‌2010‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌Licensed‌ ‌by‌ ‌Salesh‌ ‌Kumar‌ ‌‌To‌ ‌Jessica‌ ‌ ‌1821604‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌ ‌This‌ ‌page‌ ‌intentionally‌ ‌left‌ ‌blank‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌Contents‌ ‌ ‌Listings‌ ‌xii‌ ‌ ‌Preface‌ ‌xvii‌ ‌ ‌1‌ ‌‌Introduction‌ ‌‌1‌ ‌ ‌1‌.‌1‌ ‌‌A‌ ‌(very)‌ ‌brief‌ ‌history‌ ‌of‌ ‌concurrency‌ ‌.‌ ‌..................‌ ‌‌1‌ ‌ ‌1‌.‌2‌ ‌‌Benefits‌ ‌of‌ ‌threads‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌3‌ ‌ ‌1‌.‌3‌ ‌‌Risks‌ ‌of‌ ‌threads‌ ‌.‌ ‌.‌ ‌.............................‌ ‌‌5‌ ‌ ‌1‌.‌4‌ ‌‌Threads‌ ‌are‌ ‌everywhere‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌9‌ ‌ ‌I‌ ‌Fundamentals‌ ‌‌13‌ ‌ ‌2‌ ‌‌Thread‌ ‌Safety‌ ‌‌15‌ ‌ ‌2‌.‌1‌ ‌‌What‌ ‌is‌ ‌thread‌ ‌safety?‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌17‌ ‌ ‌2‌.‌2‌ ‌‌Atomicity‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌19‌ ‌ ‌2‌.‌3‌ ‌‌Locking‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌23‌ ‌ ‌2‌.‌4‌ ‌‌Guarding‌ ‌state‌ ‌with‌ ‌locks‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌27‌ ‌ ‌2‌.‌5‌ ‌‌Liveness‌ ‌and‌ ‌performance‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌29‌ ‌ ‌3‌ ‌‌Sharing‌ ‌Objects‌ ‌‌33‌ ‌ ‌3‌.‌1‌ ‌‌Visibility‌ ‌.‌ ‌.‌ ‌.................................‌ ‌‌33‌ ‌ ‌3‌.‌2‌ ‌‌Publication‌ ‌and‌ ‌escape‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌39‌ ‌ ‌3‌.‌3‌ ‌‌Thread‌ ‌confinement‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌42‌ ‌ ‌3‌.‌4‌ ‌‌Immutability‌ ‌.................................‌ ‌‌46‌ ‌ ‌3‌.‌5‌ ‌‌Safe‌ ‌publication‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌49‌ ‌ ‌4‌ ‌‌Composing‌ ‌Objects‌ ‌‌55‌ ‌ ‌4‌.‌1‌ ‌‌Designing‌ ‌a‌ ‌thread-safe‌ ‌class‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌..................‌ ‌‌55‌ ‌ ‌4‌.‌2‌ ‌‌Instance‌ ‌confinement‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌58‌ ‌ ‌4‌.‌3‌ ‌‌Delegating‌ ‌thread‌ ‌safety‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌62‌ ‌ ‌4‌.‌4‌ ‌‌Adding‌ ‌functionality‌ ‌to‌ ‌existing‌ ‌thread-safe‌ ‌classes‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌71‌ ‌ ‌4‌.‌5‌ ‌‌Documenting‌ ‌synchronization‌ ‌policies‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌74‌ ‌ ‌ix‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌x‌ ‌‌Contents‌ ‌ ‌5‌ ‌‌Building‌ ‌Blocks‌ ‌‌79‌ ‌ ‌5‌.‌1‌ ‌‌Synchronized‌ ‌collections‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌79‌ ‌ ‌5‌.‌2‌ ‌‌Concurrent‌ ‌collections‌ ‌.‌ ‌.‌ ‌.........................‌ ‌‌84‌ ‌ ‌5‌.‌3‌ ‌‌Blocking‌ ‌queues‌ ‌and‌ ‌the‌ ‌producer-consumer‌ ‌pattern‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌87‌ ‌ ‌5‌.‌4‌ ‌‌Blocking‌ ‌and‌ ‌interruptible‌ ‌methods‌ ‌.‌ ‌..................‌ ‌‌92‌ ‌ ‌5‌.‌5‌ ‌‌Synchronizers‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌94‌ ‌ ‌5‌.‌6‌ ‌‌Building‌ ‌an‌ ‌efficient,‌ ‌scalable‌ ‌result‌ ‌cache‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌101‌ ‌ ‌II‌ ‌Structuring‌ ‌Concurrent‌ ‌Applications‌ ‌‌111‌ ‌ ‌6‌ ‌‌Task‌ ‌Execution‌ ‌‌113‌ ‌ ‌6‌.‌1‌ ‌‌Executing‌ ‌tasks‌ ‌in‌ ‌threads‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌113‌ ‌ ‌6‌.‌2‌ ‌‌The‌ ‌‌Executor‌ ‌‌framework‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌117‌ ‌ ‌6‌.‌3‌ ‌‌Finding‌ ‌exploitable‌ ‌parallelism‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌..................‌ ‌‌123‌ ‌ ‌7‌ ‌‌Cancellation‌ ‌and‌ ‌Shutdown‌ ‌‌135‌ ‌ ‌7‌.‌1‌ ‌‌Task‌ ‌cancellation‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌135‌ ‌ ‌7‌.‌2‌ ‌‌Stopping‌ ‌a‌ ‌thread-based‌ ‌service‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌150‌ ‌ ‌7‌.‌3‌ ‌‌Handling‌ ‌abnormal‌ ‌thread‌ ‌termination‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌161‌ ‌ ‌7‌.‌4‌ ‌‌JVM‌ ‌shutdown‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌164‌ ‌ ‌8‌ ‌‌Applying‌ ‌Thread‌ ‌Pools‌ ‌‌167‌ ‌ ‌8‌.‌1‌ ‌‌Implicit‌ ‌couplings‌ ‌between‌ ‌tasks‌ ‌and‌ ‌execution‌ ‌policies‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌167‌ ‌ ‌8‌.‌2‌ ‌‌Sizing‌ ‌thread‌ ‌pools‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌170‌ ‌ ‌8‌.‌3‌ ‌‌Configuring‌ ‌‌ThreadPoolExecutor‌ ‌‌....................‌ ‌‌171‌ ‌ ‌8‌.‌4‌ ‌‌Extending‌ ‌‌ThreadPoolExecutor‌ ‌‌.....................‌ ‌‌179‌ ‌ ‌8‌.‌5‌ ‌‌Parallelizing‌ ‌recursive‌ ‌algorithms‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌181‌ ‌ ‌9‌ ‌‌GUI‌ ‌Applications‌ ‌‌189‌ ‌ ‌9‌.‌1‌ ‌‌Why‌ ‌are‌ ‌GUIs‌ ‌single-threaded?‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌..................‌ ‌‌189‌ ‌ ‌9‌.‌2‌ ‌‌Short-running‌ ‌GUI‌ ‌tasks‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌192‌ ‌ ‌9‌.‌3‌ ‌‌Long-running‌ ‌GUI‌ ‌tasks‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌195‌ ‌ ‌9‌.‌4‌ ‌‌Shared‌ ‌data‌ ‌models‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌198‌ ‌ ‌9‌.‌5‌ ‌‌Other‌ ‌forms‌ ‌of‌ ‌single-threaded‌ ‌subsystems‌ ‌.‌ ‌..............‌ ‌‌202‌ ‌ ‌III‌ ‌Liveness,‌ ‌Performance,‌ ‌and‌ ‌Testing‌ ‌‌203‌ ‌ ‌10‌ ‌‌Avoiding‌ ‌Liveness‌ ‌Hazards‌ ‌‌205‌ ‌ ‌10‌.‌1‌ ‌‌Deadlock‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌205‌ ‌ ‌10‌.‌2‌ ‌‌Avoiding‌ ‌and‌ ‌diagnosing‌ ‌deadlocks‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌215‌ ‌ ‌10‌.‌3‌ ‌‌Other‌ ‌liveness‌ ‌hazards‌ ‌.‌ ‌.‌ ‌.........................‌ ‌‌218‌ ‌ ‌11‌ ‌‌Performance‌ ‌and‌ ‌Scalability‌ ‌‌221‌ ‌ ‌11‌.‌1‌ ‌‌Thinking‌ ‌about‌ ‌performance‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌221‌ ‌ ‌11‌.‌2‌ ‌‌Amdahl’s‌ ‌law‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌225‌ ‌ ‌11‌.‌3‌ ‌‌Costs‌ ‌introduced‌ ‌by‌ ‌threads‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌229‌ ‌ ‌11‌.‌4‌ ‌‌Reducing‌ ‌lock‌ ‌contention‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌232‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌Contents‌ ‌‌xi‌ ‌ ‌11‌.‌5‌ ‌‌Example:‌ ‌Comparing‌ ‌‌Map‌ ‌‌performance‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌242‌ ‌ ‌11‌.‌6‌ ‌‌Reducing‌ ‌context‌ ‌switch‌ ‌overhead‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌243‌ ‌ ‌12‌ ‌‌Testing‌ ‌Concurrent‌ ‌Programs‌ ‌‌247‌ ‌ ‌12‌.‌1‌ ‌‌Testing‌ ‌for‌ ‌correctness‌ ‌.‌ ‌.‌ ‌.........................‌ ‌‌248‌ ‌ ‌12‌.‌2‌ ‌‌Testing‌ ‌for‌ ‌performance‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌260‌ ‌ ‌12‌.‌3‌ ‌‌Avoiding‌ ‌performance‌ ‌testing‌ ‌pitfalls‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌266‌ ‌ ‌12‌.‌4‌ ‌‌Complementary‌ ‌testing‌ ‌approaches‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌270‌ ‌ ‌IV‌ ‌Advanced‌ ‌Topics‌ ‌‌275‌ ‌ ‌13‌ ‌‌Explicit‌ ‌Locks‌ ‌‌277‌ ‌ ‌13‌.‌1‌ ‌‌Lock‌ ‌‌and‌ ‌‌ReentrantLock‌ ‌‌..........................‌ ‌‌277‌ ‌ ‌13‌.‌2‌ ‌‌Performance‌ ‌considerations‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌..................‌ ‌‌282‌ ‌ ‌13‌.‌3‌ ‌‌Fairness‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌283‌ ‌ ‌13‌.‌4‌ ‌‌Choosing‌ ‌between‌ ‌‌synchronized‌ ‌‌and‌ ‌‌ReentrantLock‌ ‌‌.........‌ ‌‌285‌ ‌ ‌13‌.‌5‌ ‌‌Read-write‌ ‌locks‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌286‌ ‌ ‌14‌ ‌‌Building‌ ‌Custom‌ ‌Synchronizers‌ ‌‌291‌ ‌ ‌14‌.‌1‌ ‌‌Managing‌ ‌state‌ ‌dependence‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌291‌ ‌ ‌14‌.‌2‌ ‌‌Using‌ ‌condition‌ ‌queues‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌298‌ ‌ ‌14‌.‌3‌ ‌‌Explicit‌ ‌condition‌ ‌objects‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌306‌ ‌ ‌14‌.‌4‌ ‌‌Anatomy‌ ‌of‌ ‌a‌ ‌synchronizer‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌308‌ ‌ ‌14‌.‌5‌ ‌‌AbstractQueuedSynchronizer‌ ‌‌......................‌ ‌‌311‌ ‌ ‌14‌.‌6‌ ‌‌AQS‌ ‌in‌ ‌‌java.util.concurrent‌ ‌‌synchronizer‌ ‌classes‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌314‌ ‌ ‌15‌ ‌‌Atomic‌ ‌Variables‌ ‌and‌ ‌Nonblocking‌ ‌Synchronization‌ ‌‌319‌ ‌ ‌15‌.‌1‌ ‌‌Disadvantages‌ ‌of‌ ‌locking‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌319‌ ‌ ‌15‌.‌2‌ ‌‌Hardware‌ ‌support‌ ‌for‌ ‌concurrency‌ ‌.‌ ‌.‌ ‌..................‌ ‌‌321‌ ‌ ‌15‌.‌3‌ ‌‌Atomic‌ ‌variable‌ ‌classes‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌324‌ ‌ ‌15‌.‌4‌ ‌‌Nonblocking‌ ‌algorithms‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌329‌ ‌ ‌16‌ ‌‌The‌ ‌Java‌ ‌Memory‌ ‌Model‌ ‌‌337‌ ‌ ‌16‌.‌1‌ ‌‌What‌ ‌is‌ ‌a‌ ‌memory‌ ‌model,‌ ‌and‌ ‌why‌ ‌would‌ ‌I‌ ‌want‌ ‌one?‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌337‌ ‌ ‌16‌.‌2‌ ‌‌Publication‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌344‌ ‌ ‌16‌.‌3‌ ‌‌Initialization‌ ‌safety‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌349‌ ‌ ‌A‌ ‌Annotations‌ ‌for‌ ‌Concurrency‌ ‌‌353‌ ‌ ‌A.‌1‌ ‌‌Class‌ ‌annotations‌ ‌.‌ ‌.............................‌ ‌‌353‌ ‌ ‌A.‌2‌ ‌‌Field‌ ‌and‌ ‌method‌ ‌annotations‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌..................‌ ‌‌353‌ ‌ ‌Bibliography‌ ‌‌355‌ ‌ ‌Index‌ ‌‌359‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌Listings‌ ‌ ‌1‌ ‌‌Bad‌ ‌way‌ ‌to‌ ‌sort‌ ‌a‌ ‌list.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌xix‌ ‌ ‌2‌ ‌‌Less‌ ‌than‌ ‌optimal‌ ‌way‌ ‌to‌ ‌sort‌ ‌a‌ ‌list.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌xx‌ ‌ ‌1‌.‌1‌ ‌‌Non-thread-safe‌ ‌sequence‌ ‌generator.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌6‌ ‌ ‌1‌.‌2‌ ‌‌Thread-safe‌ ‌sequence‌ ‌generator.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌7‌ ‌ ‌2‌.‌1‌ ‌‌A‌ ‌stateless‌ ‌servlet.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌18‌ ‌ ‌2‌.‌2‌ ‌‌Servlet‌ ‌that‌ ‌counts‌ ‌requests‌ ‌without‌ ‌the‌ ‌necessary‌ ‌synchroniza‌ ‌ ‌tion.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌.............................‌ ‌‌19‌ ‌ ‌2‌.‌3‌ ‌‌Race‌ ‌condition‌ ‌in‌ ‌lazy‌ ‌initialization.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌..........‌ ‌‌21‌ ‌ ‌2‌.‌4‌ ‌‌Servlet‌ ‌that‌ ‌counts‌ ‌requests‌ ‌using‌ ‌‌AtomicLong‌.‌ ‌............‌ ‌‌23‌ ‌ ‌2‌.‌5‌ ‌‌Servlet‌ ‌that‌ ‌attempts‌ ‌to‌ ‌cache‌ ‌its‌ ‌last‌ ‌result‌ ‌without‌ ‌adequate‌ ‌ ‌atomicity.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌..........................‌ ‌‌24‌ ‌ ‌2‌.‌6‌ ‌‌Servlet‌ ‌that‌ ‌caches‌ ‌last‌ ‌result,‌ ‌but‌ ‌with‌ ‌unnacceptably‌ ‌poor‌ ‌con‌ ‌ ‌currency.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌...........................‌ ‌‌26‌ ‌ ‌2‌.‌7‌ ‌‌Code‌ ‌that‌ ‌would‌ ‌deadlock‌ ‌if‌ ‌intrinsic‌ ‌locks‌ ‌were‌ ‌not‌ ‌reentrant.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌27‌ ‌ ‌2‌.‌8‌ ‌‌Servlet‌ ‌that‌ ‌caches‌ ‌its‌ ‌last‌ ‌request‌ ‌and‌ ‌result.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌31‌ ‌ ‌3‌.‌1‌ ‌‌Sharing‌ ‌variables‌ ‌without‌ ‌synchronization.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌......‌ ‌‌34‌ ‌ ‌3‌.‌2‌ ‌‌Non-thread-safe‌ ‌mutable‌ ‌integer‌ ‌holder.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌36‌ ‌ ‌3‌.‌3‌ ‌‌Thread-safe‌ ‌mutable‌ ‌integer‌ ‌holder.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌36‌ ‌ ‌3‌.‌4‌ ‌‌Counting‌ ‌sheep.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌39‌ ‌ ‌3‌.‌5‌ ‌‌Publishing‌ ‌an‌ ‌object.‌ ‌.‌ ‌.‌ ‌.........................‌ ‌‌40‌ ‌ ‌5‌.‌16‌ ‌‌Initial‌ ‌cache‌ ‌attempt‌ ‌using‌ ‌‌HashMap‌ ‌‌and‌ ‌synchronization.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌103‌ ‌ ‌5‌.‌17‌ ‌‌Replacing‌ ‌‌HashMap‌ ‌‌with‌ ‌‌ConcurrentHashMap‌..............‌ ‌‌105‌ ‌ ‌5‌.‌18‌ ‌‌Memoizing‌ ‌wrapper‌ ‌using‌ ‌‌FutureTask‌.‌ ‌................‌ ‌‌106‌ ‌ ‌5‌.‌19‌ ‌‌Final‌ ‌implementation‌ ‌of‌ ‌‌Memoizer‌.‌ ‌...................‌ ‌‌108‌ ‌ ‌5‌.‌20‌ ‌‌Factorizing‌ ‌servlet‌ ‌that‌ ‌caches‌ ‌results‌ ‌using‌ ‌‌Memoizer‌..‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌109‌ ‌ ‌6‌.‌1‌ ‌‌Sequential‌ ‌web‌ ‌server.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌114‌ ‌ ‌6‌.‌2‌ ‌‌Web‌ ‌server‌ ‌that‌ ‌starts‌ ‌a‌ ‌new‌ ‌thread‌ ‌for‌ ‌each‌ ‌request.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌115‌ ‌ ‌6‌.‌3‌ ‌‌Executor‌ ‌‌interface.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌117‌ ‌ ‌6‌.‌4‌ ‌‌Web‌ ‌server‌ ‌using‌ ‌a‌ ‌thread‌ ‌pool.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌118‌ ‌ ‌6‌.‌5‌ ‌‌Executor‌ ‌‌that‌ ‌starts‌ ‌a‌ ‌new‌ ‌thread‌ ‌for‌ ‌each‌ ‌task.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌118‌ ‌ ‌6‌.‌6‌ ‌‌Executor‌ ‌‌that‌ ‌executes‌ ‌tasks‌ ‌synchronously‌ ‌in‌ ‌the‌ ‌calling‌ ‌thread.‌ ‌.‌ ‌‌119‌ ‌ ‌6‌.‌7‌ ‌‌Lifecycle‌ ‌methods‌ ‌in‌ ‌‌ExecutorService‌.‌ ‌................‌ ‌‌121‌ ‌ ‌6‌.‌8‌ ‌‌Web‌ ‌server‌ ‌with‌ ‌shutdown‌ ‌support.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌122‌ ‌ ‌6‌.‌9‌ ‌‌Class‌ ‌illustrating‌ ‌confusing‌ ‌‌Timer‌ ‌‌behavior.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌124‌ ‌ ‌6‌.‌10‌ ‌‌Rendering‌ ‌page‌ ‌elements‌ ‌sequentially.‌ ‌.‌ ‌.‌ ‌.‌ ‌..............‌ ‌‌125‌ ‌ ‌6‌.‌11‌ ‌‌Callable‌ ‌‌and‌ ‌‌Future‌ ‌‌interfaces.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌126‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌xiv‌ ‌‌Listings‌ ‌ ‌6‌.‌12‌ ‌‌Default‌ ‌implementation‌ ‌of‌ ‌‌newTaskFor‌ ‌‌in‌ ‌‌ThreadPoolExecutor‌...‌ ‌‌126‌ ‌ ‌6‌.‌13‌ ‌‌Waiting‌ ‌for‌ ‌image‌ ‌download‌ ‌with‌ ‌‌Future‌................‌ ‌‌128‌ ‌ ‌6‌.‌14‌ ‌‌QueueingFuture‌ ‌‌class‌ ‌used‌ ‌by‌ ‌‌ExecutorCompletionService‌.....‌ ‌‌129‌ ‌ ‌6‌.‌15‌ ‌‌Using‌ ‌‌CompletionService‌ ‌‌to‌ ‌render‌ ‌page‌ ‌elements‌ ‌as‌ ‌they‌ ‌be‌ ‌ ‌come‌ ‌available.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌130‌ ‌ ‌6‌.‌16‌ ‌‌Fetching‌ ‌an‌ ‌advertisement‌ ‌with‌ ‌a‌ ‌time‌ ‌budget.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌132‌ ‌ ‌6‌.‌17‌ ‌‌Requesting‌ ‌travel‌ ‌quotes‌ ‌under‌ ‌a‌ ‌time‌ ‌budget.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌134‌ ‌ ‌7‌.‌1‌ ‌‌Using‌ ‌a‌ ‌‌volatile‌ ‌‌field‌ ‌to‌ ‌hold‌ ‌cancellation‌ ‌state.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌137‌ ‌ ‌7‌.‌2‌ ‌‌Generating‌ ‌a‌ ‌second’s‌ ‌worth‌ ‌of‌ ‌prime‌ ‌numbers.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌137‌ ‌ ‌7‌.‌3‌ ‌‌Unreliable‌ ‌cancellation‌ ‌that‌ ‌can‌ ‌leave‌ ‌producers‌ ‌stuck‌ ‌in‌ ‌a‌ ‌block‌ ‌ ‌ing‌ ‌operation.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌........................‌ ‌‌139‌ ‌ ‌7‌.‌4‌ ‌‌Interruption‌ ‌methods‌ ‌in‌ ‌‌Thread‌..‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌139‌ ‌ ‌7‌.‌5‌ ‌‌Using‌ ‌interruption‌ ‌for‌ ‌cancellation.‌ ‌.‌ ‌..................‌ ‌‌141‌ ‌ ‌7‌.‌6‌ ‌‌Propagating‌ ‌‌InterruptedException‌ ‌‌to‌ ‌callers.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌143‌ ‌ ‌7‌.‌7‌ ‌‌Noncancelable‌ ‌task‌ ‌that‌ ‌restores‌ ‌interruption‌ ‌before‌ ‌exit.‌ ‌......‌ ‌‌144‌ ‌ ‌7‌.‌8‌ ‌‌Scheduling‌ ‌an‌ ‌interrupt‌ ‌on‌ ‌a‌ ‌borrowed‌ ‌thread.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌....‌ ‌‌145‌ ‌ ‌7‌.‌9‌ ‌‌Interrupting‌ ‌a‌ ‌task‌ ‌in‌ ‌a‌ ‌dedicated‌ ‌thread.‌ ‌.‌ ‌..............‌ ‌‌146‌ ‌ ‌7‌.‌10‌ ‌‌Cancelling‌ ‌a‌ ‌task‌ ‌using‌ ‌‌Future‌.‌ ‌.....................‌ ‌‌147‌ ‌ ‌7‌.‌11‌ ‌‌Encapsulating‌ ‌nonstandard‌ ‌cancellation‌ ‌in‌ ‌a‌ ‌‌Thread‌ ‌‌by‌ ‌overriding‌ ‌ ‌interrupt‌.‌ ‌.................................‌ ‌‌149‌ ‌ ‌7‌.‌12‌ ‌‌Encapsulating‌ ‌nonstandard‌ ‌cancellation‌ ‌in‌ ‌a‌ ‌task‌ ‌with‌ ‌‌newTaskFor‌.‌ ‌‌151‌ ‌ ‌7‌.‌13‌ ‌‌Producer-consumer‌ ‌logging‌ ‌service‌ ‌with‌ ‌no‌ ‌shutdown‌ ‌support.‌ ‌.‌ ‌.‌ ‌‌152‌ ‌ ‌7‌.‌14‌ ‌‌Unreliable‌ ‌way‌ ‌to‌ ‌add‌ ‌shutdown‌ ‌support‌ ‌to‌ ‌the‌ ‌logging‌ ‌service.‌ ‌.‌ ‌.‌ ‌‌153‌ ‌ ‌7‌.‌15‌ ‌‌Adding‌ ‌reliable‌ ‌cancellation‌ ‌to‌ ‌‌LogWriter‌..‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌154‌ ‌ ‌7‌.‌16‌ ‌‌Logging‌ ‌service‌ ‌that‌ ‌uses‌ ‌an‌ ‌‌ExecutorService‌.............‌ ‌‌155‌ ‌ ‌7‌.‌17‌ ‌‌Shutdown‌ ‌with‌ ‌poison‌ ‌pill.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌..................‌ ‌‌156‌ ‌ ‌7‌.‌18‌ ‌‌Producer‌ ‌thread‌ ‌for‌ ‌‌IndexingService‌..................‌ ‌‌157‌ ‌ ‌7‌.‌19‌ ‌‌Consumer‌ ‌thread‌ ‌for‌ ‌‌IndexingService‌.‌ ‌................‌ ‌‌157‌ ‌ ‌7‌.‌20‌ ‌‌Using‌ ‌a‌ ‌private‌ ‌‌Executor‌ ‌‌whose‌ ‌lifetime‌ ‌is‌ ‌bounded‌ ‌by‌ ‌a‌ ‌method‌ ‌ ‌call.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌158‌ ‌ ‌7‌.‌21‌ ‌‌ExecutorService‌ ‌‌that‌ ‌keeps‌ ‌track‌ ‌of‌ ‌cancelled‌ ‌tasks‌ ‌after‌ ‌shutdown.‌159‌ ‌ ‌7‌.‌22‌ ‌‌Using‌ ‌‌TrackingExecutorService‌ ‌‌to‌ ‌save‌ ‌unfinished‌ ‌tasks‌ ‌for‌ ‌later‌ ‌ ‌execution.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌160‌ ‌ ‌7‌.‌23‌ ‌‌Typical‌ ‌thread-pool‌ ‌worker‌ ‌thread‌ ‌structure.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌162‌ ‌ ‌7‌.‌24‌ ‌‌UncaughtExceptionHandler‌ ‌‌interface.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌163‌ ‌ ‌7‌.‌25‌ ‌‌UncaughtExceptionHandler‌ ‌‌that‌ ‌logs‌ ‌the‌ ‌exception.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌163‌ ‌ ‌7‌.‌26‌ ‌‌Registering‌ ‌a‌ ‌shutdown‌ ‌hook‌ ‌to‌ ‌stop‌ ‌the‌ ‌logging‌ ‌service.‌ ‌......‌ ‌‌165‌ ‌ ‌8‌.‌1‌ ‌‌Task‌ ‌that‌ ‌deadlocks‌ ‌in‌ ‌a‌ ‌single-threaded‌ ‌‌Executor‌.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌.‌ ‌.‌ ‌‌169‌ ‌ ‌8‌.‌2‌ ‌‌General‌ ‌constructor‌ ‌for‌ ‌‌ThreadPoolExecutor‌..............‌ ‌‌172‌ ‌ ‌8‌.‌3‌ ‌‌Creating‌ ‌a‌ ‌fixed-sized‌ ‌thread‌ ‌pool‌ ‌with‌ ‌a‌ ‌bounded‌ ‌queue‌ ‌and‌ ‌the‌ ‌ ‌caller-runs‌ ‌saturation‌ ‌policy.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌175‌ ‌ ‌8‌.‌4‌ ‌‌Using‌ ‌a‌ ‌‌Semaphore‌ ‌‌to‌ ‌throttle‌ ‌task‌ ‌submission.‌ ‌.‌ ‌.‌ ‌..........‌ ‌‌176‌ ‌ ‌8‌.‌5‌ ‌‌ThreadFactory‌ ‌‌interface.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌176‌ ‌ ‌8‌.‌6‌ ‌‌Custom‌ ‌thread‌ ‌factory.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌177‌ ‌ ‌8‌.‌7‌ ‌‌Custom‌ ‌thread‌ ‌base‌ ‌class.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌178‌ ‌ ‌8‌.‌8‌ ‌‌Modifying‌ ‌an‌ ‌‌Executor‌ ‌‌created‌ ‌with‌ ‌the‌ ‌standard‌ ‌factories.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌179‌ ‌ ‌8‌.‌9‌ ‌‌Thread‌ ‌pool‌ ‌extended‌ ‌with‌ ‌logging‌ ‌and‌ ‌timing.‌ ‌.‌ ‌..........‌ ‌‌180‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌Listings‌ ‌‌xv‌ ‌ ‌8‌.‌10‌ ‌‌Transforming‌ ‌sequential‌ ‌execution‌ ‌into‌ ‌parallel‌ ‌execution.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌181‌ ‌ ‌8‌.‌11‌ ‌‌Transforming‌ ‌sequential‌ ‌tail-recursion‌ ‌into‌ ‌parallelized‌ ‌recursion.‌ ‌.‌ ‌‌182‌ ‌ ‌8‌.‌12‌ ‌‌Waiting‌ ‌for‌ ‌results‌ ‌to‌ ‌be‌ ‌calculated‌ ‌in‌ ‌parallel.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌182‌ ‌ ‌8‌.‌13‌ ‌‌Abstraction‌ ‌for‌ ‌puzzles‌ ‌like‌ ‌the‌ ‌“sliding‌ ‌blocks‌ ‌puzzle”.‌ ‌.‌ ‌......‌ ‌‌183‌ ‌ ‌8‌.‌14‌ ‌‌Link‌ ‌node‌ ‌for‌ ‌the‌ ‌puzzle‌ ‌solver‌ ‌framework.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌184‌ ‌ ‌8‌.‌15‌ ‌‌Sequential‌ ‌puzzle‌ ‌solver.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌185‌ ‌ ‌8‌.‌16‌ ‌‌Concurrent‌ ‌version‌ ‌of‌ ‌puzzle‌ ‌solver.‌ ‌..................‌ ‌‌186‌ ‌ ‌8‌.‌17‌ ‌‌Result-bearing‌ ‌latch‌ ‌used‌ ‌by‌ ‌‌ConcurrentPuzzleSolver‌........‌ ‌‌187‌ ‌ ‌8‌.‌18‌ ‌‌Solver‌ ‌that‌ ‌recognizes‌ ‌when‌ ‌no‌ ‌solution‌ ‌exists.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌188‌ ‌ ‌9‌.‌1‌ ‌‌Implementing‌ ‌‌SwingUtilities‌ ‌‌using‌ ‌an‌ ‌‌Executor‌.‌ ‌.........‌ ‌‌193‌ ‌ ‌9‌.‌2‌ ‌‌Executor‌ ‌‌built‌ ‌atop‌ ‌‌SwingUtilities‌..‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌194‌ ‌ ‌Licensed‌ ‌by‌ ‌ ‌9‌.‌3‌ ‌‌Simple‌ ‌event‌ ‌listener.‌ ‌.‌ ‌.‌ ‌.........................‌ ‌‌194‌ ‌ ‌9‌.‌4‌ ‌‌Binding‌ ‌a‌ ‌long-running‌ ‌task‌ ‌to‌ ‌a‌ ‌visual‌ ‌component.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌196‌ ‌ ‌9‌.‌5‌ ‌‌Long-running‌ ‌task‌ ‌with‌ ‌user‌ ‌feedback.‌ ‌.‌ ‌.‌ ‌.‌ ‌..............‌ ‌‌196‌ ‌ ‌9‌.‌6‌ ‌‌Cancelling‌ ‌a‌ ‌long-running‌ ‌task.‌ ‌.‌ ‌.‌ ‌.‌ ‌..................‌ ‌‌197‌ ‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌9‌.‌7‌ ‌‌Background‌ ‌task‌ ‌class‌ ‌supporting‌ ‌cancellation,‌ ‌completion‌ ‌notifi‌ ‌ ‌cation,‌ ‌and‌ ‌progress‌ ‌notification.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌199‌ ‌ ‌9‌.‌8‌ ‌‌Initiating‌ ‌a‌ ‌long-running,‌ ‌cancellable‌ ‌task‌ ‌with‌ ‌‌BackgroundTask‌.‌ ‌.‌ ‌‌200‌ ‌ ‌10‌.‌1‌ ‌‌Simple‌ ‌lock-ordering‌ ‌deadlock.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌.............‌ ‌‌207‌ ‌ ‌1821604‌ ‌10‌.‌2‌ ‌‌Dynamic‌ ‌lock-ordering‌ ‌deadlock.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌............‌ ‌‌208‌ ‌ ‌10‌.‌3‌ ‌‌Inducing‌ ‌a‌ ‌lock‌ ‌ordering‌ ‌to‌ ‌avoid‌ ‌deadlock.‌ ‌..............‌ ‌‌209‌ ‌ ‌10‌.‌4‌ ‌‌Driver‌ ‌loop‌ ‌that‌ ‌induces‌ ‌deadlock‌ ‌under‌ ‌typical‌ ‌conditions.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌210‌ ‌ ‌10‌.‌5‌ ‌‌Lock-ordering‌ ‌deadlock‌ ‌between‌ ‌cooperating‌ ‌objects.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌212‌ ‌ ‌10‌.‌6‌ ‌‌Using‌ ‌open‌ ‌calls‌ ‌to‌ ‌avoiding‌ ‌deadlock‌ ‌between‌ ‌cooperating‌ ‌objects.‌ ‌‌214‌ ‌ ‌10‌.‌7‌ ‌‌Portion‌ ‌of‌ ‌thread‌ ‌dump‌ ‌after‌ ‌deadlock.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌217‌ ‌ ‌11‌.‌1‌ ‌‌Serialized‌ ‌access‌ ‌to‌ ‌a‌ ‌task‌ ‌queue.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌227‌ ‌ ‌11‌.‌2‌ ‌‌Synchronization‌ ‌that‌ ‌has‌ ‌no‌ ‌effect.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌...........‌ ‌‌230‌ ‌ ‌11‌.‌3‌ ‌‌Candidate‌ ‌for‌ ‌lock‌ ‌elision.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌..................‌ ‌‌231‌ ‌ ‌11‌.‌4‌ ‌‌Holding‌ ‌a‌ ‌lock‌ ‌longer‌ ‌than‌ ‌necessary.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌233‌ ‌ ‌11‌.‌5‌ ‌‌Reducing‌ ‌lock‌ ‌duration.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌234‌ ‌ ‌11‌.‌6‌ ‌‌Candidate‌ ‌for‌ ‌lock‌ ‌splitting.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌236‌ ‌ ‌11‌.‌7‌ ‌‌ServerStatus‌ ‌‌refactored‌ ‌to‌ ‌use‌ ‌split‌ ‌locks.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌236‌ ‌ ‌11‌.‌8‌ ‌‌Hash-based‌ ‌map‌ ‌using‌ ‌lock‌ ‌striping.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌238‌ ‌ ‌12‌.‌1‌ ‌‌Bounded‌ ‌buffer‌ ‌using‌ ‌‌Semaphore‌.....................‌ ‌‌249‌ ‌ ‌12‌.‌2‌ ‌‌Basic‌ ‌unit‌ ‌tests‌ ‌for‌ ‌‌BoundedBuffer‌.‌ ‌...................‌ ‌‌250‌ ‌ ‌12‌.‌3‌ ‌‌Testing‌ ‌blocking‌ ‌and‌ ‌responsiveness‌ ‌to‌ ‌interruption.‌ ‌.‌ ‌.‌ ‌.‌ ‌......‌ ‌‌252‌ ‌ ‌12‌.‌4‌ ‌‌Medium-quality‌ ‌random‌ ‌number‌ ‌generator‌ ‌suitable‌ ‌for‌ ‌testing.‌ ‌.‌ ‌.‌ ‌‌253‌ ‌ ‌12‌.‌5‌ ‌‌Producer-consumer‌ ‌test‌ ‌program‌ ‌for‌ ‌‌BoundedBuffer‌.‌ ‌........‌ ‌‌255‌ ‌ ‌12‌.‌6‌ ‌‌Producer‌ ‌and‌ ‌consumer‌ ‌classes‌ ‌used‌ ‌in‌ ‌‌PutTakeTest‌.‌ ‌........‌ ‌‌256‌ ‌ ‌12‌.‌7‌ ‌‌Testing‌ ‌for‌ ‌resource‌ ‌leaks.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌258‌ ‌ ‌12‌.‌8‌ ‌‌Thread‌ ‌factory‌ ‌for‌ ‌testing‌ ‌‌ThreadPoolExecutor‌.‌ ‌...........‌ ‌‌258‌ ‌ ‌12‌.‌9‌ ‌‌Test‌ ‌method‌ ‌to‌ ‌verify‌ ‌thread‌ ‌pool‌ ‌expansion.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌259‌ ‌ ‌12‌.‌10‌ ‌‌Using‌ ‌‌Thread.yield‌ ‌‌to‌ ‌generate‌ ‌more‌ ‌interleavings.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌260‌ ‌ ‌12‌.‌11‌ ‌‌Barrier-based‌ ‌timer.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌261‌ ‌ ‌12‌.‌12‌ ‌‌Testing‌ ‌with‌ ‌a‌ ‌barrier-based‌ ‌timer.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌262‌ ‌ ‌12‌.‌13‌ ‌‌Driver‌ ‌program‌ ‌for‌ ‌‌TimedPutTakeTest‌.‌ ‌................‌ ‌‌262‌ ‌ ‌13‌.‌1‌ ‌‌Lock‌ ‌‌interface.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌277‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌ ‌xvi‌ ‌‌Listings‌ ‌ ‌13‌.‌2‌ ‌‌Guarding‌ ‌object‌ ‌state‌ ‌using‌ ‌‌ReentrantLock‌...............‌ ‌‌278‌ ‌ ‌13‌.‌3‌ ‌‌Avoiding‌ ‌lock-ordering‌ ‌deadlock‌ ‌using‌ ‌‌tryLock‌............‌ ‌‌280‌ ‌ ‌13‌.‌4‌ ‌‌Locking‌ ‌with‌ ‌a‌ ‌time‌ ‌budget.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌281‌ ‌ ‌13‌.‌5‌ ‌‌Interruptible‌ ‌lock‌ ‌acquisition.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌..................‌ ‌‌281‌ ‌ ‌13‌.‌6‌ ‌‌ReadWriteLock‌ ‌‌interface.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌286‌ ‌ ‌13‌.‌7‌ ‌‌Wrapping‌ ‌a‌ ‌‌Map‌ ‌‌with‌ ‌a‌ ‌read-write‌ ‌lock.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌288‌ ‌ ‌14‌.‌1‌ ‌‌Structure‌ ‌of‌ ‌blocking‌ ‌state-dependent‌ ‌actions.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌292‌ ‌ ‌14‌.‌2‌ ‌‌Base‌ ‌class‌ ‌for‌ ‌bounded‌ ‌buffer‌ ‌implementations.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌293‌ ‌ ‌14‌.‌3‌ ‌‌Bounded‌ ‌buffer‌ ‌that‌ ‌balks‌ ‌when‌ ‌preconditions‌ ‌are‌ ‌not‌ ‌met.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌294‌ ‌ ‌14‌.‌4‌ ‌‌Client‌ ‌logic‌ ‌for‌ ‌calling‌ ‌‌GrumpyBoundedBuffer‌..‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌294‌ ‌ ‌14‌.‌5‌ ‌‌Bounded‌ ‌buffer‌ ‌using‌ ‌crude‌ ‌blocking.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌296‌ ‌ ‌14‌.‌6‌ ‌‌Bounded‌ ‌buffer‌ ‌using‌ ‌condition‌ ‌queues.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌298‌ ‌ ‌14‌.‌7‌ ‌‌Canonical‌ ‌form‌ ‌for‌ ‌state-dependent‌ ‌methods.‌ ‌.‌ ‌.‌ ‌.‌ ‌..........‌ ‌‌301‌ ‌ ‌14‌.‌8‌ ‌‌Using‌ ‌conditional‌ ‌notification‌ ‌in‌ ‌‌BoundedBuffer.put‌.‌ ‌........‌ ‌‌304‌ ‌ ‌14‌.‌9‌ ‌‌Recloseable‌ ‌gate‌ ‌using‌ ‌‌wait‌ ‌‌and‌ ‌‌notifyAll‌.....‌ ‌....‌ ‌....‌ ‌..‌ ‌‌305‌ ‌ ‌14‌.‌10‌ ‌‌Condition‌ ‌‌interface.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌307‌ ‌ ‌14‌.‌11‌ ‌‌Bounded‌ ‌buffer‌ ‌using‌ ‌explicit‌ ‌condition‌ ‌variables.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌309‌ ‌ ‌14‌.‌12‌ ‌‌Counting‌ ‌semaphore‌ ‌implemented‌ ‌using‌ ‌‌Lock‌.............‌ ‌‌310‌ ‌ ‌14‌.‌13‌ ‌‌Canonical‌ ‌forms‌ ‌for‌ ‌acquisition‌ ‌and‌ ‌release‌ ‌in‌ ‌AQS.‌ ‌.‌ ‌.‌ ‌.‌ ‌......‌ ‌‌312‌ ‌ ‌14‌.‌14‌ ‌‌Binary‌ ‌latch‌ ‌using‌ ‌‌AbstractQueuedSynchronizer‌.‌ ‌..........‌ ‌‌313‌ ‌ ‌14‌.‌15‌ ‌‌tryAcquire‌ ‌‌implementation‌ ‌from‌ ‌nonfair‌ ‌‌ReentrantLock‌.‌ ‌.....‌ ‌‌315‌ ‌ ‌14‌.‌16‌ ‌‌tryAcquireShared‌ ‌‌and‌ ‌‌tryReleaseShared‌ ‌‌from‌ ‌‌Semaphore‌.‌ ‌....‌ ‌‌316‌ ‌ ‌15‌.‌1‌ ‌‌Simulated‌ ‌CAS‌ ‌operation.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌322‌ ‌ ‌15‌.‌2‌ ‌‌Nonblocking‌ ‌counter‌ ‌using‌ ‌CAS.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌323‌ ‌ ‌15‌.‌3‌ ‌‌Preserving‌ ‌multivariable‌ ‌invariants‌ ‌using‌ ‌CAS.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌326‌ ‌ ‌15‌.‌4‌ ‌‌Random‌ ‌number‌ ‌generator‌ ‌using‌ ‌‌ReentrantLock‌.‌ ‌..........‌ ‌‌327‌ ‌ ‌15‌.‌5‌ ‌‌Random‌ ‌number‌ ‌generator‌ ‌using‌ ‌‌AtomicInteger‌.‌ ‌..........‌ ‌‌327‌ ‌ ‌15‌.‌6‌ ‌‌Nonblocking‌ ‌stack‌ ‌using‌ ‌Treiber’s‌ ‌algorithm‌ ‌(Treiber,‌ ‌‌1986‌).‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌331‌ ‌ ‌15‌.‌7‌ ‌‌Insertion‌ ‌in‌ ‌the‌ ‌Michael-Scott‌ ‌nonblocking‌ ‌queue‌ ‌algorithm‌ ‌ ‌(Michael‌ ‌and‌ ‌Scott,‌ ‌‌1996‌).‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌334‌ ‌ ‌15‌.‌8‌ ‌‌Using‌ ‌atomic‌ ‌field‌ ‌updaters‌ ‌in‌ ‌‌ConcurrentLinkedQueue‌.‌ ‌......‌ ‌‌335‌ ‌ ‌16‌.‌1‌ ‌‌Insufficiently‌ ‌synchronized‌ ‌program‌ ‌that‌ ‌can‌ ‌have‌ ‌surprising‌ ‌re‌ ‌ ‌sults.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌.............................‌ ‌‌340‌ ‌ ‌16‌.‌2‌ ‌‌Inner‌ ‌class‌ ‌of‌ ‌‌FutureTask‌ ‌‌illustrating‌ ‌synchronization‌ ‌piggybacking.‌343‌ ‌ ‌16‌.‌3‌ ‌‌Unsafe‌ ‌lazy‌ ‌initialization.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌.................‌ ‌‌345‌ ‌ ‌16‌.‌4‌ ‌‌Thread-safe‌ ‌lazy‌ ‌initialization.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌347‌ ‌ ‌16‌.‌5‌ ‌‌Eager‌ ‌initialization.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌347‌ ‌ ‌16‌.‌6‌ ‌‌Lazy‌ ‌initialization‌ ‌holder‌ ‌class‌ ‌idiom.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌348‌ ‌ ‌16‌.‌7‌ ‌‌Double-checked-locking‌ ‌antipattern.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌‌..........‌ ‌‌349‌ ‌ ‌16‌.‌8‌ ‌‌Initialization‌ ‌safety‌ ‌for‌ ‌immutable‌ ‌objects.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌.‌ ‌‌350‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌Preface‌ ‌ ‌At‌ ‌this‌ ‌writing,‌ ‌multicore‌ ‌processors‌ ‌are‌ ‌just‌ ‌now‌ ‌becoming‌ ‌inexpensive‌ ‌enough‌ ‌ ‌for‌ ‌midrange‌ ‌desktop‌ ‌systems.‌ ‌Not‌ ‌coincidentally,‌ ‌many‌ ‌development‌ ‌teams‌ ‌are‌ ‌ ‌noticing‌ ‌more‌ ‌and‌ ‌more‌ ‌threading-related‌ ‌bug‌ ‌reports‌ ‌in‌ ‌their‌ ‌projects.‌ ‌In‌ ‌a‌ ‌recent‌ ‌ ‌post‌ ‌on‌ ‌the‌ ‌NetBeans‌ ‌developer‌ ‌site,‌ ‌one‌ ‌of‌ ‌the‌ ‌core‌ ‌maintainers‌ ‌observed‌ ‌that‌ ‌ ‌a‌ ‌single‌ ‌class‌ ‌had‌ ‌been‌ ‌patched‌ ‌over‌ ‌‌14‌ ‌‌times‌ ‌to‌ ‌fix‌ ‌threading-related‌ ‌problems.‌ ‌ ‌Dion‌ ‌Almaer,‌ ‌former‌ ‌editor‌ ‌of‌ ‌TheServerSide,‌ ‌recently‌ ‌blogged‌ ‌(after‌ ‌a‌ ‌painful‌ ‌ ‌debugging‌ ‌session‌ ‌that‌ ‌ultimately‌ ‌revealed‌ ‌a‌ ‌threading‌ ‌bug)‌ ‌that‌ ‌most‌ ‌Java‌ ‌pro‌ ‌ ‌grams‌ ‌are‌ ‌so‌ ‌rife‌ ‌with‌ ‌concurrency‌ ‌bugs‌ ‌that‌ ‌they‌ ‌work‌ ‌only‌ ‌“by‌ ‌accident”.‌ ‌ ‌Indeed,‌ ‌developing,‌ ‌testing‌ ‌and‌ ‌debugging‌ ‌multithreaded‌ ‌programs‌ ‌can‌ ‌be‌ ‌ ‌extremely‌ ‌difficult‌ ‌because‌ ‌concurrency‌ ‌bugs‌ ‌do‌ ‌not‌ ‌manifest‌ ‌themselves‌ ‌pre‌ ‌ ‌dictably.‌ ‌And‌ ‌when‌ ‌they‌ ‌do‌ ‌surface,‌ ‌it‌ ‌is‌ ‌often‌ ‌at‌ ‌the‌ ‌worst‌ ‌possible‌ ‌time—in‌ ‌ ‌production,‌ ‌under‌ ‌heavy‌ ‌load.‌ ‌ ‌One‌ ‌of‌ ‌the‌ ‌challenges‌ ‌of‌ ‌developing‌ ‌concurrent‌ ‌programs‌ ‌in‌ ‌Java‌ ‌is‌ ‌the‌ ‌mis‌ ‌ ‌match‌ ‌between‌ ‌the‌ ‌concurrency‌ ‌features‌ ‌offered‌ ‌by‌ ‌the‌ ‌platform‌ ‌and‌ ‌how‌ ‌de‌ ‌ ‌velopers‌ ‌need‌ ‌to‌ ‌think‌ ‌about‌ ‌concurrency‌ ‌in‌ ‌their‌ ‌programs.‌ ‌The‌ ‌language‌ ‌pro‌ ‌ ‌vides‌ ‌low-level‌ ‌‌mechanisms‌ ‌‌such‌ ‌as‌ ‌synchronization‌ ‌and‌ ‌condition‌ ‌waits,‌ ‌but‌ ‌these‌ ‌ ‌mechanisms‌ ‌must‌ ‌be‌ ‌used‌ ‌consistently‌ ‌to‌ ‌implement‌ ‌application-level‌ ‌protocols‌ ‌ ‌or‌ ‌‌policies‌.‌ ‌Without‌ ‌such‌ ‌policies,‌ ‌it‌ ‌is‌ ‌all‌ ‌too‌ ‌easy‌ ‌to‌ ‌create‌ ‌programs‌ ‌that‌ ‌com‌ ‌ ‌pile‌ ‌and‌ ‌appear‌ ‌to‌ ‌work‌ ‌but‌ ‌are‌ ‌nevertheless‌ ‌broken.‌ ‌Many‌ ‌otherwise‌ ‌excellent‌ ‌ ‌books‌ ‌on‌ ‌concurrency‌ ‌fall‌ ‌short‌ ‌of‌ ‌their‌ ‌goal‌ ‌by‌ ‌focusing‌ ‌excessively‌ ‌on‌ ‌low-level‌ ‌ ‌mechanisms‌ ‌and‌ ‌APIs‌ ‌rather‌ ‌than‌ ‌design-level‌ ‌policies‌ ‌and‌ ‌patterns.‌ ‌ ‌Java‌ ‌‌5‌.‌0‌ ‌‌is‌ ‌a‌ ‌huge‌ ‌step‌ ‌forward‌ ‌for‌ ‌the‌ ‌development‌ ‌of‌ ‌concurrent‌ ‌applica‌ ‌ ‌tions‌ ‌in‌ ‌Java,‌ ‌providing‌ ‌new‌ ‌higher-level‌ ‌components‌ ‌and‌ ‌additional‌ ‌low-level‌ ‌ ‌mechanisms‌ ‌that‌ ‌make‌ ‌it‌ ‌easier‌ ‌for‌ ‌novices‌ ‌and‌ ‌experts‌ ‌alike‌ ‌to‌ ‌build‌ ‌concurrent‌ ‌ ‌applications.‌ ‌The‌ ‌authors‌ ‌are‌ ‌the‌ ‌primary‌ ‌members‌ ‌of‌ ‌the‌ ‌JCP‌ ‌Expert‌ ‌Group‌ ‌ ‌that‌ ‌created‌ ‌these‌ ‌facilities;‌ ‌in‌ ‌addition‌ ‌to‌ ‌describing‌ ‌their‌ ‌behavior‌ ‌and‌ ‌features,‌ ‌ ‌we‌ ‌present‌ ‌the‌ ‌underlying‌ ‌design‌ ‌patterns‌ ‌and‌ ‌anticipated‌ ‌usage‌ ‌scenarios‌ ‌that‌ ‌ ‌motivated‌ ‌their‌ ‌inclusion‌ ‌in‌ ‌the‌ ‌platform‌ ‌libraries.‌ ‌ ‌Our‌ ‌goal‌ ‌is‌ ‌to‌ ‌give‌ ‌readers‌ ‌a‌ ‌set‌ ‌of‌ ‌design‌ ‌rules‌ ‌and‌ ‌mental‌ ‌models‌ ‌that‌ ‌make‌ ‌ ‌it‌ ‌easier—and‌ ‌more‌ ‌fun—to‌ ‌build‌ ‌correct,‌ ‌performant‌ ‌concurrent‌ ‌classes‌ ‌and‌ ‌ap‌ ‌ ‌plications‌ ‌in‌ ‌Java.‌ ‌ ‌We‌ ‌hope‌ ‌you‌ ‌enjoy‌ ‌‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice‌.‌ ‌ ‌Brian‌ ‌Goetz‌ ‌ ‌Williston,‌ ‌VT‌ ‌ ‌March‌ ‌‌2006‌ ‌ ‌xvii‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌xviii‌ ‌‌Preface‌ ‌ ‌How‌ ‌to‌ ‌use‌ ‌this‌ ‌book‌ ‌ ‌To‌ ‌address‌ ‌the‌ ‌abstraction‌ ‌mismatch‌ ‌between‌ ‌Java’s‌ ‌low-level‌ ‌mechanisms‌ ‌and‌ ‌ ‌the‌ ‌necessary‌ ‌design-level‌ ‌policies,‌ ‌we‌ ‌present‌ ‌a‌ ‌‌simplified‌ ‌‌set‌ ‌of‌ ‌rules‌ ‌for‌ ‌writing‌ ‌ ‌concurrent‌ ‌programs.‌ ‌Experts‌ ‌may‌ ‌look‌ ‌at‌ ‌these‌ ‌rules‌ ‌and‌ ‌say‌ ‌“Hmm,‌ ‌that’s‌ ‌ ‌not‌ ‌entirely‌ ‌true:‌ ‌class‌ ‌‌C‌ ‌‌is‌ ‌thread-safe‌ ‌even‌ ‌though‌ ‌it‌ ‌violates‌ ‌rule‌ ‌‌R‌.”‌ ‌While‌ ‌ ‌it‌ ‌is‌ ‌possible‌ ‌to‌ ‌write‌ ‌correct‌ ‌programs‌ ‌that‌ ‌break‌ ‌our‌ ‌rules,‌ ‌doing‌ ‌so‌ ‌requires‌ ‌a‌ ‌ ‌deep‌ ‌understanding‌ ‌of‌ ‌the‌ ‌low-level‌ ‌details‌ ‌of‌ ‌the‌ ‌Java‌ ‌Memory‌ ‌Model,‌ ‌and‌ ‌we‌ ‌ ‌want‌ ‌developers‌ ‌to‌ ‌be‌ ‌able‌ ‌to‌ ‌write‌ ‌correct‌ ‌concurrent‌ ‌programs‌ ‌‌without‌ ‌‌having‌ ‌ ‌to‌ ‌master‌ ‌these‌ ‌details.‌ ‌Consistently‌ ‌following‌ ‌our‌ ‌simplified‌ ‌rules‌ ‌will‌ ‌produce‌ ‌ ‌correct‌ ‌and‌ ‌maintainable‌ ‌concurrent‌ ‌programs.‌ ‌ ‌We‌ ‌assume‌ ‌the‌ ‌reader‌ ‌already‌ ‌has‌ ‌some‌ ‌familiarity‌ ‌with‌ ‌the‌ ‌basic‌ ‌mecha‌ ‌ ‌nisms‌ ‌for‌ ‌concurrency‌ ‌in‌ ‌Java.‌ ‌‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice‌ ‌‌is‌ ‌not‌ ‌an‌ ‌introduction‌ ‌ ‌to‌ ‌concurrency—for‌ ‌that,‌ ‌see‌ ‌the‌ ‌threading‌ ‌chapter‌ ‌of‌ ‌any‌ ‌decent‌ ‌introductory‌ ‌ ‌volume,‌ ‌such‌ ‌as‌ ‌‌The‌ ‌Java‌ ‌Programming‌ ‌Language‌ ‌‌(Arnold‌ ‌et‌ ‌al.,‌ ‌‌2005‌).‌ ‌Nor‌ ‌is‌ ‌it‌ ‌ ‌an‌ ‌encyclopedic‌ ‌reference‌ ‌for‌ ‌All‌ ‌Things‌ ‌Concurrency—for‌ ‌that,‌ ‌see‌ ‌‌Concurrent‌ ‌ ‌Programming‌ ‌in‌ ‌Java‌ ‌‌(Lea,‌ ‌‌2000‌).‌ ‌Rather,‌ ‌it‌ ‌offers‌ ‌practical‌ ‌design‌ ‌rules‌ ‌to‌ ‌assist‌ ‌ ‌developers‌ ‌in‌ ‌the‌ ‌difficult‌ ‌process‌ ‌of‌ ‌creating‌ ‌safe‌ ‌and‌ ‌performant‌ ‌concurrent‌ ‌ ‌classes.‌ ‌Where‌ ‌appropriate,‌ ‌we‌ ‌cross-reference‌ ‌relevant‌ ‌sections‌ ‌of‌ ‌‌The‌ ‌Java‌ ‌Pro‌ ‌ ‌gramming‌ ‌Language‌,‌ ‌‌Concurrent‌ ‌Programming‌ ‌in‌ ‌Java‌,‌ ‌‌The‌ ‌Java‌ ‌Language‌ ‌Specification‌ ‌ ‌(Gosling‌ ‌et‌ ‌al.,‌ ‌‌2005‌),‌ ‌and‌ ‌‌Effective‌ ‌Java‌ ‌‌(Bloch,‌ ‌‌2001‌)‌ ‌using‌ ‌the‌ ‌conventions‌ ‌[JPL‌ ‌ ‌n.m],‌ ‌[CPJ‌ ‌n.m],‌ ‌[JLS‌ ‌n.m],‌ ‌and‌ ‌[EJ‌ ‌Item‌ ‌n].‌ ‌ ‌After‌ ‌the‌ ‌introduction‌ ‌(Chapter‌ ‌‌1‌),‌ ‌the‌ ‌book‌ ‌is‌ ‌divided‌ ‌into‌ ‌four‌ ‌parts:‌ ‌ ‌Fundamentals.‌ ‌‌Part‌ ‌I‌ ‌(Chapters‌ ‌‌2‌-‌5‌)‌ ‌focuses‌ ‌on‌ ‌the‌ ‌basic‌ ‌concepts‌ ‌of‌ ‌con‌ ‌ ‌currency‌ ‌and‌ ‌thread‌ ‌safety,‌ ‌and‌ ‌how‌ ‌to‌ ‌compose‌ ‌thread-safe‌ ‌classes‌ ‌out‌ ‌of‌ ‌the‌ ‌ ‌concurrent‌ ‌building‌ ‌blocks‌ ‌provided‌ ‌by‌ ‌the‌ ‌class‌ ‌library.‌ ‌A‌ ‌“cheat‌ ‌sheet”‌ ‌summa‌ ‌ ‌rizing‌ ‌the‌ ‌most‌ ‌important‌ ‌of‌ ‌the‌ ‌rules‌ ‌presented‌ ‌in‌ ‌Part‌ ‌I‌ ‌appears‌ ‌on‌ ‌page‌ ‌‌110‌.‌ ‌ ‌Chapters‌ ‌‌2‌ ‌‌(Thread‌ ‌Safety)‌ ‌and‌ ‌‌3‌ ‌‌(Sharing‌ ‌Objects)‌ ‌form‌ ‌the‌ ‌foundation‌ ‌for‌ ‌ ‌the‌ ‌book.‌ ‌Nearly‌ ‌all‌ ‌of‌ ‌the‌ ‌rules‌ ‌on‌ ‌avoiding‌ ‌concurrency‌ ‌hazards,‌ ‌constructing‌ ‌ ‌thread-safe‌ ‌classes,‌ ‌and‌ ‌verifying‌ ‌thread‌ ‌safety‌ ‌are‌ ‌here.‌ ‌Readers‌ ‌who‌ ‌prefer‌ ‌ ‌“practice”‌ ‌to‌ ‌“theory”‌ ‌may‌ ‌be‌ ‌tempted‌ ‌to‌ ‌skip‌ ‌ahead‌ ‌to‌ ‌Part‌ ‌II,‌ ‌but‌ ‌make‌ ‌sure‌ ‌to‌ ‌ ‌come‌ ‌back‌ ‌and‌ ‌read‌ ‌Chapters‌ ‌‌2‌ ‌‌and‌ ‌‌3‌ ‌‌before‌ ‌writing‌ ‌any‌ ‌concurrent‌ ‌code!‌ ‌ ‌Chapter‌ ‌‌4‌ ‌‌(Composing‌ ‌Objects)‌ ‌covers‌ ‌techniques‌ ‌for‌ ‌composing‌ ‌thread-safe‌ ‌ ‌classes‌ ‌into‌ ‌larger‌ ‌thread-safe‌ ‌classes.‌ ‌Chapter‌ ‌‌5‌ ‌‌(Building‌ ‌Blocks)‌ ‌covers‌ ‌the‌ ‌ ‌concurrent‌ ‌building‌ ‌blocks—thread-safe‌ ‌collections‌ ‌and‌ ‌synchronizers—provided‌ ‌ ‌by‌ ‌the‌ ‌platform‌ ‌libraries.‌ ‌ ‌Structuring‌ ‌Concurrent‌ ‌Applications.‌ ‌‌Part‌ ‌II‌ ‌(Chapters‌ ‌‌6‌-‌9‌)‌ ‌describes‌ ‌how‌ ‌ ‌to‌ ‌exploit‌ ‌threads‌ ‌to‌ ‌improve‌ ‌the‌ ‌throughput‌ ‌or‌ ‌responsiveness‌ ‌of‌ ‌concurrent‌ ‌ap‌ ‌ ‌plications.‌ ‌Chapter‌ ‌‌6‌ ‌‌(Task‌ ‌Execution)‌ ‌covers‌ ‌identifying‌ ‌parallelizable‌ ‌tasks‌ ‌and‌ ‌ ‌executing‌ ‌them‌ ‌within‌ ‌the‌ ‌task-execution‌ ‌framework.‌ ‌Chapter‌ ‌‌7‌ ‌‌(Cancellation‌ ‌ ‌and‌ ‌Shutdown)‌ ‌deals‌ ‌with‌ ‌techniques‌ ‌for‌ ‌convincing‌ ‌tasks‌ ‌and‌ ‌threads‌ ‌to‌ ‌ter‌ ‌ ‌minate‌ ‌before‌ ‌they‌ ‌would‌ ‌normally‌ ‌do‌ ‌so;‌ ‌how‌ ‌programs‌ ‌deal‌ ‌with‌ ‌cancellation‌ ‌ ‌and‌ ‌shutdown‌ ‌is‌ ‌often‌ ‌one‌ ‌of‌ ‌the‌ ‌factors‌ ‌that‌ ‌separates‌ ‌truly‌ ‌robust‌ ‌concurrent‌ ‌ ‌applications‌ ‌from‌ ‌those‌ ‌that‌ ‌merely‌ ‌work.‌ ‌Chapter‌ ‌‌8‌ ‌‌(Applying‌ ‌Thread‌ ‌Pools)‌ ‌ ‌addresses‌ ‌some‌ ‌of‌ ‌the‌ ‌more‌ ‌advanced‌ ‌features‌ ‌of‌ ‌the‌ ‌task-execution‌ ‌framework.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌Preface‌ ‌‌xix‌ ‌ ‌Chapter‌ ‌‌9‌ ‌‌(GUI‌ ‌Applications)‌ ‌focuses‌ ‌on‌ ‌techniques‌ ‌for‌ ‌improving‌ ‌responsiveness‌ ‌ ‌in‌ ‌single-threaded‌ ‌subsystems.‌ ‌ ‌Liveness,‌ ‌Performance,‌ ‌and‌ ‌Testing.‌ ‌‌Part‌ ‌III‌ ‌(Chapters‌ ‌‌10‌-‌12‌)‌ ‌concerns‌ ‌itself‌ ‌ ‌with‌ ‌ensuring‌ ‌that‌ ‌concurrent‌ ‌programs‌ ‌actually‌ ‌do‌ ‌what‌ ‌you‌ ‌want‌ ‌them‌ ‌to‌ ‌do‌ ‌ ‌and‌ ‌do‌ ‌so‌ ‌with‌ ‌acceptable‌ ‌performance.‌ ‌Chapter‌ ‌‌10‌ ‌‌(Avoiding‌ ‌Liveness‌ ‌Hazards)‌ ‌ ‌describes‌ ‌how‌ ‌to‌ ‌avoid‌ ‌liveness‌ ‌failures‌ ‌that‌ ‌can‌ ‌prevent‌ ‌programs‌ ‌from‌ ‌making‌ ‌ ‌forward‌ ‌progress.‌ ‌Chapter‌ ‌‌11‌ ‌‌(Performance‌ ‌and‌ ‌Scalability)‌ ‌covers‌ ‌techniques‌ ‌ ‌for‌ ‌improving‌ ‌the‌ ‌performance‌ ‌and‌ ‌scalability‌ ‌of‌ ‌concurrent‌ ‌code.‌ ‌Chapter‌ ‌‌12‌ ‌ ‌(Testing‌ ‌Concurrent‌ ‌Programs)‌ ‌covers‌ ‌techniques‌ ‌for‌ ‌testing‌ ‌concurrent‌ ‌code‌ ‌for‌ ‌ ‌both‌ ‌correctness‌ ‌and‌ ‌performance.‌ ‌ ‌Advanced‌ ‌Topics.‌ ‌‌Part‌ ‌IV‌ ‌(Chapters‌ ‌‌13‌-‌16‌)‌ ‌covers‌ ‌topics‌ ‌that‌ ‌are‌ ‌likely‌ ‌to‌ ‌ ‌be‌ ‌of‌ ‌interest‌ ‌only‌ ‌to‌ ‌experienced‌ ‌developers:‌ ‌explicit‌ ‌locks,‌ ‌atomic‌ ‌variables,‌ ‌ ‌nonblocking‌ ‌algorithms,‌ ‌and‌ ‌developing‌ ‌custom‌ ‌synchronizers.‌ ‌ ‌Code‌ ‌examples‌ ‌ ‌While‌ ‌many‌ ‌of‌ ‌the‌ ‌general‌ ‌concepts‌ ‌in‌ ‌this‌ ‌book‌ ‌are‌ ‌applicable‌ ‌to‌ ‌versions‌ ‌of‌ ‌Java‌ ‌ ‌prior‌ ‌to‌ ‌Java‌ ‌‌5‌.‌0‌ ‌‌and‌ ‌even‌ ‌to‌ ‌non-Java‌ ‌environments,‌ ‌most‌ ‌of‌ ‌the‌ ‌code‌ ‌examples‌ ‌ ‌(and‌ ‌all‌ ‌the‌ ‌statements‌ ‌about‌ ‌the‌ ‌Java‌ ‌Memory‌ ‌Model)‌ ‌assume‌ ‌Java‌ ‌‌5‌.‌0‌ ‌‌or‌ ‌later.‌ ‌ ‌Some‌ ‌of‌ ‌the‌ ‌code‌ ‌examples‌ ‌may‌ ‌use‌ ‌library‌ ‌features‌ ‌added‌ ‌in‌ ‌Java‌ ‌‌6‌.‌ ‌ ‌The‌ ‌code‌ ‌examples‌ ‌have‌ ‌been‌ ‌compressed‌ ‌to‌ ‌reduce‌ ‌their‌ ‌size‌ ‌and‌ ‌to‌ ‌high‌ ‌ ‌light‌ ‌the‌ ‌relevant‌ ‌portions.‌ ‌The‌ ‌full‌ ‌versions‌ ‌of‌ ‌the‌ ‌code‌ ‌examples,‌ ‌as‌ ‌well‌ ‌ ‌as‌ ‌supplementary‌ ‌examples‌ ‌and‌ ‌errata,‌ ‌are‌ ‌available‌ ‌from‌ ‌the‌ ‌book’s‌ ‌website,‌ ‌ ‌http://www.javaconcurrencyinpractice.com‌.‌ ‌ ‌The‌ ‌code‌ ‌examples‌ ‌are‌ ‌of‌ ‌three‌ ‌sorts:‌ ‌“good”‌ ‌examples,‌ ‌“not‌ ‌so‌ ‌good”‌ ‌exam‌ ‌ ‌ples,‌ ‌and‌ ‌“bad”‌ ‌examples.‌ ‌Good‌ ‌examples‌ ‌illustrate‌ ‌techniques‌ ‌that‌ ‌should‌ ‌be‌ ‌ ‌emulated.‌ ‌Bad‌ ‌examples‌ ‌illustrate‌ ‌techniques‌ ‌that‌ ‌should‌ ‌definitely‌ ‌‌not‌ ‌‌be‌ ‌em‌ ‌ ‌ulated,‌ ‌and‌ ‌are‌ ‌identified‌ ‌with‌ ‌a‌ ‌“Mr.‌ ‌Yuk”‌ ‌icon‌1‌ ‌‌to‌ ‌make‌ ‌it‌ ‌clear‌ ‌that‌ ‌this‌ ‌is‌ ‌ ‌“toxic”‌ ‌code‌ ‌(see‌ ‌Listing‌ ‌‌1‌).‌ ‌Not-so-good‌ ‌examples‌ ‌illustrate‌ ‌techniques‌ ‌that‌ ‌are‌ ‌ ‌not‌ ‌‌necessarily‌ ‌‌wrong‌ ‌but‌ ‌are‌ ‌fragile,‌ ‌risky,‌ ‌or‌ ‌perform‌ ‌poorly,‌ ‌and‌ ‌are‌ ‌decorated‌ ‌ ‌with‌ ‌a‌ ‌“Mr.‌ ‌Could‌ ‌Be‌ ‌Happier”‌ ‌icon‌ ‌as‌ ‌in‌ ‌Listing‌ ‌‌2‌.‌ ‌ ‌public‌ ‌<T‌ ‌extends‌ ‌Comparable<?‌ ‌super‌ ‌T>>‌ ‌void‌ ‌sort(List<T>‌ ‌list)‌ ‌{‌ ‌ ‌//‌ ‌Never‌ ‌returns‌ ‌the‌ ‌wrong‌ ‌answer!‌ ‌ ‌System.exit(0);‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌1‌.‌ ‌Bad‌ ‌way‌ ‌to‌ ‌sort‌ ‌a‌ ‌list.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌ ‌Some‌ ‌readers‌ ‌may‌ ‌question‌ ‌the‌ ‌role‌ ‌of‌ ‌the‌ ‌“bad”‌ ‌examples‌ ‌in‌ ‌this‌ ‌book;‌ ‌after‌ ‌ ‌all,‌ ‌a‌ ‌book‌ ‌should‌ ‌show‌ ‌how‌ ‌to‌ ‌do‌ ‌things‌ ‌right,‌ ‌not‌ ‌wrong.‌ ‌The‌ ‌bad‌ ‌examples‌ ‌ ‌have‌ ‌two‌ ‌purposes.‌ ‌They‌ ‌illustrate‌ ‌common‌ ‌pitfalls,‌ ‌but‌ ‌more‌ ‌importantly‌ ‌they‌ ‌ ‌demonstrate‌ ‌how‌ ‌to‌ ‌analyze‌ ‌a‌ ‌program‌ ‌for‌ ‌thread‌ ‌safety—and‌ ‌the‌ ‌best‌ ‌way‌ ‌to‌ ‌do‌ ‌ ‌that‌ ‌is‌ ‌to‌ ‌see‌ ‌the‌ ‌ways‌ ‌in‌ ‌which‌ ‌thread‌ ‌safety‌ ‌is‌ ‌compromised.‌ ‌ ‌1‌.‌ ‌Mr.‌ ‌Yuk‌ ‌is‌ ‌a‌ ‌registered‌ ‌trademark‌ ‌of‌ ‌the‌ ‌Children’s‌ ‌Hospital‌ ‌of‌ ‌Pittsburgh‌ ‌and‌ ‌appears‌ ‌by‌ ‌permis‌ ‌ ‌sion.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌xx‌ ‌‌Preface‌ ‌ ‌public‌ ‌<T‌ ‌extends‌ ‌Comparable<?‌ ‌super‌ ‌T>>‌ ‌void‌ ‌sort(List<T>‌ ‌list)‌ ‌{‌ ‌ ‌for‌ ‌(int‌ ‌i=0;‌ ‌i<1000000;‌ ‌i++)‌ ‌ ‌doNothing();‌ ‌ ‌Collections.sort(list);‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌2‌.‌ ‌Less‌ ‌than‌ ‌optimal‌ ‌way‌ ‌to‌ ‌sort‌ ‌a‌ ‌list.‌ ‌ ‌Acknowledgments‌ ‌ ‌This‌ ‌book‌ ‌grew‌ ‌out‌ ‌of‌ ‌the‌ ‌development‌ ‌process‌ ‌for‌ ‌the‌ ‌‌java.util.concurrent‌ ‌ ‌package‌ ‌that‌ ‌was‌ ‌created‌ ‌by‌ ‌the‌ ‌Java‌ ‌Community‌ ‌Process‌ ‌JSR‌ ‌‌166‌ ‌‌for‌ ‌inclusion‌ ‌in‌ ‌ ‌Java‌ ‌‌5‌.‌0‌.‌ ‌Many‌ ‌others‌ ‌contributed‌ ‌to‌ ‌JSR‌ ‌‌166‌;‌ ‌in‌ ‌particular‌ ‌we‌ ‌thank‌ ‌Martin‌ ‌Buch‌ ‌ ‌holz‌ ‌for‌ ‌doing‌ ‌all‌ ‌the‌ ‌work‌ ‌related‌ ‌to‌ ‌getting‌ ‌the‌ ‌code‌ ‌into‌ ‌the‌ ‌JDK,‌ ‌and‌ ‌all‌ ‌the‌ ‌ ‌readers‌ ‌of‌ ‌the‌ ‌‌concurrency-interest‌ ‌‌mailing‌ ‌list‌ ‌who‌ ‌offered‌ ‌their‌ ‌suggestions‌ ‌ ‌and‌ ‌feedback‌ ‌on‌ ‌the‌ ‌draft‌ ‌APIs.‌ ‌ ‌This‌ ‌book‌ ‌has‌ ‌been‌ ‌tremendously‌ ‌improved‌ ‌by‌ ‌the‌ ‌suggestions‌ ‌and‌ ‌assistance‌ ‌ ‌of‌ ‌a‌ ‌small‌ ‌army‌ ‌of‌ ‌reviewers,‌ ‌advisors,‌ ‌cheerleaders,‌ ‌and‌ ‌armchair‌ ‌critics.‌ ‌We‌ ‌ ‌would‌ ‌like‌ ‌to‌ ‌thank‌ ‌Dion‌ ‌Almaer,‌ ‌Tracy‌ ‌Bialik,‌ ‌Cindy‌ ‌Bloch,‌ ‌Martin‌ ‌Buchholz,‌ ‌ ‌Paul‌ ‌Christmann,‌ ‌Cliff‌ ‌Click,‌ ‌Stuart‌ ‌Halloway,‌ ‌David‌ ‌Hovemeyer,‌ ‌Jason‌ ‌Hunter,‌ ‌ ‌Michael‌ ‌Hunter,‌ ‌Jeremy‌ ‌Hylton,‌ ‌Heinz‌ ‌Kabutz,‌ ‌Robert‌ ‌Kuhar,‌ ‌Ramnivas‌ ‌Lad‌ ‌ ‌dad,‌ ‌Jared‌ ‌Levy,‌ ‌Nicole‌ ‌Lewis,‌ ‌Victor‌ ‌Luchangco,‌ ‌Jeremy‌ ‌Manson,‌ ‌Paul‌ ‌Martin,‌ ‌ ‌Berna‌ ‌Massingill,‌ ‌Michael‌ ‌Maurer,‌ ‌Ted‌ ‌Neward,‌ ‌Kirk‌ ‌Pepperdine,‌ ‌Bill‌ ‌Pugh,‌ ‌Sam‌ ‌ ‌Pullara,‌ ‌Russ‌ ‌Rufer,‌ ‌Bill‌ ‌Scherer,‌ ‌Jeffrey‌ ‌Siegal,‌ ‌Bruce‌ ‌Tate,‌ ‌Gil‌ ‌Tene,‌ ‌Paul‌ ‌Tyma,‌ ‌ ‌and‌ ‌members‌ ‌of‌ ‌the‌ ‌Silicon‌ ‌Valley‌ ‌Patterns‌ ‌Group‌ ‌who,‌ ‌through‌ ‌many‌ ‌interest‌ ‌ ‌ing‌ ‌technical‌ ‌conversations,‌ ‌offered‌ ‌guidance‌ ‌and‌ ‌made‌ ‌suggestions‌ ‌that‌ ‌helped‌ ‌ ‌make‌ ‌this‌ ‌book‌ ‌better.‌ ‌ ‌We‌ ‌are‌ ‌especially‌ ‌grateful‌ ‌to‌ ‌Cliff‌ ‌Biffle,‌ ‌Barry‌ ‌Hayes,‌ ‌Dawid‌ ‌Kurzyniec,‌ ‌Ange‌ ‌ ‌lika‌ ‌Langer,‌ ‌Doron‌ ‌Rajwan,‌ ‌and‌ ‌Bill‌ ‌Venners,‌ ‌who‌ ‌reviewed‌ ‌the‌ ‌entire‌ ‌manuscript‌ ‌ ‌in‌ ‌excruciating‌ ‌detail,‌ ‌found‌ ‌bugs‌ ‌in‌ ‌the‌ ‌code‌ ‌examples,‌ ‌and‌ ‌suggested‌ ‌numerous‌ ‌ ‌improvements.‌ ‌ ‌We‌ ‌thank‌ ‌Katrina‌ ‌Avery‌ ‌for‌ ‌a‌ ‌great‌ ‌copy-editing‌ ‌job‌ ‌and‌ ‌Rosemary‌ ‌Simpson‌ ‌ ‌for‌ ‌producing‌ ‌the‌ ‌index‌ ‌under‌ ‌unreasonable‌ ‌time‌ ‌pressure.‌ ‌We‌ ‌thank‌ ‌Ami‌ ‌Dewar‌ ‌ ‌for‌ ‌doing‌ ‌the‌ ‌illustrations.‌ ‌ ‌Thanks‌ ‌to‌ ‌the‌ ‌whole‌ ‌team‌ ‌at‌ ‌Addison-Wesley‌ ‌who‌ ‌helped‌ ‌make‌ ‌this‌ ‌book‌ ‌a‌ ‌ ‌reality.‌ ‌Ann‌ ‌Sellers‌ ‌got‌ ‌the‌ ‌project‌ ‌launched‌ ‌and‌ ‌Greg‌ ‌Doench‌ ‌shepherded‌ ‌it‌ ‌to‌ ‌a‌ ‌ ‌smooth‌ ‌completion;‌ ‌Elizabeth‌ ‌Ryan‌ ‌guided‌ ‌it‌ ‌through‌ ‌the‌ ‌production‌ ‌process.‌ ‌ ‌We‌ ‌would‌ ‌also‌ ‌like‌ ‌to‌ ‌thank‌ ‌the‌ ‌thousands‌ ‌of‌ ‌software‌ ‌engineers‌ ‌who‌ ‌con‌ ‌ ‌tributed‌ ‌indirectly‌ ‌by‌ ‌creating‌ ‌the‌ ‌software‌ ‌used‌ ‌to‌ ‌create‌ ‌this‌ ‌book,‌ ‌including‌ ‌ ‌T‌E‌X,‌ ‌L‌A‌T‌E‌X,‌ ‌Adobe‌ ‌Acrobat,‌ ‌‌pic‌,‌ ‌‌grap‌,‌ ‌Adobe‌ ‌Illustrator,‌ ‌Perl,‌ ‌Apache‌ ‌Ant,‌ ‌IntelliJ‌ ‌ ‌IDEA,‌ ‌GNU‌ ‌emacs,‌ ‌Subversion,‌ ‌TortoiseSVN,‌ ‌and‌ ‌of‌ ‌course,‌ ‌the‌ ‌Java‌ ‌platform‌ ‌ ‌and‌ ‌class‌ ‌libraries.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌C‌hapter‌ ‌1‌ ‌ ‌Introduction‌ ‌ ‌Writing‌ ‌correct‌ ‌programs‌ ‌is‌ ‌hard;‌ ‌writing‌ ‌correct‌ ‌concurrent‌ ‌programs‌ ‌is‌ ‌harder.‌ ‌ ‌There‌ ‌are‌ ‌simply‌ ‌more‌ ‌things‌ ‌that‌ ‌can‌ ‌go‌ ‌wrong‌ ‌in‌ ‌a‌ ‌concurrent‌ ‌program‌ ‌than‌ ‌ ‌in‌ ‌a‌ ‌sequential‌ ‌one.‌ ‌So,‌ ‌why‌ ‌do‌ ‌we‌ ‌bother‌ ‌with‌ ‌concurrency?‌ ‌Threads‌ ‌are‌ ‌an‌ ‌ ‌inescapable‌ ‌feature‌ ‌of‌ ‌the‌ ‌Java‌ ‌language,‌ ‌and‌ ‌they‌ ‌can‌ ‌simplify‌ ‌the‌ ‌develop‌ ‌ ‌ment‌ ‌of‌ ‌complex‌ ‌systems‌ ‌by‌ ‌turning‌ ‌complicated‌ ‌asynchronous‌ ‌code‌ ‌into‌ ‌simpler‌ ‌ ‌straight-line‌ ‌code.‌ ‌In‌ ‌addition,‌ ‌threads‌ ‌are‌ ‌the‌ ‌easiest‌ ‌way‌ ‌to‌ ‌tap‌ ‌the‌ ‌computing‌ ‌ ‌power‌ ‌of‌ ‌multiprocessor‌ ‌systems.‌ ‌And,‌ ‌as‌ ‌processor‌ ‌counts‌ ‌increase,‌ ‌exploiting‌ ‌ ‌concurrency‌ ‌effectively‌ ‌will‌ ‌only‌ ‌become‌ ‌more‌ ‌important.‌ ‌ ‌1‌.‌1‌ ‌‌A‌ ‌(very)‌ ‌brief‌ ‌history‌ ‌of‌ ‌concurrency‌ ‌ ‌In‌ ‌the‌ ‌ancient‌ ‌past,‌ ‌computers‌ ‌didn’t‌ ‌have‌ ‌operating‌ ‌systems;‌ ‌they‌ ‌executed‌ ‌a‌ ‌ ‌single‌ ‌program‌ ‌from‌ ‌beginning‌ ‌to‌ ‌end,‌ ‌and‌ ‌that‌ ‌program‌ ‌had‌ ‌direct‌ ‌access‌ ‌to‌ ‌all‌ ‌ ‌the‌ ‌resources‌ ‌of‌ ‌the‌ ‌machine.‌ ‌Not‌ ‌only‌ ‌was‌ ‌it‌ ‌difficult‌ ‌to‌ ‌write‌ ‌programs‌ ‌that‌ ‌ran‌ ‌ ‌on‌ ‌the‌ ‌bare‌ ‌metal,‌ ‌but‌ ‌running‌ ‌only‌ ‌a‌ ‌single‌ ‌program‌ ‌at‌ ‌a‌ ‌time‌ ‌was‌ ‌an‌ ‌inefficient‌ ‌ ‌use‌ ‌of‌ ‌expensive‌ ‌and‌ ‌scarce‌ ‌computer‌ ‌resources.‌ ‌ ‌Operating‌ ‌systems‌ ‌evolved‌ ‌to‌ ‌allow‌ ‌more‌ ‌than‌ ‌one‌ ‌program‌ ‌to‌ ‌run‌ ‌at‌ ‌once,‌ ‌ ‌running‌ ‌individual‌ ‌programs‌ ‌in‌ ‌‌processes‌:‌ ‌isolated,‌ ‌independently‌ ‌executing‌ ‌pro‌ ‌ ‌grams‌ ‌to‌ ‌which‌ ‌the‌ ‌operating‌ ‌system‌ ‌allocates‌ ‌resources‌ ‌such‌ ‌as‌ ‌memory,‌ ‌file‌ ‌ ‌handles,‌ ‌and‌ ‌security‌ ‌credentials.‌ ‌If‌ ‌they‌ ‌needed‌ ‌to,‌ ‌processes‌ ‌could‌ ‌communi‌ ‌ ‌cate‌ ‌with‌ ‌one‌ ‌another‌ ‌through‌ ‌a‌ ‌variety‌ ‌of‌ ‌coarse-grained‌ ‌communication‌ ‌mech‌ ‌ ‌anisms:‌ ‌sockets,‌ ‌signal‌ ‌handlers,‌ ‌shared‌ ‌memory,‌ ‌semaphores,‌ ‌and‌ ‌files.‌ ‌ ‌Several‌ ‌motivating‌ ‌factors‌ ‌led‌ ‌to‌ ‌the‌ ‌development‌ ‌of‌ ‌operating‌ ‌systems‌ ‌that‌ ‌ ‌allowed‌ ‌multiple‌ ‌programs‌ ‌to‌ ‌execute‌ ‌simultaneously:‌ ‌ ‌Resource‌ ‌utilization.‌ ‌‌Programs‌ ‌sometimes‌ ‌have‌ ‌to‌ ‌wait‌ ‌for‌ ‌external‌ ‌operations‌ ‌ ‌such‌ ‌as‌ ‌input‌ ‌or‌ ‌output,‌ ‌and‌ ‌while‌ ‌waiting‌ ‌can‌ ‌do‌ ‌no‌ ‌useful‌ ‌work.‌ ‌It‌ ‌is‌ ‌ ‌more‌ ‌efficient‌ ‌to‌ ‌use‌ ‌that‌ ‌wait‌ ‌time‌ ‌to‌ ‌let‌ ‌another‌ ‌program‌ ‌run.‌ ‌ ‌Fairness.‌ ‌‌Multiple‌ ‌users‌ ‌and‌ ‌programs‌ ‌may‌ ‌have‌ ‌equal‌ ‌claims‌ ‌on‌ ‌the‌ ‌machine’s‌ ‌ ‌resources.‌ ‌It‌ ‌is‌ ‌preferable‌ ‌to‌ ‌let‌ ‌them‌ ‌share‌ ‌the‌ ‌computer‌ ‌via‌ ‌finer-grained‌ ‌ ‌time‌ ‌slicing‌ ‌than‌ ‌to‌ ‌let‌ ‌one‌ ‌program‌ ‌run‌ ‌to‌ ‌completion‌ ‌and‌ ‌then‌ ‌start‌ ‌an‌ ‌ ‌other.‌ ‌ ‌1‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌2‌ ‌‌Chapter‌ ‌‌1‌.‌ ‌Introduction‌ ‌ ‌Convenience.‌ ‌‌It‌ ‌is‌ ‌often‌ ‌easier‌ ‌or‌ ‌more‌ ‌desirable‌ ‌to‌ ‌write‌ ‌several‌ ‌programs‌ ‌that‌ ‌ ‌each‌ ‌perform‌ ‌a‌ ‌single‌ ‌task‌ ‌and‌ ‌have‌ ‌them‌ ‌coordinate‌ ‌with‌ ‌each‌ ‌other‌ ‌as‌ ‌ ‌necessary‌ ‌than‌ ‌to‌ ‌write‌ ‌a‌ ‌single‌ ‌program‌ ‌that‌ ‌performs‌ ‌all‌ ‌the‌ ‌tasks.‌ ‌ ‌In‌ ‌early‌ ‌timesharing‌ ‌systems,‌ ‌each‌ ‌process‌ ‌was‌ ‌a‌ ‌virtual‌ ‌von‌ ‌Neumann‌ ‌com‌ ‌ ‌puter;‌ ‌it‌ ‌had‌ ‌a‌ ‌memory‌ ‌space‌ ‌storing‌ ‌both‌ ‌instructions‌ ‌and‌ ‌data,‌ ‌executing‌ ‌in‌ ‌ ‌structions‌ ‌sequentially‌ ‌according‌ ‌to‌ ‌the‌ ‌semantics‌ ‌of‌ ‌the‌ ‌machine‌ ‌language,‌ ‌and‌ ‌ ‌interacting‌ ‌with‌ ‌the‌ ‌outside‌ ‌world‌ ‌via‌ ‌the‌ ‌operating‌ ‌system‌ ‌through‌ ‌a‌ ‌set‌ ‌of‌ ‌I/O‌ ‌ ‌primitives.‌ ‌For‌ ‌each‌ ‌instruction‌ ‌executed‌ ‌there‌ ‌was‌ ‌a‌ ‌clearly‌ ‌defined‌ ‌“next‌ ‌in‌ ‌ ‌struction”,‌ ‌and‌ ‌control‌ ‌flowed‌ ‌through‌ ‌the‌ ‌program‌ ‌according‌ ‌to‌ ‌the‌ ‌rules‌ ‌of‌ ‌the‌ ‌ ‌instruction‌ ‌set.‌ ‌Nearly‌ ‌all‌ ‌widely‌ ‌used‌ ‌programming‌ ‌languages‌ ‌today‌ ‌follow‌ ‌this‌ ‌ ‌sequential‌ ‌programming‌ ‌model,‌ ‌where‌ ‌the‌ ‌language‌ ‌specification‌ ‌clearly‌ ‌defines‌ ‌ ‌“what‌ ‌comes‌ ‌next”‌ ‌after‌ ‌a‌ ‌given‌ ‌action‌ ‌is‌ ‌executed.‌ ‌ ‌The‌ ‌sequential‌ ‌programming‌ ‌model‌ ‌is‌ ‌intuitive‌ ‌and‌ ‌natural,‌ ‌as‌ ‌it‌ ‌models‌ ‌the‌ ‌ ‌way‌ ‌humans‌ ‌work:‌ ‌do‌ ‌one‌ ‌thing‌ ‌at‌ ‌a‌ ‌time,‌ ‌in‌ ‌sequence—mostly.‌ ‌Get‌ ‌out‌ ‌of‌ ‌ ‌bed,‌ ‌put‌ ‌on‌ ‌your‌ ‌bathrobe,‌ ‌go‌ ‌downstairs‌ ‌and‌ ‌start‌ ‌the‌ ‌tea.‌ ‌As‌ ‌in‌ ‌programming‌ ‌ ‌languages,‌ ‌each‌ ‌of‌ ‌these‌ ‌real-world‌ ‌actions‌ ‌is‌ ‌an‌ ‌abstraction‌ ‌for‌ ‌a‌ ‌sequence‌ ‌of‌ ‌ ‌finer-grained‌ ‌actions—open‌ ‌the‌ ‌cupboard,‌ ‌select‌ ‌a‌ ‌flavor‌ ‌of‌ ‌tea,‌ ‌measure‌ ‌some‌ ‌ ‌tea‌ ‌into‌ ‌the‌ ‌pot,‌ ‌see‌ ‌if‌ ‌there’s‌ ‌enough‌ ‌water‌ ‌in‌ ‌the‌ ‌teakettle,‌ ‌if‌ ‌not‌ ‌put‌ ‌some‌ ‌more‌ ‌ ‌water‌ ‌in,‌ ‌set‌ ‌it‌ ‌on‌ ‌the‌ ‌stove,‌ ‌turn‌ ‌the‌ ‌stove‌ ‌on,‌ ‌wait‌ ‌for‌ ‌the‌ ‌water‌ ‌to‌ ‌boil,‌ ‌and‌ ‌so‌ ‌on.‌ ‌ ‌This‌ ‌last‌ ‌step—waiting‌ ‌for‌ ‌the‌ ‌water‌ ‌to‌ ‌boil—also‌ ‌involves‌ ‌a‌ ‌degree‌ ‌of‌ ‌‌asynchrony‌.‌ ‌ ‌While‌ ‌the‌ ‌water‌ ‌is‌ ‌heating,‌ ‌you‌ ‌have‌ ‌a‌ ‌choice‌ ‌of‌ ‌what‌ ‌to‌ ‌do—just‌ ‌wait,‌ ‌or‌ ‌do‌ ‌ ‌other‌ ‌tasks‌ ‌in‌ ‌that‌ ‌time‌ ‌such‌ ‌as‌ ‌starting‌ ‌the‌ ‌toast‌ ‌(another‌ ‌asynchronous‌ ‌task)‌ ‌or‌ ‌ ‌fetching‌ ‌the‌ ‌newspaper,‌ ‌while‌ ‌remaining‌ ‌aware‌ ‌that‌ ‌your‌ ‌attention‌ ‌will‌ ‌soon‌ ‌be‌ ‌ ‌needed‌ ‌by‌ ‌the‌ ‌teakettle.‌ ‌The‌ ‌manufacturers‌ ‌of‌ ‌teakettles‌ ‌and‌ ‌toasters‌ ‌know‌ ‌their‌ ‌ ‌products‌ ‌are‌ ‌often‌ ‌used‌ ‌in‌ ‌an‌ ‌asynchronous‌ ‌manner,‌ ‌so‌ ‌they‌ ‌raise‌ ‌an‌ ‌audible‌ ‌ ‌signal‌ ‌when‌ ‌they‌ ‌complete‌ ‌their‌ ‌task.‌ ‌Finding‌ ‌the‌ ‌right‌ ‌balance‌ ‌of‌ ‌sequentiality‌ ‌ ‌and‌ ‌asynchrony‌ ‌is‌ ‌often‌ ‌a‌ ‌characteristic‌ ‌of‌ ‌efficient‌ ‌people—and‌ ‌the‌ ‌same‌ ‌is‌ ‌true‌ ‌ ‌of‌ ‌programs.‌ ‌ ‌The‌ ‌same‌ ‌concerns‌ ‌(resource‌ ‌utilization,‌ ‌fairness,‌ ‌and‌ ‌convenience)‌ ‌that‌ ‌mo‌ ‌ ‌tivated‌ ‌the‌ ‌development‌ ‌of‌ ‌processes‌ ‌also‌ ‌motivated‌ ‌the‌ ‌development‌ ‌of‌ ‌‌threads‌.‌ ‌ ‌Threads‌ ‌allow‌ ‌multiple‌ ‌streams‌ ‌of‌ ‌program‌ ‌control‌ ‌flow‌ ‌to‌ ‌coexist‌ ‌within‌ ‌a‌ ‌proc‌ ‌ ‌ess.‌ ‌They‌ ‌share‌ ‌process-wide‌ ‌resources‌ ‌such‌ ‌as‌ ‌memory‌ ‌and‌ ‌file‌ ‌handles,‌ ‌but‌ ‌ ‌each‌ ‌thread‌ ‌has‌ ‌its‌ ‌own‌ ‌program‌ ‌counter,‌ ‌stack,‌ ‌and‌ ‌local‌ ‌variables.‌ ‌Threads‌ ‌also‌ ‌ ‌provide‌ ‌a‌ ‌natural‌ ‌decomposition‌ ‌for‌ ‌exploiting‌ ‌hardware‌ ‌parallelism‌ ‌on‌ ‌multi‌ ‌ ‌processor‌ ‌systems;‌ ‌multiple‌ ‌threads‌ ‌within‌ ‌the‌ ‌same‌ ‌program‌ ‌can‌ ‌be‌ ‌scheduled‌ ‌ ‌simultaneously‌ ‌on‌ ‌multiple‌ ‌CPUs.‌ ‌ ‌Threads‌ ‌are‌ ‌sometimes‌ ‌called‌ ‌‌lightweight‌ ‌processes‌,‌ ‌and‌ ‌most‌ ‌modern‌ ‌oper‌ ‌ ‌ating‌ ‌systems‌ ‌treat‌ ‌threads,‌ ‌not‌ ‌processes,‌ ‌as‌ ‌the‌ ‌basic‌ ‌units‌ ‌of‌ ‌scheduling.‌ ‌In‌ ‌ ‌the‌ ‌absence‌ ‌of‌ ‌explicit‌ ‌coordination,‌ ‌threads‌ ‌execute‌ ‌simultaneously‌ ‌and‌ ‌asyn‌ ‌ ‌chronously‌ ‌with‌ ‌respect‌ ‌to‌ ‌one‌ ‌another.‌ ‌Since‌ ‌threads‌ ‌share‌ ‌the‌ ‌memory‌ ‌address‌ ‌ ‌space‌ ‌of‌ ‌their‌ ‌owning‌ ‌process,‌ ‌all‌ ‌threads‌ ‌within‌ ‌a‌ ‌process‌ ‌have‌ ‌access‌ ‌to‌ ‌the‌ ‌same‌ ‌ ‌variables‌ ‌and‌ ‌allocate‌ ‌objects‌ ‌from‌ ‌the‌ ‌same‌ ‌heap,‌ ‌which‌ ‌allows‌ ‌finer-grained‌ ‌data‌ ‌ ‌sharing‌ ‌than‌ ‌inter-process‌ ‌mechanisms.‌ ‌But‌ ‌without‌ ‌explicit‌ ‌synchronization‌ ‌to‌ ‌ ‌coordinate‌ ‌access‌ ‌to‌ ‌shared‌ ‌data,‌ ‌a‌ ‌thread‌ ‌may‌ ‌modify‌ ‌variables‌ ‌that‌ ‌another‌ ‌ ‌thread‌ ‌is‌ ‌in‌ ‌the‌ ‌middle‌ ‌of‌ ‌using,‌ ‌with‌ ‌unpredictable‌ ‌results.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌4‌ ‌‌Chapter‌ ‌‌1‌.‌ ‌Introduction‌ ‌ ‌multiple‌ ‌priorities‌ ‌and‌ ‌deadlines‌ ‌and‌ ‌switching‌ ‌from‌ ‌task‌ ‌to‌ ‌task‌ ‌usually‌ ‌carries‌ ‌ ‌some‌ ‌overhead.‌ ‌ ‌The‌ ‌same‌ ‌is‌ ‌true‌ ‌for‌ ‌software:‌ ‌a‌ ‌program‌ ‌that‌ ‌processes‌ ‌one‌ ‌type‌ ‌of‌ ‌task‌ ‌ ‌sequentially‌ ‌is‌ ‌simpler‌ ‌to‌ ‌write,‌ ‌less‌ ‌error-prone,‌ ‌and‌ ‌easier‌ ‌to‌ ‌test‌ ‌than‌ ‌one‌ ‌man‌ ‌ ‌aging‌ ‌multiple‌ ‌different‌ ‌types‌ ‌of‌ ‌tasks‌ ‌at‌ ‌once.‌ ‌Assigning‌ ‌a‌ ‌thread‌ ‌to‌ ‌each‌ ‌type‌ ‌of‌ ‌ ‌task‌ ‌or‌ ‌to‌ ‌each‌ ‌element‌ ‌in‌ ‌a‌ ‌simulation‌ ‌affords‌ ‌the‌ ‌illusion‌ ‌of‌ ‌sequentiality‌ ‌and‌ ‌in‌ ‌ ‌sulates‌ ‌domain‌ ‌logic‌ ‌from‌ ‌the‌ ‌details‌ ‌of‌ ‌scheduling,‌ ‌interleaved‌ ‌operations,‌ ‌asyn‌ ‌ ‌chronous‌ ‌I/O,‌ ‌and‌ ‌resource‌ ‌waits.‌ ‌A‌ ‌complicated,‌ ‌asynchronous‌ ‌workflow‌ ‌can‌ ‌ ‌be‌ ‌decomposed‌ ‌into‌ ‌a‌ ‌number‌ ‌of‌ ‌simpler,‌ ‌synchronous‌ ‌workflows‌ ‌each‌ ‌running‌ ‌ ‌in‌ ‌a‌ ‌separate‌ ‌thread,‌ ‌interacting‌ ‌only‌ ‌with‌ ‌each‌ ‌other‌ ‌at‌ ‌specific‌ ‌synchronization‌ ‌ ‌points.‌ ‌ ‌This‌ ‌benefit‌ ‌is‌ ‌often‌ ‌exploited‌ ‌by‌ ‌frameworks‌ ‌such‌ ‌as‌ ‌servlets‌ ‌or‌ ‌RMI‌ ‌(Remote‌ ‌ ‌Method‌ ‌Invocation).‌ ‌The‌ ‌framework‌ ‌handles‌ ‌the‌ ‌details‌ ‌of‌ ‌request‌ ‌management,‌ ‌ ‌thread‌ ‌creation,‌ ‌and‌ ‌load‌ ‌balancing,‌ ‌dispatching‌ ‌portions‌ ‌of‌ ‌the‌ ‌request‌ ‌handling‌ ‌ ‌to‌ ‌the‌ ‌appropriate‌ ‌application‌ ‌component‌ ‌at‌ ‌the‌ ‌appropriate‌ ‌point‌ ‌in‌ ‌the‌ ‌work‌ ‌ ‌flow.‌ ‌Servlet‌ ‌writers‌ ‌do‌ ‌not‌ ‌need‌ ‌to‌ ‌worry‌ ‌about‌ ‌how‌ ‌many‌ ‌other‌ ‌requests‌ ‌are‌ ‌ ‌being‌ ‌processed‌ ‌at‌ ‌the‌ ‌same‌ ‌time‌ ‌or‌ ‌whether‌ ‌the‌ ‌socket‌ ‌input‌ ‌and‌ ‌output‌ ‌streams‌ ‌ ‌block;‌ ‌when‌ ‌a‌ ‌servlet’s‌ ‌‌service‌ ‌‌method‌ ‌is‌ ‌called‌ ‌in‌ ‌response‌ ‌to‌ ‌a‌ ‌web‌ ‌request,‌ ‌ ‌it‌ ‌can‌ ‌process‌ ‌the‌ ‌request‌ ‌synchronously‌ ‌as‌ ‌if‌ ‌it‌ ‌were‌ ‌a‌ ‌single-threaded‌ ‌program.‌ ‌ ‌This‌ ‌can‌ ‌simplify‌ ‌component‌ ‌development‌ ‌and‌ ‌reduce‌ ‌the‌ ‌learning‌ ‌curve‌ ‌for‌ ‌us‌ ‌ ‌ing‌ ‌such‌ ‌frameworks.‌ ‌ ‌1‌.‌2‌.‌3‌ ‌‌Simplified‌ ‌handling‌ ‌of‌ ‌asynchronous‌ ‌events‌ ‌ ‌A‌ ‌server‌ ‌application‌ ‌that‌ ‌accepts‌ ‌socket‌ ‌connections‌ ‌from‌ ‌multiple‌ ‌remote‌ ‌clients‌ ‌ ‌may‌ ‌be‌ ‌easier‌ ‌to‌ ‌develop‌ ‌when‌ ‌each‌ ‌connection‌ ‌is‌ ‌allocated‌ ‌its‌ ‌own‌ ‌thread‌ ‌and‌ ‌ ‌allowed‌ ‌to‌ ‌use‌ ‌synchronous‌ ‌I/O.‌ ‌ ‌If‌ ‌an‌ ‌application‌ ‌goes‌ ‌to‌ ‌read‌ ‌from‌ ‌a‌ ‌socket‌ ‌when‌ ‌no‌ ‌data‌ ‌is‌ ‌available,‌ ‌‌read‌ ‌ ‌blocks‌ ‌until‌ ‌some‌ ‌data‌ ‌is‌ ‌available.‌ ‌In‌ ‌a‌ ‌single-threaded‌ ‌application,‌ ‌this‌ ‌means‌ ‌ ‌that‌ ‌not‌ ‌only‌ ‌does‌ ‌processing‌ ‌the‌ ‌corresponding‌ ‌request‌ ‌stall,‌ ‌but‌ ‌processing‌ ‌of‌ ‌ ‌all‌ ‌‌requests‌ ‌stalls‌ ‌while‌ ‌the‌ ‌single‌ ‌thread‌ ‌is‌ ‌blocked.‌ ‌To‌ ‌avoid‌ ‌this‌ ‌problem,‌ ‌single‌ ‌ ‌threaded‌ ‌server‌ ‌applications‌ ‌are‌ ‌forced‌ ‌to‌ ‌use‌ ‌nonblocking‌ ‌I/O,‌ ‌which‌ ‌is‌ ‌far‌ ‌more‌ ‌ ‌complicated‌ ‌and‌ ‌error-prone‌ ‌than‌ ‌synchronous‌ ‌I/O.‌ ‌However,‌ ‌if‌ ‌each‌ ‌request‌ ‌has‌ ‌ ‌its‌ ‌own‌ ‌thread,‌ ‌then‌ ‌blocking‌ ‌does‌ ‌not‌ ‌affect‌ ‌the‌ ‌processing‌ ‌of‌ ‌other‌ ‌requests.‌ ‌ ‌Historically,‌ ‌operating‌ ‌systems‌ ‌placed‌ ‌relatively‌ ‌low‌ ‌limits‌ ‌on‌ ‌the‌ ‌number‌ ‌of‌ ‌ ‌threads‌ ‌that‌ ‌a‌ ‌process‌ ‌could‌ ‌create,‌ ‌as‌ ‌few‌ ‌as‌ ‌several‌ ‌hundred‌ ‌(or‌ ‌even‌ ‌less).‌ ‌ ‌As‌ ‌a‌ ‌result,‌ ‌operating‌ ‌systems‌ ‌developed‌ ‌efficient‌ ‌facilities‌ ‌for‌ ‌multiplexed‌ ‌I/O,‌ ‌ ‌such‌ ‌as‌ ‌the‌ ‌Unix‌ ‌‌select‌ ‌‌and‌ ‌‌poll‌ ‌‌system‌ ‌calls,‌ ‌and‌ ‌to‌ ‌access‌ ‌these‌ ‌facilities,‌ ‌the‌ ‌ ‌Java‌ ‌class‌ ‌libraries‌ ‌acquired‌ ‌a‌ ‌set‌ ‌of‌ ‌packages‌ ‌(‌java.nio‌)‌ ‌for‌ ‌nonblocking‌ ‌I/O.‌ ‌ ‌However,‌ ‌operating‌ ‌system‌ ‌support‌ ‌for‌ ‌larger‌ ‌numbers‌ ‌of‌ ‌threads‌ ‌has‌ ‌improved‌ ‌ ‌significantly,‌ ‌making‌ ‌the‌ ‌thread-per-client‌ ‌model‌ ‌practical‌ ‌even‌ ‌for‌ ‌large‌ ‌numbers‌ ‌ ‌of‌ ‌clients‌ ‌on‌ ‌some‌ ‌platforms.‌1‌ ‌ ‌1‌.‌ ‌The‌ ‌NPTL‌ ‌threads‌ ‌package,‌ ‌now‌ ‌part‌ ‌of‌ ‌most‌ ‌Linux‌ ‌distributions,‌ ‌was‌ ‌designed‌ ‌to‌ ‌support‌ ‌hun‌ ‌ ‌dreds‌ ‌of‌ ‌thousands‌ ‌of‌ ‌threads.‌ ‌Nonblocking‌ ‌I/O‌ ‌has‌ ‌its‌ ‌own‌ ‌benefits,‌ ‌but‌ ‌better‌ ‌OS‌ ‌support‌ ‌for‌ ‌ ‌threads‌ ‌means‌ ‌that‌ ‌there‌ ‌are‌ ‌fewer‌ ‌situations‌ ‌for‌ ‌which‌ ‌it‌ ‌is‌ ‌‌essential‌.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌1‌.‌3‌.‌ ‌Risks‌ ‌of‌ ‌threads‌ ‌‌5‌ ‌ ‌1‌.‌2‌.‌4‌ ‌‌More‌ ‌responsive‌ ‌user‌ ‌interfaces‌ ‌ ‌GUI‌ ‌applications‌ ‌used‌ ‌to‌ ‌be‌ ‌single-threaded,‌ ‌which‌ ‌meant‌ ‌that‌ ‌you‌ ‌had‌ ‌to‌ ‌either‌ ‌ ‌frequently‌ ‌poll‌ ‌throughout‌ ‌the‌ ‌code‌ ‌for‌ ‌input‌ ‌events‌ ‌(which‌ ‌is‌ ‌messy‌ ‌and‌ ‌intru‌ ‌ ‌sive)‌ ‌or‌ ‌execute‌ ‌all‌ ‌application‌ ‌code‌ ‌indirectly‌ ‌through‌ ‌a‌ ‌“main‌ ‌event‌ ‌loop”.‌ ‌If‌ ‌ ‌code‌ ‌called‌ ‌from‌ ‌the‌ ‌main‌ ‌event‌ ‌loop‌ ‌takes‌ ‌too‌ ‌long‌ ‌to‌ ‌execute,‌ ‌the‌ ‌user‌ ‌interface‌ ‌ ‌appears‌ ‌to‌ ‌“freeze”‌ ‌until‌ ‌that‌ ‌code‌ ‌finishes,‌ ‌because‌ ‌subsequent‌ ‌user‌ ‌interface‌ ‌ ‌events‌ ‌cannot‌ ‌be‌ ‌processed‌ ‌until‌ ‌control‌ ‌is‌ ‌returned‌ ‌to‌ ‌the‌ ‌main‌ ‌event‌ ‌loop.‌ ‌ ‌Modern‌ ‌GUI‌ ‌frameworks,‌ ‌such‌ ‌as‌ ‌the‌ ‌AWT‌ ‌and‌ ‌Swing‌ ‌toolkits,‌ ‌replace‌ ‌the‌ ‌ ‌main‌ ‌event‌ ‌loop‌ ‌with‌ ‌an‌ ‌‌event‌ ‌dispatch‌ ‌thread‌ ‌‌(EDT).‌ ‌When‌ ‌a‌ ‌user‌ ‌interface‌ ‌event‌ ‌ ‌such‌ ‌as‌ ‌a‌ ‌button‌ ‌press‌ ‌occurs,‌ ‌application-defined‌ ‌event‌ ‌handlers‌ ‌are‌ ‌called‌ ‌in‌ ‌ ‌Licensed‌ ‌by‌ ‌ ‌the‌ ‌event‌ ‌thread.‌ ‌Most‌ ‌GUI‌ ‌frameworks‌ ‌are‌ ‌single-threaded‌ ‌subsystems,‌ ‌so‌ ‌the‌ ‌ ‌main‌ ‌event‌ ‌loop‌ ‌is‌ ‌effectively‌ ‌still‌ ‌present,‌ ‌but‌ ‌it‌ ‌runs‌ ‌in‌ ‌its‌ ‌own‌ ‌thread‌ ‌under‌ ‌the‌ ‌ ‌control‌ ‌of‌ ‌the‌ ‌GUI‌ ‌toolkit‌ ‌rather‌ ‌than‌ ‌the‌ ‌application.‌ ‌ ‌If‌ ‌only‌ ‌short-lived‌ ‌tasks‌ ‌execute‌ ‌in‌ ‌the‌ ‌event‌ ‌thread,‌ ‌the‌ ‌interface‌ ‌remains‌ ‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌responsive‌ ‌since‌ ‌the‌ ‌event‌ ‌thread‌ ‌is‌ ‌always‌ ‌able‌ ‌to‌ ‌process‌ ‌user‌ ‌actions‌ ‌reasonably‌ ‌ ‌quickly.‌ ‌However,‌ ‌processing‌ ‌a‌ ‌long-running‌ ‌task‌ ‌in‌ ‌the‌ ‌event‌ ‌thread,‌ ‌such‌ ‌as‌ ‌ ‌spell-checking‌ ‌a‌ ‌large‌ ‌document‌ ‌or‌ ‌fetching‌ ‌a‌ ‌resource‌ ‌over‌ ‌the‌ ‌network,‌ ‌impairs‌ ‌ ‌responsiveness.‌ ‌If‌ ‌the‌ ‌user‌ ‌performs‌ ‌an‌ ‌action‌ ‌while‌ ‌this‌ ‌task‌ ‌is‌ ‌running,‌ ‌there‌ ‌is‌ ‌ ‌1821604‌ ‌a‌ ‌long‌ ‌delay‌ ‌before‌ ‌the‌ ‌event‌ ‌thread‌ ‌can‌ ‌process‌ ‌or‌ ‌even‌ ‌acknowledge‌ ‌it.‌ ‌To‌ ‌add‌ ‌ ‌insult‌ ‌to‌ ‌injury,‌ ‌not‌ ‌only‌ ‌does‌ ‌the‌ ‌UI‌ ‌become‌ ‌unresponsive,‌ ‌but‌ ‌it‌ ‌is‌ ‌impossible‌ ‌ ‌to‌ ‌cancel‌ ‌the‌ ‌offending‌ ‌task‌ ‌even‌ ‌if‌ ‌the‌ ‌UI‌ ‌provides‌ ‌a‌ ‌cancel‌ ‌button‌ ‌because‌ ‌the‌ ‌ ‌event‌ ‌thread‌ ‌is‌ ‌busy‌ ‌and‌ ‌cannot‌ ‌handle‌ ‌the‌ ‌cancel‌ ‌button-press‌ ‌event‌ ‌until‌ ‌the‌ ‌ ‌lengthy‌ ‌task‌ ‌completes!‌ ‌If,‌ ‌however,‌ ‌the‌ ‌long-running‌ ‌task‌ ‌is‌ ‌instead‌ ‌executed‌ ‌in‌ ‌ ‌a‌ ‌separate‌ ‌thread,‌ ‌the‌ ‌event‌ ‌thread‌ ‌remains‌ ‌free‌ ‌to‌ ‌process‌ ‌UI‌ ‌events,‌ ‌making‌ ‌the‌ ‌ ‌UI‌ ‌more‌ ‌responsive.‌ ‌ ‌1‌.‌3‌ ‌‌Risks‌ ‌of‌ ‌threads‌ ‌ ‌Java’s‌ ‌built-in‌ ‌support‌ ‌for‌ ‌threads‌ ‌is‌ ‌a‌ ‌double-edged‌ ‌sword.‌ ‌While‌ ‌it‌ ‌simplifies‌ ‌the‌ ‌ ‌development‌ ‌of‌ ‌concurrent‌ ‌applications‌ ‌by‌ ‌providing‌ ‌language‌ ‌and‌ ‌library‌ ‌sup‌ ‌ ‌port‌ ‌and‌ ‌a‌ ‌formal‌ ‌cross-platform‌ ‌memory‌ ‌model‌ ‌(it‌ ‌is‌ ‌this‌ ‌formal‌ ‌cross-platform‌ ‌ ‌memory‌ ‌model‌ ‌that‌ ‌makes‌ ‌possible‌ ‌the‌ ‌development‌ ‌of‌ ‌write-once,‌ ‌run-anywhere‌ ‌ ‌concurrent‌ ‌‌applications‌ ‌in‌ ‌Java),‌ ‌it‌ ‌also‌ ‌raises‌ ‌the‌ ‌bar‌ ‌for‌ ‌developers‌ ‌because‌ ‌more‌ ‌ ‌programs‌ ‌will‌ ‌use‌ ‌threads.‌ ‌When‌ ‌threads‌ ‌were‌ ‌more‌ ‌esoteric,‌ ‌concurrency‌ ‌was‌ ‌ ‌an‌ ‌“advanced”‌ ‌topic;‌ ‌now,‌ ‌mainstream‌ ‌developers‌ ‌must‌ ‌be‌ ‌aware‌ ‌of‌ ‌thread-safety‌ ‌ ‌issues.‌ ‌ ‌porarily‌ ‌(or‌ ‌even‌ ‌permanently)‌ ‌invisible‌ ‌to‌ ‌other‌ ‌threads.‌ ‌These‌ ‌tricks‌ ‌are‌ ‌in‌ ‌aid‌ ‌ ‌of‌ ‌better‌ ‌performance‌ ‌and‌ ‌are‌ ‌generally‌ ‌desirable,‌ ‌but‌ ‌they‌ ‌place‌ ‌a‌ ‌burden‌ ‌on‌ ‌the‌ ‌ ‌developer‌ ‌to‌ ‌clearly‌ ‌identify‌ ‌where‌ ‌data‌ ‌is‌ ‌being‌ ‌shared‌ ‌across‌ ‌threads‌ ‌so‌ ‌that‌ ‌ ‌these‌ ‌optimizations‌ ‌do‌ ‌not‌ ‌undermine‌ ‌safety.‌ ‌(Chapter‌ ‌‌16‌ ‌‌gives‌ ‌the‌ ‌gory‌ ‌details‌ ‌ ‌on‌ ‌exactly‌ ‌what‌ ‌ordering‌ ‌guarantees‌ ‌the‌ ‌JVM‌ ‌makes‌ ‌and‌ ‌how‌ ‌synchronization‌ ‌ ‌3‌.‌ ‌‌@GuardedBy‌ ‌‌is‌ ‌described‌ ‌in‌ ‌Section‌ ‌‌2‌.‌4‌;‌ ‌it‌ ‌documents‌ ‌the‌ ‌‌synchronization‌ ‌policy‌ ‌‌for‌ ‌‌Sequence‌.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌8‌ ‌‌Chapter‌ ‌‌1‌.‌ ‌Introduction‌ ‌ ‌affects‌ ‌those‌ ‌guarantees,‌ ‌but‌ ‌if‌ ‌you‌ ‌follow‌ ‌the‌ ‌rules‌ ‌in‌ ‌Chapters‌ ‌‌2‌ ‌‌and‌ ‌‌3‌,‌ ‌you‌ ‌can‌ ‌ ‌safely‌ ‌avoid‌ ‌these‌ ‌low-level‌ ‌details.)‌ ‌ ‌1‌.‌3‌.‌2‌ ‌‌Liveness‌ ‌hazards‌ ‌ ‌It‌ ‌is‌ ‌critically‌ ‌important‌ ‌to‌ ‌pay‌ ‌attention‌ ‌to‌ ‌thread‌ ‌safety‌ ‌issues‌ ‌when‌ ‌develop‌ ‌ ‌ing‌ ‌concurrent‌ ‌code:‌ ‌safety‌ ‌cannot‌ ‌be‌ ‌compromised.‌ ‌The‌ ‌importance‌ ‌of‌ ‌safety‌ ‌ ‌is‌ ‌not‌ ‌unique‌ ‌to‌ ‌multithreaded‌ ‌programs—single-threaded‌ ‌programs‌ ‌also‌ ‌must‌ ‌ ‌take‌ ‌care‌ ‌to‌ ‌preserve‌ ‌safety‌ ‌and‌ ‌correctness—but‌ ‌the‌ ‌use‌ ‌of‌ ‌threads‌ ‌introduces‌ ‌ ‌additional‌ ‌safety‌ ‌hazards‌ ‌not‌ ‌present‌ ‌in‌ ‌single-threaded‌ ‌programs.‌ ‌Similarly,‌ ‌the‌ ‌ ‌use‌ ‌of‌ ‌threads‌ ‌introduces‌ ‌additional‌ ‌forms‌ ‌of‌ ‌‌liveness‌ ‌failure‌ ‌‌that‌ ‌do‌ ‌not‌ ‌occur‌ ‌in‌ ‌ ‌single-threaded‌ ‌programs.‌ ‌ ‌While‌ ‌‌safety‌ ‌‌means‌ ‌“nothing‌ ‌bad‌ ‌ever‌ ‌happens”,‌ ‌liveness‌ ‌concerns‌ ‌the‌ ‌com‌ ‌ ‌plementary‌ ‌goal‌ ‌that‌ ‌“something‌ ‌good‌ ‌eventually‌ ‌happens”.‌ ‌A‌ ‌liveness‌ ‌failure‌ ‌ ‌occurs‌ ‌when‌ ‌an‌ ‌activity‌ ‌gets‌ ‌into‌ ‌a‌ ‌state‌ ‌such‌ ‌that‌ ‌it‌ ‌is‌ ‌permanently‌ ‌unable‌ ‌to‌ ‌ ‌make‌ ‌forward‌ ‌progress.‌ ‌One‌ ‌form‌ ‌of‌ ‌liveness‌ ‌failure‌ ‌that‌ ‌can‌ ‌occur‌ ‌in‌ ‌sequential‌ ‌ ‌programs‌ ‌is‌ ‌an‌ ‌inadvertent‌ ‌infinite‌ ‌loop,‌ ‌where‌ ‌the‌ ‌code‌ ‌that‌ ‌follows‌ ‌the‌ ‌loop‌ ‌ ‌never‌ ‌gets‌ ‌executed.‌ ‌The‌ ‌use‌ ‌of‌ ‌threads‌ ‌introduces‌ ‌additional‌ ‌liveness‌ ‌risks.‌ ‌For‌ ‌ ‌example,‌ ‌if‌ ‌thread‌ ‌‌A‌ ‌‌is‌ ‌waiting‌ ‌for‌ ‌a‌ ‌resource‌ ‌that‌ ‌thread‌ ‌‌B‌ ‌‌holds‌ ‌exclusively,‌ ‌and‌ ‌ ‌B‌ ‌‌never‌ ‌releases‌ ‌it,‌ ‌‌A‌ ‌‌will‌ ‌wait‌ ‌forever.‌ ‌Chapter‌ ‌‌10‌ ‌‌describes‌ ‌various‌ ‌forms‌ ‌of‌ ‌ ‌liveness‌ ‌failures‌ ‌and‌ ‌how‌ ‌to‌ ‌avoid‌ ‌them,‌ ‌including‌ ‌deadlock‌ ‌(Section‌ ‌‌10‌.‌1‌),‌ ‌star‌ ‌ ‌vation‌ ‌(Section‌ ‌‌10‌.‌3‌.‌1‌),‌ ‌and‌ ‌livelock‌ ‌(Section‌ ‌‌10‌.‌3‌.‌3‌).‌ ‌Like‌ ‌most‌ ‌concurrency‌ ‌bugs,‌ ‌ ‌bugs‌ ‌that‌ ‌cause‌ ‌liveness‌ ‌failures‌ ‌can‌ ‌be‌ ‌elusive‌ ‌because‌ ‌they‌ ‌depend‌ ‌on‌ ‌the‌ ‌rel‌ ‌ ‌ative‌ ‌timing‌ ‌of‌ ‌events‌ ‌in‌ ‌different‌ ‌threads,‌ ‌and‌ ‌therefore‌ ‌do‌ ‌not‌ ‌always‌ ‌manifest‌ ‌ ‌themselves‌ ‌in‌ ‌development‌ ‌or‌ ‌testing.‌ ‌ ‌1‌.‌3‌.‌3‌ ‌‌Performance‌ ‌hazards‌ ‌ ‌Related‌ ‌to‌ ‌liveness‌ ‌is‌ ‌‌performance‌.‌ ‌While‌ ‌liveness‌ ‌means‌ ‌that‌ ‌something‌ ‌good‌ ‌‌even‌ ‌ ‌tually‌ ‌‌happens,‌ ‌eventually‌ ‌may‌ ‌not‌ ‌be‌ ‌good‌ ‌enough—we‌ ‌often‌ ‌want‌ ‌good‌ ‌things‌ ‌ ‌to‌ ‌happen‌ ‌quickly.‌ ‌Performance‌ ‌issues‌ ‌subsume‌ ‌a‌ ‌broad‌ ‌range‌ ‌of‌ ‌problems,‌ ‌in‌ ‌ ‌cluding‌ ‌poor‌ ‌service‌ ‌time,‌ ‌responsiveness,‌ ‌throughput,‌ ‌resource‌ ‌consumption,‌ ‌or‌ ‌ ‌scalability.‌ ‌Just‌ ‌as‌ ‌with‌ ‌safety‌ ‌and‌ ‌liveness,‌ ‌multithreaded‌ ‌programs‌ ‌are‌ ‌subject‌ ‌ ‌to‌ ‌all‌ ‌the‌ ‌performance‌ ‌hazards‌ ‌of‌ ‌single-threaded‌ ‌programs,‌ ‌and‌ ‌to‌ ‌others‌ ‌as‌ ‌well‌ ‌ ‌that‌ ‌are‌ ‌introduced‌ ‌by‌ ‌the‌ ‌use‌ ‌of‌ ‌threads.‌ ‌ ‌In‌ ‌well‌ ‌designed‌ ‌concurrent‌ ‌applications‌ ‌the‌ ‌use‌ ‌of‌ ‌threads‌ ‌is‌ ‌a‌ ‌net‌ ‌perfor‌ ‌ ‌mance‌ ‌gain,‌ ‌but‌ ‌threads‌ ‌nevertheless‌ ‌carry‌ ‌some‌ ‌degree‌ ‌of‌ ‌runtime‌ ‌overhead.‌ ‌ ‌Context‌ ‌switches‌—when‌ ‌the‌ ‌scheduler‌ ‌suspends‌ ‌the‌ ‌active‌ ‌thread‌ ‌temporarily‌ ‌so‌ ‌ ‌another‌ ‌thread‌ ‌can‌ ‌run—are‌ ‌more‌ ‌frequent‌ ‌in‌ ‌applications‌ ‌with‌ ‌many‌ ‌threads,‌ ‌ ‌and‌ ‌have‌ ‌significant‌ ‌costs:‌ ‌saving‌ ‌and‌ ‌restoring‌ ‌execution‌ ‌context,‌ ‌loss‌ ‌of‌ ‌lo‌ ‌ ‌cality,‌ ‌and‌ ‌CPU‌ ‌time‌ ‌spent‌ ‌scheduling‌ ‌threads‌ ‌instead‌ ‌of‌ ‌running‌ ‌them.‌ ‌When‌ ‌ ‌threads‌ ‌share‌ ‌data,‌ ‌they‌ ‌must‌ ‌use‌ ‌synchronization‌ ‌mechanisms‌ ‌that‌ ‌can‌ ‌inhibit‌ ‌ ‌compiler‌ ‌optimizations,‌ ‌flush‌ ‌or‌ ‌invalidate‌ ‌memory‌ ‌caches,‌ ‌and‌ ‌create‌ ‌synchro‌ ‌ ‌nization‌ ‌traffic‌ ‌on‌ ‌the‌ ‌shared‌ ‌memory‌ ‌bus.‌ ‌All‌ ‌these‌ ‌factors‌ ‌introduce‌ ‌additional‌ ‌ ‌performance‌ ‌costs;‌ ‌Chapter‌ ‌‌11‌ ‌‌covers‌ ‌techniques‌ ‌for‌ ‌analyzing‌ ‌and‌ ‌reducing‌ ‌these‌ ‌ ‌costs.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌1‌.‌4‌.‌ ‌Threads‌ ‌are‌ ‌everywhere‌ ‌‌9‌ ‌ ‌1‌.‌4‌ ‌‌Threads‌ ‌are‌ ‌everywhere‌ ‌ ‌Even‌ ‌if‌ ‌your‌ ‌program‌ ‌never‌ ‌explicitly‌ ‌creates‌ ‌a‌ ‌thread,‌ ‌frameworks‌ ‌may‌ ‌create‌ ‌ ‌threads‌ ‌on‌ ‌your‌ ‌behalf,‌ ‌and‌ ‌code‌ ‌called‌ ‌from‌ ‌these‌ ‌threads‌ ‌must‌ ‌be‌ ‌thread-safe.‌ ‌ ‌This‌ ‌can‌ ‌place‌ ‌a‌ ‌significant‌ ‌design‌ ‌and‌ ‌implementation‌ ‌burden‌ ‌on‌ ‌developers,‌ ‌ ‌since‌ ‌developing‌ ‌thread-safe‌ ‌classes‌ ‌requires‌ ‌more‌ ‌care‌ ‌and‌ ‌analysis‌ ‌than‌ ‌devel‌ ‌ ‌oping‌ ‌non-thread-safe‌ ‌classes.‌ ‌ ‌Every‌ ‌Java‌ ‌application‌ ‌uses‌ ‌threads.‌ ‌When‌ ‌the‌ ‌JVM‌ ‌starts,‌ ‌it‌ ‌creates‌ ‌threads‌ ‌ ‌for‌ ‌JVM‌ ‌housekeeping‌ ‌tasks‌ ‌(garbage‌ ‌collection,‌ ‌finalization)‌ ‌and‌ ‌a‌ ‌main‌ ‌thread‌ ‌ ‌for‌ ‌running‌ ‌the‌ ‌‌main‌ ‌‌method.‌ ‌The‌ ‌AWT‌ ‌(Abstract‌ ‌Window‌ ‌Toolkit)‌ ‌and‌ ‌Swing‌ ‌ ‌user‌ ‌interface‌ ‌frameworks‌ ‌create‌ ‌threads‌ ‌for‌ ‌managing‌ ‌user‌ ‌interface‌ ‌events.‌ ‌‌Tim‌ ‌ ‌er‌ ‌‌creates‌ ‌threads‌ ‌for‌ ‌executing‌ ‌deferred‌ ‌tasks.‌ ‌Component‌ ‌frameworks,‌ ‌such‌ ‌as‌ ‌ ‌servlets‌ ‌and‌ ‌RMI‌ ‌create‌ ‌pools‌ ‌of‌ ‌threads‌ ‌and‌ ‌invoke‌ ‌component‌ ‌methods‌ ‌in‌ ‌these‌ ‌ ‌threads.‌ ‌ ‌If‌ ‌you‌ ‌use‌ ‌these‌ ‌facilities—as‌ ‌many‌ ‌developers‌ ‌do—you‌ ‌have‌ ‌to‌ ‌be‌ ‌familiar‌ ‌ ‌with‌ ‌concurrency‌ ‌and‌ ‌thread‌ ‌safety,‌ ‌because‌ ‌these‌ ‌frameworks‌ ‌create‌ ‌threads‌ ‌and‌ ‌ ‌call‌ ‌your‌ ‌components‌ ‌from‌ ‌them.‌ ‌It‌ ‌would‌ ‌be‌ ‌nice‌ ‌to‌ ‌believe‌ ‌that‌ ‌concurrency‌ ‌ ‌is‌ ‌an‌ ‌“optional”‌ ‌or‌ ‌“advanced”‌ ‌language‌ ‌feature,‌ ‌but‌ ‌the‌ ‌reality‌ ‌is‌ ‌that‌ ‌nearly‌ ‌all‌ ‌ ‌Java‌ ‌applications‌ ‌are‌ ‌multithreaded‌ ‌and‌ ‌these‌ ‌frameworks‌ ‌do‌ ‌not‌ ‌insulate‌ ‌you‌ ‌ ‌from‌ ‌the‌ ‌need‌ ‌to‌ ‌properly‌ ‌coordinate‌ ‌access‌ ‌to‌ ‌application‌ ‌state.‌ ‌ ‌When‌ ‌concurrency‌ ‌is‌ ‌introduced‌ ‌into‌ ‌an‌ ‌application‌ ‌by‌ ‌a‌ ‌framework,‌ ‌it‌ ‌is‌ ‌ ‌usually‌ ‌impossible‌ ‌to‌ ‌restrict‌ ‌the‌ ‌concurrency-awareness‌ ‌to‌ ‌the‌ ‌framework‌ ‌code,‌ ‌ ‌because‌ ‌frameworks‌ ‌by‌ ‌their‌ ‌nature‌ ‌make‌ ‌callbacks‌ ‌to‌ ‌application‌ ‌components‌ ‌ ‌that‌ ‌in‌ ‌turn‌ ‌access‌ ‌application‌ ‌state.‌ ‌Similarly,‌ ‌the‌ ‌need‌ ‌for‌ ‌thread‌ ‌safety‌ ‌does‌ ‌not‌ ‌ ‌end‌ ‌with‌ ‌the‌ ‌components‌ ‌called‌ ‌by‌ ‌the‌ ‌framework—it‌ ‌extends‌ ‌to‌ ‌all‌ ‌code‌ ‌paths‌ ‌ ‌that‌ ‌access‌ ‌the‌ ‌program‌ ‌state‌ ‌accessed‌ ‌by‌ ‌those‌ ‌components.‌ ‌Thus,‌ ‌the‌ ‌need‌ ‌for‌ ‌ ‌thread‌ ‌safety‌ ‌is‌ ‌contagious.‌ ‌ ‌Frameworks‌ ‌introduce‌ ‌concurrency‌ ‌into‌ ‌applications‌ ‌by‌ ‌calling‌ ‌applica‌ ‌ ‌tion‌ ‌components‌ ‌from‌ ‌framework‌ ‌threads.‌ ‌Components‌ ‌invariably‌ ‌access‌ ‌ ‌application‌ ‌state,‌ ‌thus‌ ‌requiring‌ ‌that‌ ‌‌all‌ ‌‌code‌ ‌paths‌ ‌accessing‌ ‌that‌ ‌state‌ ‌ ‌be‌ ‌thread-safe.‌ ‌ ‌The‌ ‌facilities‌ ‌described‌ ‌below‌ ‌all‌ ‌cause‌ ‌application‌ ‌code‌ ‌to‌ ‌be‌ ‌called‌ ‌from‌ ‌ ‌threads‌ ‌not‌ ‌managed‌ ‌by‌ ‌the‌ ‌application.‌ ‌While‌ ‌the‌ ‌need‌ ‌for‌ ‌thread‌ ‌safety‌ ‌may‌ ‌ ‌start‌ ‌with‌ ‌these‌ ‌facilities,‌ ‌it‌ ‌rarely‌ ‌ends‌ ‌there;‌ ‌instead,‌ ‌it‌ ‌ripples‌ ‌through‌ ‌the‌ ‌ap‌ ‌ ‌plication.‌ ‌ ‌Timer.‌ ‌‌Timer‌ ‌‌is‌ ‌a‌ ‌convenience‌ ‌mechanism‌ ‌for‌ ‌scheduling‌ ‌tasks‌ ‌to‌ ‌run‌ ‌at‌ ‌a‌ ‌later‌ ‌ ‌time,‌ ‌either‌ ‌once‌ ‌or‌ ‌periodically.‌ ‌The‌ ‌introduction‌ ‌of‌ ‌a‌ ‌‌Timer‌ ‌‌can‌ ‌complicate‌ ‌ ‌an‌ ‌otherwise‌ ‌sequential‌ ‌program,‌ ‌because‌ ‌‌TimerTask‌s‌ ‌are‌ ‌executed‌ ‌in‌ ‌a‌ ‌thread‌ ‌ ‌managed‌ ‌by‌ ‌the‌ ‌‌Timer‌,‌ ‌not‌ ‌the‌ ‌application.‌ ‌If‌ ‌a‌ ‌‌TimerTask‌ ‌‌accesses‌ ‌data‌ ‌that‌ ‌is‌ ‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌I-beams,‌ ‌just‌ ‌as‌ ‌building‌ ‌concurrent‌ ‌programs‌ ‌require‌ ‌the‌ ‌correct‌ ‌use‌ ‌of‌ ‌threads‌ ‌and‌ ‌locks.‌ ‌But‌ ‌these‌ ‌are‌ ‌just‌ ‌‌mechanisms‌—means‌ ‌to‌ ‌an‌ ‌end.‌ ‌Writing‌ ‌thread-safe‌ ‌code‌ ‌is,‌ ‌at‌ ‌its‌ ‌core,‌ ‌about‌ ‌managing‌ ‌access‌ ‌to‌ ‌‌state‌,‌ ‌and‌ ‌in‌ ‌particular‌ ‌to‌ ‌‌shared,‌ ‌ ‌mutable‌ ‌state‌.‌ ‌ ‌1821604‌ ‌Informally,‌ ‌an‌ ‌object’s‌ ‌‌state‌ ‌‌is‌ ‌its‌ ‌data,‌ ‌stored‌ ‌in‌ ‌‌state‌ ‌variables‌ ‌‌such‌ ‌as‌ ‌instance‌ ‌ ‌or‌ ‌static‌ ‌fields.‌ ‌An‌ ‌object’s‌ ‌state‌ ‌may‌ ‌include‌ ‌fields‌ ‌from‌ ‌other,‌ ‌dependent‌ ‌objects;‌ ‌ ‌a‌ ‌‌HashMap‌’s‌ ‌state‌ ‌is‌ ‌partially‌ ‌stored‌ ‌in‌ ‌the‌ ‌‌HashMap‌ ‌‌object‌ ‌itself,‌ ‌but‌ ‌also‌ ‌in‌ ‌many‌ ‌ ‌Map.Entry‌ ‌‌objects.‌ ‌An‌ ‌object’s‌ ‌state‌ ‌encompasses‌ ‌any‌ ‌data‌ ‌that‌ ‌can‌ ‌affect‌ ‌its‌ ‌ ‌externally‌ ‌visible‌ ‌behavior.‌ ‌ ‌By‌ ‌‌shared‌,‌ ‌we‌ ‌mean‌ ‌that‌ ‌a‌ ‌variable‌ ‌could‌ ‌be‌ ‌accessed‌ ‌by‌ ‌multiple‌ ‌threads;‌ ‌by‌ ‌ ‌mutable‌,‌ ‌we‌ ‌mean‌ ‌that‌ ‌its‌ ‌value‌ ‌could‌ ‌change‌ ‌during‌ ‌its‌ ‌lifetime.‌ ‌We‌ ‌may‌ ‌talk‌ ‌ ‌about‌ ‌thread‌ ‌safety‌ ‌as‌ ‌if‌ ‌it‌ ‌were‌ ‌about‌ ‌‌code‌,‌ ‌but‌ ‌what‌ ‌we‌ ‌are‌ ‌really‌ ‌trying‌ ‌to‌ ‌do‌ ‌is‌ ‌ ‌protect‌ ‌‌data‌ ‌‌from‌ ‌uncontrolled‌ ‌concurrent‌ ‌access.‌ ‌ ‌Whether‌ ‌an‌ ‌object‌ ‌needs‌ ‌to‌ ‌be‌ ‌thread-safe‌ ‌depends‌ ‌on‌ ‌whether‌ ‌it‌ ‌will‌ ‌be‌ ‌ac‌ ‌ ‌cessed‌ ‌from‌ ‌multiple‌ ‌threads.‌ ‌This‌ ‌is‌ ‌a‌ ‌property‌ ‌of‌ ‌how‌ ‌the‌ ‌object‌ ‌is‌ ‌‌used‌ ‌‌in‌ ‌a‌ ‌ ‌program,‌ ‌not‌ ‌what‌ ‌it‌ ‌‌does‌.‌ ‌Making‌ ‌an‌ ‌object‌ ‌thread-safe‌ ‌requires‌ ‌using‌ ‌synchro‌ ‌ ‌nization‌ ‌to‌ ‌coordinate‌ ‌access‌ ‌to‌ ‌its‌ ‌mutable‌ ‌state;‌ ‌failing‌ ‌to‌ ‌do‌ ‌so‌ ‌could‌ ‌result‌ ‌in‌ ‌ ‌data‌ ‌corruption‌ ‌and‌ ‌other‌ ‌undesirable‌ ‌consequences.‌ ‌ ‌Whenever‌ ‌more‌ ‌than‌ ‌one‌ ‌thread‌ ‌accesses‌ ‌a‌ ‌given‌ ‌state‌ ‌variable,‌ ‌and‌ ‌one‌ ‌of‌ ‌them‌ ‌might‌ ‌ ‌write‌ ‌to‌ ‌it,‌ ‌they‌ ‌all‌ ‌must‌ ‌coordinate‌ ‌their‌ ‌access‌ ‌to‌ ‌it‌ ‌using‌ ‌synchronization.‌ ‌‌The‌ ‌primary‌ ‌ ‌mechanism‌ ‌for‌ ‌synchronization‌ ‌in‌ ‌Java‌ ‌is‌ ‌the‌ ‌‌synchronized‌ ‌‌keyword,‌ ‌which‌ ‌pro‌ ‌ ‌vides‌ ‌exclusive‌ ‌locking,‌ ‌but‌ ‌the‌ ‌term‌ ‌“synchronization”‌ ‌also‌ ‌includes‌ ‌the‌ ‌use‌ ‌of‌ ‌ ‌volatile‌ ‌‌variables,‌ ‌explicit‌ ‌locks,‌ ‌and‌ ‌atomic‌ ‌variables.‌ ‌ ‌You‌ ‌should‌ ‌avoid‌ ‌the‌ ‌temptation‌ ‌to‌ ‌think‌ ‌that‌ ‌there‌ ‌are‌ ‌“special”‌ ‌situations‌ ‌ ‌in‌ ‌which‌ ‌this‌ ‌rule‌ ‌does‌ ‌not‌ ‌apply.‌ ‌A‌ ‌program‌ ‌that‌ ‌omits‌ ‌needed‌ ‌synchronization‌ ‌ ‌might‌ ‌appear‌ ‌to‌ ‌work,‌ ‌passing‌ ‌its‌ ‌tests‌ ‌and‌ ‌performing‌ ‌well‌ ‌for‌ ‌years,‌ ‌but‌ ‌it‌ ‌is‌ ‌ ‌still‌ ‌broken‌ ‌and‌ ‌may‌ ‌fail‌ ‌at‌ ‌any‌ ‌moment.‌ ‌ ‌15‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌ ‌16‌ ‌‌Chapter‌ ‌‌2‌.‌ ‌Thread‌ ‌Safety‌ ‌ ‌If‌ ‌multiple‌ ‌threads‌ ‌access‌ ‌the‌ ‌same‌ ‌mutable‌ ‌state‌ ‌variable‌ ‌without‌ ‌appro‌ ‌ ‌priate‌ ‌synchronization,‌ ‌‌your‌ ‌program‌ ‌is‌ ‌broken‌.‌ ‌There‌ ‌are‌ ‌three‌ ‌ways‌ ‌to‌ ‌ ‌fix‌ ‌it:‌ ‌ ‌•‌ ‌‌Don’t‌ ‌share‌ ‌‌the‌ ‌state‌ ‌variable‌ ‌across‌ ‌threads;‌ ‌ ‌•‌ ‌‌Make‌ ‌the‌ ‌state‌ ‌variable‌ ‌‌immutable‌;‌ ‌or‌ ‌ ‌•‌ ‌‌Use‌ ‌‌synchronization‌ ‌‌whenever‌ ‌accessing‌ ‌the‌ ‌state‌ ‌variable.‌ ‌ ‌If‌ ‌you‌ ‌haven’t‌ ‌considered‌ ‌concurrent‌ ‌access‌ ‌in‌ ‌your‌ ‌class‌ ‌design,‌ ‌some‌ ‌of‌ ‌these‌ ‌ ‌approaches‌ ‌can‌ ‌require‌ ‌significant‌ ‌design‌ ‌modifications,‌ ‌so‌ ‌fixing‌ ‌the‌ ‌problem‌ ‌ ‌might‌ ‌not‌ ‌be‌ ‌as‌ ‌trivial‌ ‌as‌ ‌this‌ ‌advice‌ ‌makes‌ ‌it‌ ‌sound.‌ ‌‌It‌ ‌is‌ ‌far‌ ‌easier‌ ‌to‌ ‌design‌ ‌a‌ ‌class‌ ‌ ‌to‌ ‌be‌ ‌thread-safe‌ ‌than‌ ‌to‌ ‌retrofit‌ ‌it‌ ‌for‌ ‌thread‌ ‌safety‌ ‌later.‌ ‌ ‌In‌ ‌a‌ ‌large‌ ‌program,‌ ‌identifying‌ ‌whether‌ ‌multiple‌ ‌threads‌ ‌might‌ ‌access‌ ‌a‌ ‌given‌ ‌ ‌variable‌ ‌can‌ ‌be‌ ‌complicated.‌ ‌Fortunately,‌ ‌the‌ ‌same‌ ‌object-oriented‌ ‌techniques‌ ‌ ‌that‌ ‌help‌ ‌you‌ ‌write‌ ‌well-organized,‌ ‌maintainable‌ ‌classes—such‌ ‌as‌ ‌encapsulation‌ ‌ ‌and‌ ‌data‌ ‌hiding—can‌ ‌also‌ ‌help‌ ‌you‌ ‌create‌ ‌thread-safe‌ ‌classes.‌ ‌The‌ ‌less‌ ‌code‌ ‌that‌ ‌ ‌has‌ ‌access‌ ‌to‌ ‌a‌ ‌particular‌ ‌variable,‌ ‌the‌ ‌easier‌ ‌it‌ ‌is‌ ‌to‌ ‌ensure‌ ‌that‌ ‌all‌ ‌of‌ ‌it‌ ‌uses‌ ‌the‌ ‌ ‌proper‌ ‌synchronization,‌ ‌and‌ ‌the‌ ‌easier‌ ‌it‌ ‌is‌ ‌to‌ ‌reason‌ ‌about‌ ‌the‌ ‌conditions‌ ‌under‌ ‌ ‌which‌ ‌a‌ ‌given‌ ‌variable‌ ‌might‌ ‌be‌ ‌accessed.‌ ‌The‌ ‌Java‌ ‌language‌ ‌doesn’t‌ ‌force‌ ‌you‌ ‌ ‌to‌ ‌encapsulate‌ ‌state—it‌ ‌is‌ ‌perfectly‌ ‌allowable‌ ‌to‌ ‌store‌ ‌state‌ ‌in‌ ‌public‌ ‌fields‌ ‌(even‌ ‌ ‌public‌ ‌static‌ ‌fields)‌ ‌or‌ ‌publish‌ ‌a‌ ‌reference‌ ‌to‌ ‌an‌ ‌otherwise‌ ‌internal‌ ‌object—but‌ ‌the‌ ‌ ‌better‌ ‌encapsulated‌ ‌your‌ ‌program‌ ‌state,‌ ‌the‌ ‌easier‌ ‌it‌ ‌is‌ ‌to‌ ‌make‌ ‌your‌ ‌program‌ ‌ ‌thread-safe‌ ‌and‌ ‌to‌ ‌help‌ ‌maintainers‌ ‌keep‌ ‌it‌ ‌that‌ ‌way.‌ ‌ ‌When‌ ‌designing‌ ‌thread-safe‌ ‌classes,‌ ‌good‌ ‌object-oriented‌ ‌techniques—‌ ‌ ‌encapsulation,‌ ‌immutability,‌ ‌and‌ ‌clear‌ ‌specification‌ ‌of‌ ‌invariants—are‌ ‌ ‌your‌ ‌best‌ ‌friends.‌ ‌ ‌There‌ ‌will‌ ‌be‌ ‌times‌ ‌when‌ ‌good‌ ‌object-oriented‌ ‌design‌ ‌techniques‌ ‌are‌ ‌at‌ ‌odds‌ ‌ ‌with‌ ‌real-world‌ ‌requirements;‌ ‌it‌ ‌may‌ ‌be‌ ‌necessary‌ ‌in‌ ‌these‌ ‌cases‌ ‌to‌ ‌compromise‌ ‌ ‌the‌ ‌rules‌ ‌of‌ ‌good‌ ‌design‌ ‌for‌ ‌the‌ ‌sake‌ ‌of‌ ‌performance‌ ‌or‌ ‌for‌ ‌the‌ ‌sake‌ ‌of‌ ‌back‌ ‌ ‌ward‌ ‌compatibility‌ ‌with‌ ‌legacy‌ ‌code.‌ ‌Sometimes‌ ‌abstraction‌ ‌and‌ ‌encapsulation‌ ‌ ‌are‌ ‌at‌ ‌odds‌ ‌with‌ ‌performance—although‌ ‌not‌ ‌nearly‌ ‌as‌ ‌often‌ ‌as‌ ‌many‌ ‌developers‌ ‌ ‌believe—but‌ ‌it‌ ‌is‌ ‌always‌ ‌a‌ ‌good‌ ‌practice‌ ‌first‌ ‌to‌ ‌make‌ ‌your‌ ‌code‌ ‌right,‌ ‌and‌ ‌‌then‌ ‌ ‌make‌ ‌it‌ ‌fast.‌ ‌Even‌ ‌then,‌ ‌pursue‌ ‌optimization‌ ‌only‌ ‌if‌ ‌your‌ ‌performance‌ ‌measure‌ ‌ ‌ments‌ ‌and‌ ‌requirements‌ ‌tell‌ ‌you‌ ‌that‌ ‌you‌ ‌must,‌ ‌and‌ ‌if‌ ‌those‌ ‌same‌ ‌measurements‌ ‌ ‌tell‌ ‌you‌ ‌that‌ ‌your‌ ‌optimizations‌ ‌actually‌ ‌made‌ ‌a‌ ‌difference‌ ‌under‌ ‌realistic‌ ‌condi‌ ‌ ‌tions.‌1‌ ‌ ‌If‌ ‌you‌ ‌decide‌ ‌that‌ ‌you‌ ‌simply‌ ‌must‌ ‌break‌ ‌encapsulation,‌ ‌all‌ ‌is‌ ‌not‌ ‌lost.‌ ‌It‌ ‌is‌ ‌still‌ ‌ ‌possible‌ ‌to‌ ‌make‌ ‌your‌ ‌program‌ ‌thread-safe,‌ ‌it‌ ‌is‌ ‌just‌ ‌a‌ ‌lot‌ ‌harder.‌ ‌Moreover,‌ ‌the‌ ‌ ‌1‌.‌ ‌In‌ ‌concurrent‌ ‌code,‌ ‌this‌ ‌practice‌ ‌should‌ ‌be‌ ‌adhered‌ ‌to‌ ‌even‌ ‌more‌ ‌than‌ ‌usual.‌ ‌Because‌ ‌concur‌ ‌ ‌rency‌ ‌bugs‌ ‌are‌ ‌so‌ ‌difficult‌ ‌to‌ ‌reproduce‌ ‌and‌ ‌debug,‌ ‌the‌ ‌benefit‌ ‌of‌ ‌a‌ ‌small‌ ‌performance‌ ‌gain‌ ‌on‌ ‌some‌ ‌ ‌infrequently‌ ‌used‌ ‌code‌ ‌path‌ ‌may‌ ‌well‌ ‌be‌ ‌dwarfed‌ ‌by‌ ‌the‌ ‌risk‌ ‌that‌ ‌the‌ ‌program‌ ‌will‌ ‌fail‌ ‌in‌ ‌the‌ ‌field.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌2‌.‌1‌.‌ ‌What‌ ‌is‌ ‌thread‌ ‌safety?‌ ‌‌17‌ ‌ ‌thread‌ ‌safety‌ ‌of‌ ‌your‌ ‌program‌ ‌will‌ ‌be‌ ‌more‌ ‌fragile,‌ ‌increasing‌ ‌not‌ ‌only‌ ‌develop‌ ‌ ‌ment‌ ‌cost‌ ‌and‌ ‌risk‌ ‌but‌ ‌maintenance‌ ‌cost‌ ‌and‌ ‌risk‌ ‌as‌ ‌well.‌ ‌Chapter‌ ‌‌4‌ ‌‌characterizes‌ ‌ ‌the‌ ‌conditions‌ ‌under‌ ‌which‌ ‌it‌ ‌is‌ ‌safe‌ ‌to‌ ‌relax‌ ‌encapsulation‌ ‌of‌ ‌state‌ ‌variables.‌ ‌ ‌We’ve‌ ‌used‌ ‌the‌ ‌terms‌ ‌“thread-safe‌ ‌class”‌ ‌and‌ ‌“thread-safe‌ ‌program”‌ ‌nearly‌ ‌ ‌interchangeably‌ ‌thus‌ ‌far.‌ ‌Is‌ ‌a‌ ‌thread-safe‌ ‌program‌ ‌one‌ ‌that‌ ‌is‌ ‌constructed‌ ‌en‌ ‌ ‌tirely‌ ‌of‌ ‌thread-safe‌ ‌classes?‌ ‌Not‌ ‌necessarily—a‌ ‌program‌ ‌that‌ ‌consists‌ ‌entirely‌ ‌of‌ ‌ ‌thread-safe‌ ‌classes‌ ‌may‌ ‌not‌ ‌be‌ ‌thread-safe,‌ ‌and‌ ‌a‌ ‌thread-safe‌ ‌program‌ ‌may‌ ‌con‌ ‌ ‌tain‌ ‌classes‌ ‌that‌ ‌are‌ ‌not‌ ‌thread-safe.‌ ‌The‌ ‌issues‌ ‌surrounding‌ ‌the‌ ‌composition‌ ‌of‌ ‌ ‌thread-safe‌ ‌classes‌ ‌are‌ ‌also‌ ‌taken‌ ‌up‌ ‌in‌ ‌Chapter‌ ‌‌4‌.‌ ‌In‌ ‌any‌ ‌case,‌ ‌the‌ ‌concept‌ ‌of‌ ‌a‌ ‌ ‌thread-safe‌ ‌class‌ ‌makes‌ ‌sense‌ ‌only‌ ‌if‌ ‌the‌ ‌class‌ ‌encapsulates‌ ‌its‌ ‌own‌ ‌state.‌ ‌Thread‌ ‌ ‌safety‌ ‌may‌ ‌be‌ ‌a‌ ‌term‌ ‌that‌ ‌is‌ ‌applied‌ ‌to‌ ‌‌code‌,‌ ‌but‌ ‌it‌ ‌is‌ ‌about‌ ‌‌state‌,‌ ‌and‌ ‌it‌ ‌can‌ ‌only‌ ‌ ‌be‌ ‌applied‌ ‌to‌ ‌the‌ ‌entire‌ ‌body‌ ‌of‌ ‌code‌ ‌that‌ ‌encapsulates‌ ‌its‌ ‌state,‌ ‌which‌ ‌may‌ ‌be‌ ‌an‌ ‌ ‌2‌.‌2‌.‌3‌ ‌‌Compound‌ ‌actions‌ ‌ ‌Both‌ ‌‌LazyInitRace‌ ‌‌and‌ ‌‌UnsafeCountingFactorizer‌ ‌‌contained‌ ‌a‌ ‌sequence‌ ‌of‌ ‌op‌ ‌ ‌erations‌ ‌that‌ ‌needed‌ ‌to‌ ‌be‌ ‌‌atomic‌,‌ ‌or‌ ‌indivisible,‌ ‌relative‌ ‌to‌ ‌other‌ ‌operations‌ ‌on‌ ‌ ‌the‌ ‌same‌ ‌state.‌ ‌To‌ ‌avoid‌ ‌race‌ ‌conditions,‌ ‌there‌ ‌must‌ ‌be‌ ‌a‌ ‌way‌ ‌to‌ ‌prevent‌ ‌other‌ ‌ ‌threads‌ ‌from‌ ‌using‌ ‌a‌ ‌variable‌ ‌while‌ ‌we’re‌ ‌in‌ ‌the‌ ‌middle‌ ‌of‌ ‌modifying‌ ‌it,‌ ‌so‌ ‌we‌ ‌ ‌can‌ ‌ensure‌ ‌that‌ ‌other‌ ‌threads‌ ‌can‌ ‌observe‌ ‌or‌ ‌modify‌ ‌the‌ ‌state‌ ‌only‌ ‌before‌ ‌we‌ ‌start‌ ‌ ‌or‌ ‌after‌ ‌we‌ ‌finish,‌ ‌but‌ ‌not‌ ‌in‌ ‌the‌ ‌middle.‌ ‌ ‌Operations‌ ‌‌A‌ ‌‌and‌ ‌‌B‌ ‌‌are‌ ‌‌atomic‌ ‌‌with‌ ‌respect‌ ‌to‌ ‌each‌ ‌other‌ ‌if,‌ ‌from‌ ‌the‌ ‌ ‌perspective‌ ‌of‌ ‌a‌ ‌thread‌ ‌executing‌ ‌‌A‌,‌ ‌when‌ ‌another‌ ‌thread‌ ‌executes‌ ‌‌B‌,‌ ‌ ‌either‌ ‌all‌ ‌of‌ ‌‌B‌ ‌‌has‌ ‌executed‌ ‌or‌ ‌none‌ ‌of‌ ‌it‌ ‌has.‌ ‌An‌ ‌‌atomic‌ ‌operation‌ ‌‌is‌ ‌one‌ ‌ ‌that‌ ‌is‌ ‌atomic‌ ‌with‌ ‌respect‌ ‌to‌ ‌all‌ ‌operations,‌ ‌including‌ ‌itself,‌ ‌that‌ ‌operate‌ ‌ ‌on‌ ‌the‌ ‌same‌ ‌state.‌ ‌ ‌If‌ ‌the‌ ‌increment‌ ‌operation‌ ‌in‌ ‌‌UnsafeSequence‌ ‌‌were‌ ‌atomic,‌ ‌the‌ ‌race‌ ‌condition‌ ‌ ‌illustrated‌ ‌in‌ ‌Figure‌ ‌‌1‌.‌1‌ ‌‌on‌ ‌page‌ ‌‌6‌ ‌‌could‌ ‌not‌ ‌occur,‌ ‌and‌ ‌each‌ ‌execution‌ ‌of‌ ‌the‌ ‌in‌ ‌ ‌crement‌ ‌operation‌ ‌would‌ ‌have‌ ‌the‌ ‌desired‌ ‌effect‌ ‌of‌ ‌incrementing‌ ‌the‌ ‌counter‌ ‌by‌ ‌ ‌exactly‌ ‌one.‌ ‌To‌ ‌ensure‌ ‌thread‌ ‌safety,‌ ‌check-then-act‌ ‌operations‌ ‌(like‌ ‌lazy‌ ‌initializa‌ ‌ ‌tion)‌ ‌and‌ ‌read-modify-write‌ ‌operations‌ ‌(like‌ ‌increment)‌ ‌must‌ ‌always‌ ‌be‌ ‌atomic.‌ ‌ ‌We‌ ‌refer‌ ‌collectively‌ ‌to‌ ‌check-then-act‌ ‌and‌ ‌read-modify-write‌ ‌sequences‌ ‌as‌ ‌‌com‌ ‌ ‌pound‌ ‌actions‌:‌ ‌sequences‌ ‌of‌ ‌operations‌ ‌that‌ ‌must‌ ‌be‌ ‌executed‌ ‌atomically‌ ‌in‌ ‌order‌ ‌ ‌to‌ ‌remain‌ ‌thread-safe.‌ ‌In‌ ‌the‌ ‌next‌ ‌section,‌ ‌we’ll‌ ‌consider‌ ‌‌locking‌,‌ ‌Java’s‌ ‌built‌ ‌ ‌in‌ ‌mechanism‌ ‌for‌ ‌ensuring‌ ‌atomicity.‌ ‌For‌ ‌now,‌ ‌we’re‌ ‌going‌ ‌to‌ ‌fix‌ ‌the‌ ‌problem‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌2‌.‌3‌.‌ ‌Locking‌ ‌‌23‌ ‌ ‌another‌ ‌way,‌ ‌by‌ ‌using‌ ‌an‌ ‌existing‌ ‌thread-safe‌ ‌class,‌ ‌as‌ ‌shown‌ ‌in‌ ‌‌CountingFac‌ ‌ ‌torizer‌ ‌‌in‌ ‌Listing‌ ‌‌2‌.‌4‌.‌ ‌ ‌@ThreadSafe‌ ‌ ‌public‌ ‌class‌ ‌CountingFactorizer‌ ‌implements‌ ‌Servlet‌ ‌{‌ ‌ ‌private‌ ‌final‌ ‌AtomicLong‌ ‌count‌ ‌=‌ ‌new‌ ‌AtomicLong(0);‌ ‌ ‌public‌ ‌long‌ ‌getCount()‌ ‌{‌ ‌return‌ ‌count.get();‌ ‌}‌ ‌ ‌public‌ ‌void‌ ‌service(ServletRequest‌ ‌req,‌ ‌ServletResponse‌ ‌resp)‌ ‌{‌ ‌ ‌BigInteger‌ ‌i‌ ‌=‌ ‌extractFromRequest(req);‌ ‌ ‌BigInteger[]‌ ‌factors‌ ‌=‌ ‌factor(i);‌ ‌ ‌count.incrementAndGet();‌ ‌ ‌encodeIntoResponse(resp,‌ ‌factors);‌ ‌ ‌}‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌2‌.‌4‌.‌ ‌Servlet‌ ‌that‌ ‌counts‌ ‌requests‌ ‌using‌ ‌‌AtomicLong‌.‌ ‌ ‌The‌ ‌‌java.util.concurrent.atomic‌ ‌‌package‌ ‌contains‌ ‌‌atomic‌ ‌variable‌ ‌‌classes‌ ‌ ‌for‌ ‌effecting‌ ‌atomic‌ ‌state‌ ‌transitions‌ ‌on‌ ‌numbers‌ ‌and‌ ‌object‌ ‌references.‌ ‌By‌ ‌replac‌ ‌ ‌ing‌ ‌the‌ ‌‌long‌ ‌‌counter‌ ‌with‌ ‌an‌ ‌‌AtomicLong‌,‌ ‌we‌ ‌ensure‌ ‌that‌ ‌all‌ ‌actions‌ ‌that‌ ‌access‌ ‌ ‌if‌ ‌(i.equals(lastNumber))‌ ‌ ‌encodeIntoResponse(resp,‌ ‌lastFactors);‌ ‌ ‌else‌ ‌{‌ ‌ ‌BigInteger[]‌ ‌factors‌ ‌=‌ ‌factor(i);‌ ‌ ‌lastNumber‌ ‌=‌ ‌i;‌ ‌ ‌lastFactors‌ ‌=‌ ‌factors;‌ ‌ ‌encodeIntoResponse(resp,‌ ‌factors);‌ ‌ ‌}‌ ‌ ‌}‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌2‌.‌6‌.‌ ‌Servlet‌ ‌that‌ ‌caches‌ ‌last‌ ‌result,‌ ‌but‌ ‌with‌ ‌unnacceptably‌ ‌poor‌ ‌concur‌ ‌ ‌rency.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌ ‌2‌.‌3‌.‌2‌ ‌‌Reentrancy‌ ‌ ‌When‌ ‌a‌ ‌thread‌ ‌requests‌ ‌a‌ ‌lock‌ ‌that‌ ‌is‌ ‌already‌ ‌held‌ ‌by‌ ‌another‌ ‌thread,‌ ‌the‌ ‌re‌ ‌ ‌questing‌ ‌thread‌ ‌blocks.‌ ‌But‌ ‌because‌ ‌intrinsic‌ ‌locks‌ ‌are‌ ‌‌reentrant‌,‌ ‌if‌ ‌a‌ ‌thread‌ ‌tries‌ ‌ ‌to‌ ‌acquire‌ ‌a‌ ‌lock‌ ‌that‌ ‌‌it‌ ‌‌already‌ ‌holds,‌ ‌the‌ ‌request‌ ‌succeeds.‌ ‌Reentrancy‌ ‌means‌ ‌ ‌that‌ ‌locks‌ ‌are‌ ‌acquired‌ ‌on‌ ‌a‌ ‌per-thread‌ ‌rather‌ ‌than‌ ‌per-invocation‌ ‌basis.‌7‌ ‌‌Reen‌ ‌ ‌trancy‌ ‌is‌ ‌implemented‌ ‌by‌ ‌associating‌ ‌with‌ ‌each‌ ‌lock‌ ‌an‌ ‌acquisition‌ ‌count‌ ‌and‌ ‌an‌ ‌ ‌owning‌ ‌thread.‌ ‌When‌ ‌the‌ ‌count‌ ‌is‌ ‌zero,‌ ‌the‌ ‌lock‌ ‌is‌ ‌considered‌ ‌unheld.‌ ‌When‌ ‌a‌ ‌ ‌thread‌ ‌acquires‌ ‌a‌ ‌previously‌ ‌unheld‌ ‌lock,‌ ‌the‌ ‌JVM‌ ‌records‌ ‌the‌ ‌owner‌ ‌and‌ ‌sets‌ ‌the‌ ‌ ‌acquisition‌ ‌count‌ ‌to‌ ‌one.‌ ‌If‌ ‌that‌ ‌same‌ ‌thread‌ ‌acquires‌ ‌the‌ ‌lock‌ ‌again,‌ ‌the‌ ‌count‌ ‌ ‌7‌.‌ ‌This‌ ‌differs‌ ‌from‌ ‌the‌ ‌default‌ ‌locking‌ ‌behavior‌ ‌for‌ ‌pthreads‌ ‌(POSIX‌ ‌threads)‌ ‌mutexes,‌ ‌which‌ ‌are‌ ‌ ‌granted‌ ‌on‌ ‌a‌ ‌per-invocation‌ ‌basis.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌2‌.‌4‌.‌ ‌Guarding‌ ‌state‌ ‌with‌ ‌locks‌ ‌‌27‌ ‌ ‌is‌ ‌incremented,‌ ‌and‌ ‌when‌ ‌the‌ ‌owning‌ ‌thread‌ ‌exits‌ ‌the‌ ‌‌synchronized‌ ‌‌block,‌ ‌the‌ ‌ ‌count‌ ‌is‌ ‌decremented.‌ ‌When‌ ‌the‌ ‌count‌ ‌reaches‌ ‌zero,‌ ‌the‌ ‌lock‌ ‌is‌ ‌released.‌ ‌ ‌Reentrancy‌ ‌facilitates‌ ‌encapsulation‌ ‌of‌ ‌locking‌ ‌behavior,‌ ‌and‌ ‌thus‌ ‌simplifies‌ ‌ ‌the‌ ‌development‌ ‌of‌ ‌object-oriented‌ ‌concurrent‌ ‌code.‌ ‌Without‌ ‌reentrant‌ ‌locks,‌ ‌the‌ ‌ ‌very‌ ‌natural-looking‌ ‌code‌ ‌in‌ ‌Listing‌ ‌‌2‌.‌7‌,‌ ‌in‌ ‌which‌ ‌a‌ ‌subclass‌ ‌overrides‌ ‌a‌ ‌‌synch‌ ‌ ‌ronized‌ ‌‌method‌ ‌and‌ ‌then‌ ‌calls‌ ‌the‌ ‌superclass‌ ‌method,‌ ‌would‌ ‌deadlock.‌ ‌Because‌ ‌ ‌the‌ ‌‌doSomething‌ ‌‌methods‌ ‌in‌ ‌‌Widget‌ ‌‌and‌ ‌‌LoggingWidget‌ ‌‌are‌ ‌both‌ ‌‌synchronized‌,‌ ‌ ‌each‌ ‌tries‌ ‌to‌ ‌acquire‌ ‌the‌ ‌lock‌ ‌on‌ ‌the‌ ‌‌Widget‌ ‌‌before‌ ‌proceeding.‌ ‌But‌ ‌if‌ ‌intrinsic‌ ‌ ‌locks‌ ‌were‌ ‌not‌ ‌reentrant,‌ ‌the‌ ‌call‌ ‌to‌ ‌‌super.doSomething‌ ‌‌would‌ ‌never‌ ‌be‌ ‌able‌ ‌to‌ ‌ ‌acquire‌ ‌the‌ ‌lock‌ ‌because‌ ‌it‌ ‌would‌ ‌be‌ ‌considered‌ ‌already‌ ‌held,‌ ‌and‌ ‌the‌ ‌thread‌ ‌ ‌would‌ ‌permanently‌ ‌stall‌ ‌waiting‌ ‌for‌ ‌a‌ ‌lock‌ ‌it‌ ‌can‌ ‌never‌ ‌acquire.‌ ‌Reentrancy‌ ‌saves‌ ‌ ‌us‌ ‌from‌ ‌deadlock‌ ‌in‌ ‌situations‌ ‌like‌ ‌this.‌ ‌ ‌public‌ ‌class‌ ‌Widget‌ ‌{‌ ‌ ‌public‌ ‌synchronized‌ ‌void‌ ‌doSomething()‌ ‌{‌ ‌ ‌...‌ ‌ ‌}‌ ‌ ‌}‌ ‌ ‌public‌ ‌class‌ ‌LoggingWidget‌ ‌extends‌ ‌Widget‌ ‌{‌ ‌ ‌public‌ ‌synchronized‌ ‌void‌ ‌doSomething()‌ ‌{‌ ‌ ‌System.out.println(toString()‌ ‌+‌ ‌":‌ ‌calling‌ ‌doSomething");‌ ‌ ‌super.doSomething();‌ ‌ ‌}‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌2‌.‌7‌.‌ ‌Code‌ ‌that‌ ‌would‌ ‌deadlock‌ ‌if‌ ‌intrinsic‌ ‌locks‌ ‌were‌ ‌not‌ ‌reentrant.‌ ‌ ‌2‌.‌4‌ ‌‌Guarding‌ ‌state‌ ‌with‌ ‌locks‌ ‌ ‌Because‌ ‌locks‌ ‌enable‌ ‌serialized‌8‌ ‌‌access‌ ‌to‌ ‌the‌ ‌code‌ ‌paths‌ ‌they‌ ‌guard,‌ ‌we‌ ‌can‌ ‌ ‌use‌ ‌them‌ ‌to‌ ‌construct‌ ‌protocols‌ ‌for‌ ‌guaranteeing‌ ‌exclusive‌ ‌access‌ ‌to‌ ‌shared‌ ‌state.‌ ‌ ‌Following‌ ‌these‌ ‌protocols‌ ‌consistently‌ ‌can‌ ‌ensure‌ ‌state‌ ‌consistency.‌ ‌ ‌Compound‌ ‌actions‌ ‌on‌ ‌shared‌ ‌state,‌ ‌such‌ ‌as‌ ‌incrementing‌ ‌a‌ ‌hit‌ ‌counter‌ ‌(read‌ ‌ ‌modify-write)‌ ‌or‌ ‌lazy‌ ‌initialization‌ ‌(check-then-act),‌ ‌must‌ ‌be‌ ‌made‌ ‌atomic‌ ‌to‌ ‌ ‌avoid‌ ‌race‌ ‌conditions.‌ ‌Holding‌ ‌a‌ ‌lock‌ ‌for‌ ‌the‌ ‌‌entire‌ ‌duration‌ ‌‌of‌ ‌a‌ ‌compound‌ ‌action‌ ‌ ‌can‌ ‌make‌ ‌that‌ ‌compound‌ ‌action‌ ‌atomic.‌ ‌However,‌ ‌just‌ ‌wrapping‌ ‌the‌ ‌compound‌ ‌ ‌action‌ ‌with‌ ‌a‌ ‌‌synchronized‌ ‌‌block‌ ‌is‌ ‌not‌ ‌sufficient;‌ ‌if‌ ‌synchronization‌ ‌is‌ ‌used‌ ‌to‌ ‌ ‌coordinate‌ ‌access‌ ‌to‌ ‌a‌ ‌variable,‌ ‌it‌ ‌is‌ ‌needed‌ ‌‌everywhere‌ ‌that‌ ‌variable‌ ‌is‌ ‌accessed‌.‌ ‌Fur‌ ‌ ‌ther,‌ ‌when‌ ‌using‌ ‌locks‌ ‌to‌ ‌coordinate‌ ‌access‌ ‌to‌ ‌a‌ ‌variable,‌ ‌the‌ ‌‌same‌ ‌‌lock‌ ‌must‌ ‌be‌ ‌ ‌used‌ ‌wherever‌ ‌that‌ ‌variable‌ ‌is‌ ‌accessed.‌ ‌ ‌8‌.‌ ‌Serializing‌ ‌access‌ ‌to‌ ‌an‌ ‌object‌ ‌has‌ ‌nothing‌ ‌to‌ ‌do‌ ‌with‌ ‌object‌ ‌serialization‌ ‌(turning‌ ‌an‌ ‌object‌ ‌into‌ ‌a‌ ‌ ‌byte‌ ‌stream);‌ ‌serializing‌ ‌access‌ ‌means‌ ‌that‌ ‌threads‌ ‌take‌ ‌turns‌ ‌accessing‌ ‌the‌ ‌object‌ ‌exclusively,‌ ‌rather‌ ‌ ‌than‌ ‌doing‌ ‌so‌ ‌concurrently.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌28‌ ‌‌Chapter‌ ‌‌2‌.‌ ‌Thread‌ ‌Safety‌ ‌ ‌It‌ ‌is‌ ‌a‌ ‌common‌ ‌mistake‌ ‌to‌ ‌assume‌ ‌that‌ ‌synchronization‌ ‌needs‌ ‌to‌ ‌be‌ ‌used‌ ‌only‌ ‌ ‌when‌ ‌‌writing‌ ‌‌to‌ ‌shared‌ ‌variables;‌ ‌‌this‌ ‌is‌ ‌simply‌ ‌not‌ ‌true‌.‌ ‌(The‌ ‌reasons‌ ‌for‌ ‌this‌ ‌will‌ ‌ ‌become‌ ‌clearer‌ ‌in‌ ‌Section‌ ‌‌3‌.‌1‌.)‌ ‌ ‌For‌ ‌each‌ ‌mutable‌ ‌state‌ ‌variable‌ ‌that‌ ‌may‌ ‌be‌ ‌accessed‌ ‌by‌ ‌more‌ ‌than‌ ‌one‌ ‌ ‌thread,‌ ‌‌all‌ ‌‌accesses‌ ‌to‌ ‌that‌ ‌variable‌ ‌must‌ ‌be‌ ‌performed‌ ‌with‌ ‌the‌ ‌‌same‌ ‌ ‌lock‌ ‌held.‌ ‌In‌ ‌this‌ ‌case,‌ ‌we‌ ‌say‌ ‌that‌ ‌the‌ ‌variable‌ ‌is‌ ‌‌guarded‌ ‌by‌ ‌‌that‌ ‌lock.‌ ‌ ‌In‌ ‌‌SynchronizedFactorizer‌ ‌‌in‌ ‌Listing‌ ‌‌2‌.‌6‌,‌ ‌‌lastNumber‌ ‌‌and‌ ‌‌lastFactors‌ ‌‌are‌ ‌ ‌guarded‌ ‌by‌ ‌the‌ ‌servlet‌ ‌object’s‌ ‌intrinsic‌ ‌lock;‌ ‌this‌ ‌is‌ ‌documented‌ ‌by‌ ‌the‌ ‌‌@Guard‌ ‌ ‌edBy‌ ‌‌annotation.‌ ‌ ‌There‌ ‌is‌ ‌no‌ ‌inherent‌ ‌relationship‌ ‌between‌ ‌an‌ ‌object’s‌ ‌intrinsic‌ ‌lock‌ ‌and‌ ‌its‌ ‌ ‌state;‌ ‌an‌ ‌object’s‌ ‌fields‌ ‌need‌ ‌not‌ ‌be‌ ‌guarded‌ ‌by‌ ‌its‌ ‌intrinsic‌ ‌lock,‌ ‌though‌ ‌this‌ ‌is‌ ‌ ‌a‌ ‌perfectly‌ ‌valid‌ ‌locking‌ ‌convention‌ ‌that‌ ‌is‌ ‌used‌ ‌by‌ ‌many‌ ‌classes.‌ ‌Acquiring‌ ‌the‌ ‌ ‌lock‌ ‌associated‌ ‌with‌ ‌an‌ ‌object‌ ‌does‌ ‌‌not‌ ‌‌prevent‌ ‌other‌ ‌threads‌ ‌from‌ ‌accessing‌ ‌that‌ ‌ ‌object—the‌ ‌only‌ ‌thing‌ ‌that‌ ‌acquiring‌ ‌a‌ ‌lock‌ ‌prevents‌ ‌any‌ ‌other‌ ‌thread‌ ‌from‌ ‌doing‌ ‌ ‌is‌ ‌acquiring‌ ‌that‌ ‌same‌ ‌lock.‌ ‌The‌ ‌fact‌ ‌that‌ ‌every‌ ‌object‌ ‌has‌ ‌a‌ ‌built-in‌ ‌lock‌ ‌is‌ ‌just‌ ‌a‌ ‌ ‌convenience‌ ‌so‌ ‌that‌ ‌you‌ ‌needn’t‌ ‌explicitly‌ ‌create‌ ‌lock‌ ‌objects.‌9‌ ‌‌It‌ ‌is‌ ‌up‌ ‌to‌ ‌you‌ ‌to‌ ‌ ‌construct‌ ‌‌locking‌ ‌protocols‌ ‌‌or‌ ‌‌synchronization‌ ‌policies‌ ‌‌that‌ ‌let‌ ‌you‌ ‌access‌ ‌shared‌ ‌state‌ ‌ ‌safely,‌ ‌and‌ ‌to‌ ‌use‌ ‌them‌ ‌consistently‌ ‌throughout‌ ‌your‌ ‌program.‌ ‌ ‌have‌ ‌to‌ ‌wait‌ ‌until‌ ‌the‌ ‌current‌ ‌request‌ ‌is‌ ‌complete‌ ‌before‌ ‌the‌ ‌servlet‌ ‌can‌ ‌start‌ ‌on‌ ‌ ‌the‌ ‌new‌ ‌number.‌ ‌If‌ ‌the‌ ‌system‌ ‌has‌ ‌multiple‌ ‌CPUs,‌ ‌processors‌ ‌may‌ ‌remain‌ ‌idle‌ ‌ ‌even‌ ‌if‌ ‌the‌ ‌load‌ ‌is‌ ‌high.‌ ‌In‌ ‌any‌ ‌case,‌ ‌even‌ ‌short-running‌ ‌requests,‌ ‌such‌ ‌as‌ ‌those‌ ‌ ‌for‌ ‌which‌ ‌the‌ ‌value‌ ‌is‌ ‌cached,‌ ‌may‌ ‌take‌ ‌an‌ ‌unexpectedly‌ ‌long‌ ‌time‌ ‌because‌ ‌they‌ ‌ ‌must‌ ‌wait‌ ‌for‌ ‌previous‌ ‌long-running‌ ‌requests‌ ‌to‌ ‌complete.‌ ‌ ‌Figure‌ ‌‌2‌.‌1‌ ‌‌shows‌ ‌what‌ ‌happens‌ ‌when‌ ‌multiple‌ ‌requests‌ ‌arrive‌ ‌for‌ ‌the‌ ‌synchro‌ ‌ ‌nized‌ ‌factoring‌ ‌servlet:‌ ‌they‌ ‌queue‌ ‌up‌ ‌and‌ ‌are‌ ‌handled‌ ‌sequentially.‌ ‌We‌ ‌would‌ ‌ ‌describe‌ ‌this‌ ‌web‌ ‌application‌ ‌as‌ ‌exhibiting‌ ‌‌poor‌ ‌concurrency‌:‌ ‌the‌ ‌number‌ ‌of‌ ‌si‌ ‌ ‌multaneous‌ ‌invocations‌ ‌is‌ ‌limited‌ ‌not‌ ‌by‌ ‌the‌ ‌availability‌ ‌of‌ ‌processing‌ ‌resources,‌ ‌ ‌but‌ ‌by‌ ‌the‌ ‌structure‌ ‌of‌ ‌the‌ ‌application‌ ‌itself.‌ ‌Fortunately,‌ ‌it‌ ‌is‌ ‌easy‌ ‌to‌ ‌improve‌ ‌ ‌the‌ ‌concurrency‌ ‌of‌ ‌the‌ ‌servlet‌ ‌while‌ ‌maintaining‌ ‌thread‌ ‌safety‌ ‌by‌ ‌narrowing‌ ‌the‌ ‌ ‌scope‌ ‌of‌ ‌the‌ ‌‌synchronized‌ ‌‌block.‌ ‌You‌ ‌should‌ ‌be‌ ‌careful‌ ‌not‌ ‌to‌ ‌make‌ ‌the‌ ‌scope‌ ‌ ‌of‌ ‌the‌ ‌‌synchronized‌ ‌‌block‌ ‌‌too‌ ‌‌small;‌ ‌you‌ ‌would‌ ‌not‌ ‌want‌ ‌to‌ ‌divide‌ ‌an‌ ‌operation‌ ‌ ‌that‌ ‌should‌ ‌be‌ ‌atomic‌ ‌into‌ ‌more‌ ‌than‌ ‌one‌ ‌‌synchronized‌ ‌‌block.‌ ‌But‌ ‌it‌ ‌is‌ ‌reason‌ ‌ ‌able‌ ‌to‌ ‌try‌ ‌to‌ ‌exclude‌ ‌from‌ ‌‌synchronized‌ ‌‌blocks‌ ‌long-running‌ ‌operations‌ ‌that‌ ‌do‌ ‌ ‌not‌ ‌affect‌ ‌shared‌ ‌state,‌ ‌so‌ ‌that‌ ‌other‌ ‌threads‌ ‌are‌ ‌not‌ ‌prevented‌ ‌from‌ ‌accessing‌ ‌the‌ ‌ ‌shared‌ ‌state‌ ‌while‌ ‌the‌ ‌long-running‌ ‌operation‌ ‌is‌ ‌in‌ ‌progress.‌ ‌ ‌CachedFactorizer‌ ‌‌in‌ ‌Listing‌ ‌‌2‌.‌8‌ ‌‌restructures‌ ‌the‌ ‌servlet‌ ‌to‌ ‌use‌ ‌two‌ ‌separate‌ ‌ ‌synchronized‌ ‌‌blocks,‌ ‌each‌ ‌limited‌ ‌to‌ ‌a‌ ‌short‌ ‌section‌ ‌of‌ ‌code.‌ ‌One‌ ‌guards‌ ‌the‌ ‌ ‌check-then-act‌ ‌sequence‌ ‌that‌ ‌tests‌ ‌whether‌ ‌we‌ ‌can‌ ‌just‌ ‌return‌ ‌the‌ ‌cached‌ ‌result,‌ ‌ ‌and‌ ‌the‌ ‌other‌ ‌guards‌ ‌updating‌ ‌both‌ ‌the‌ ‌cached‌ ‌number‌ ‌and‌ ‌the‌ ‌cached‌ ‌factors.‌ ‌ ‌As‌ ‌a‌ ‌bonus,‌ ‌we’ve‌ ‌reintroduced‌ ‌the‌ ‌hit‌ ‌counter‌ ‌and‌ ‌added‌ ‌a‌ ‌“cache‌ ‌hit”‌ ‌counter‌ ‌ ‌as‌ ‌well,‌ ‌updating‌ ‌them‌ ‌within‌ ‌the‌ ‌initial‌ ‌‌synchronized‌ ‌‌block.‌ ‌Because‌ ‌these‌ ‌ ‌counters‌ ‌constitute‌ ‌shared‌ ‌mutable‌ ‌state‌ ‌as‌ ‌well,‌ ‌we‌ ‌must‌ ‌use‌ ‌synchronization‌ ‌ ‌everywhere‌ ‌they‌ ‌are‌ ‌accessed.‌ ‌The‌ ‌portions‌ ‌of‌ ‌code‌ ‌that‌ ‌are‌ ‌outside‌ ‌the‌ ‌‌synch‌ ‌ ‌ronized‌ ‌‌blocks‌ ‌operate‌ ‌exclusively‌ ‌on‌ ‌local‌ ‌(stack-based)‌ ‌variables,‌ ‌which‌ ‌are‌ ‌not‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌2‌.‌5‌.‌ ‌Liveness‌ ‌and‌ ‌performance‌ ‌‌31‌ ‌ ‌shared‌ ‌across‌ ‌threads‌ ‌and‌ ‌therefore‌ ‌do‌ ‌not‌ ‌require‌ ‌synchronization.‌ ‌ ‌@ThreadSafe‌ ‌ ‌public‌ ‌class‌ ‌CachedFactorizer‌ ‌implements‌ ‌Servlet‌ ‌{‌ ‌ ‌@GuardedBy("this")‌ ‌private‌ ‌BigInteger‌ ‌lastNumber;‌ ‌ ‌@GuardedBy("this")‌ ‌private‌ ‌BigInteger[]‌ ‌lastFactors;‌ ‌ ‌@GuardedBy("this")‌ ‌private‌ ‌long‌ ‌hits;‌ ‌ ‌@GuardedBy("this")‌ ‌private‌ ‌long‌ ‌cacheHits;‌ ‌ ‌public‌ ‌synchronized‌ ‌long‌ ‌getHits()‌ ‌{‌ ‌return‌ ‌hits;‌ ‌}‌ ‌ ‌public‌ ‌synchronized‌ ‌double‌ ‌getCacheHitRatio()‌ ‌{‌ ‌ ‌return‌ ‌(double)‌ ‌cacheHits‌ ‌/‌ ‌(double)‌ ‌hits;‌ ‌ ‌}‌ ‌ ‌public‌ ‌void‌ ‌service(ServletRequest‌ ‌req,‌ ‌ServletResponse‌ ‌resp)‌ ‌{‌ ‌ ‌BigInteger‌ ‌i‌ ‌=‌ ‌extractFromRequest(req);‌ ‌ ‌BigInteger[]‌ ‌factors‌ ‌=‌ ‌null;‌ ‌ ‌synchronized‌ ‌(this)‌ ‌{‌ ‌ ‌++hits;‌ ‌ ‌if‌ ‌(i.equals(lastNumber))‌ ‌{‌ ‌ ‌++cacheHits;‌ ‌ ‌factors‌ ‌=‌ ‌lastFactors.clone();‌ ‌ ‌}‌ ‌ ‌}‌ ‌ ‌if‌ ‌(factors‌ ‌==‌ ‌null)‌ ‌{‌ ‌ ‌factors‌ ‌=‌ ‌factor(i);‌ ‌ ‌synchronized‌ ‌(this)‌ ‌{‌ ‌ ‌lastNumber‌ ‌=‌ ‌i;‌ ‌ ‌lastFactors‌ ‌=‌ ‌factors.clone();‌ ‌ ‌}‌ ‌ ‌}‌ ‌ ‌encodeIntoResponse(resp,‌ ‌factors);‌ ‌ ‌}‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌2‌.‌8‌.‌ ‌Servlet‌ ‌that‌ ‌caches‌ ‌its‌ ‌last‌ ‌request‌ ‌and‌ ‌result.‌ ‌ ‌CachedFactorizer‌ ‌‌no‌ ‌longer‌ ‌uses‌ ‌‌AtomicLong‌ ‌‌for‌ ‌the‌ ‌hit‌ ‌counter,‌ ‌instead‌ ‌re‌ ‌ ‌verting‌ ‌to‌ ‌using‌ ‌a‌ ‌‌long‌ ‌‌field.‌ ‌It‌ ‌would‌ ‌be‌ ‌safe‌ ‌to‌ ‌use‌ ‌‌AtomicLong‌ ‌‌here,‌ ‌but‌ ‌there‌ ‌is‌ ‌ ‌less‌ ‌benefit‌ ‌than‌ ‌there‌ ‌was‌ ‌in‌ ‌‌CountingFactorizer‌.‌ ‌Atomic‌ ‌variables‌ ‌are‌ ‌useful‌ ‌ ‌for‌ ‌effecting‌ ‌atomic‌ ‌operations‌ ‌on‌ ‌a‌ ‌single‌ ‌variable,‌ ‌but‌ ‌since‌ ‌we‌ ‌are‌ ‌already‌ ‌using‌ ‌ ‌synchronized‌ ‌‌blocks‌ ‌to‌ ‌construct‌ ‌atomic‌ ‌operations,‌ ‌using‌ ‌two‌ ‌different‌ ‌synchro‌ ‌ ‌nization‌ ‌mechanisms‌ ‌would‌ ‌be‌ ‌confusing‌ ‌and‌ ‌would‌ ‌offer‌ ‌no‌ ‌performance‌ ‌or‌ ‌ ‌safety‌ ‌benefit.‌ ‌ ‌The‌ ‌restructuring‌ ‌of‌ ‌‌CachedFactorizer‌ ‌‌provides‌ ‌a‌ ‌balance‌ ‌between‌ ‌simplic‌ ‌ ‌ity‌ ‌(synchronizing‌ ‌the‌ ‌entire‌ ‌method)‌ ‌and‌ ‌concurrency‌ ‌(synchronizing‌ ‌the‌ ‌short‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌32‌ ‌‌Chapter‌ ‌‌2‌.‌ ‌Thread‌ ‌Safety‌ ‌ ‌est‌ ‌possible‌ ‌code‌ ‌paths).‌ ‌Acquiring‌ ‌and‌ ‌releasing‌ ‌a‌ ‌lock‌ ‌has‌ ‌some‌ ‌overhead,‌ ‌so‌ ‌ ‌it‌ ‌is‌ ‌undesirable‌ ‌to‌ ‌break‌ ‌down‌ ‌‌synchronized‌ ‌‌blocks‌ ‌‌too‌ ‌‌far‌ ‌(such‌ ‌as‌ ‌factoring‌ ‌ ‌++hits‌ ‌‌into‌ ‌its‌ ‌own‌ ‌‌synchronized‌ ‌‌block),‌ ‌even‌ ‌if‌ ‌this‌ ‌would‌ ‌not‌ ‌compromise‌ ‌ ‌atomicity.‌ ‌‌CachedFactorizer‌ ‌‌holds‌ ‌the‌ ‌lock‌ ‌when‌ ‌accessing‌ ‌state‌ ‌variables‌ ‌and‌ ‌ ‌for‌ ‌the‌ ‌duration‌ ‌of‌ ‌compound‌ ‌actions,‌ ‌but‌ ‌releases‌ ‌it‌ ‌before‌ ‌executing‌ ‌the‌ ‌poten‌ ‌ ‌tially‌ ‌long-running‌ ‌factorization‌ ‌operation.‌ ‌This‌ ‌preserves‌ ‌thread‌ ‌safety‌ ‌without‌ ‌ ‌unduly‌ ‌affecting‌ ‌concurrency;‌ ‌the‌ ‌code‌ ‌paths‌ ‌in‌ ‌each‌ ‌of‌ ‌the‌ ‌‌synchronized‌ ‌‌blocks‌ ‌ ‌are‌ ‌“short‌ ‌enough”.‌ ‌ ‌Deciding‌ ‌how‌ ‌big‌ ‌or‌ ‌small‌ ‌to‌ ‌make‌ ‌‌synchronized‌ ‌‌blocks‌ ‌may‌ ‌require‌ ‌tradeoffs‌ ‌ ‌among‌ ‌competing‌ ‌design‌ ‌forces,‌ ‌including‌ ‌safety‌ ‌(which‌ ‌must‌ ‌not‌ ‌be‌ ‌compro‌ ‌ ‌mised),‌ ‌simplicity,‌ ‌and‌ ‌performance.‌ ‌Sometimes‌ ‌simplicity‌ ‌and‌ ‌performance‌ ‌are‌ ‌ ‌at‌ ‌odds‌ ‌with‌ ‌each‌ ‌other,‌ ‌although‌ ‌as‌ ‌‌CachedFactorizer‌ ‌‌illustrates,‌ ‌a‌ ‌reasonable‌ ‌ ‌balance‌ ‌can‌ ‌usually‌ ‌be‌ ‌found.‌ ‌ ‌There‌ ‌is‌ ‌frequently‌ ‌a‌ ‌tension‌ ‌between‌ ‌simplicity‌ ‌and‌ ‌performance.‌ ‌When‌ ‌ ‌implementing‌ ‌a‌ ‌synchronization‌ ‌policy,‌ ‌resist‌ ‌the‌ ‌temptation‌ ‌to‌ ‌prema‌ ‌ ‌turely‌ ‌sacrifice‌ ‌simplicity‌ ‌(potentially‌ ‌compromising‌ ‌safety)‌ ‌for‌ ‌the‌ ‌sake‌ ‌ ‌of‌ ‌performance.‌ ‌ ‌Whenever‌ ‌you‌ ‌use‌ ‌locking,‌ ‌you‌ ‌should‌ ‌be‌ ‌aware‌ ‌of‌ ‌what‌ ‌the‌ ‌code‌ ‌in‌ ‌the‌ ‌block‌ ‌ ‌is‌ ‌doing‌ ‌and‌ ‌how‌ ‌likely‌ ‌it‌ ‌is‌ ‌to‌ ‌take‌ ‌a‌ ‌long‌ ‌time‌ ‌to‌ ‌execute.‌ ‌Holding‌ ‌a‌ ‌lock‌ ‌for‌ ‌a‌ ‌ ‌long‌ ‌time,‌ ‌either‌ ‌because‌ ‌you‌ ‌are‌ ‌doing‌ ‌something‌ ‌compute-intensive‌ ‌or‌ ‌because‌ ‌ ‌you‌ ‌execute‌ ‌a‌ ‌potentially‌ ‌blocking‌ ‌operation,‌ ‌introduces‌ ‌the‌ ‌risk‌ ‌of‌ ‌liveness‌ ‌or‌ ‌ ‌number‌ ‌‌and‌ ‌then‌ ‌to‌ ‌‌ready‌ ‌‌without‌ ‌synchronization,‌ ‌the‌ ‌reader‌ ‌thread‌ ‌could‌ ‌see‌ ‌ ‌those‌ ‌writes‌ ‌happen‌ ‌in‌ ‌the‌ ‌opposite‌ ‌order—or‌ ‌not‌ ‌at‌ ‌all.‌ ‌ ‌1‌.‌ ‌This‌ ‌may‌ ‌seem‌ ‌like‌ ‌a‌ ‌broken‌ ‌design,‌ ‌but‌ ‌it‌ ‌is‌ ‌meant‌ ‌to‌ ‌allow‌ ‌JVMs‌ ‌to‌ ‌take‌ ‌full‌ ‌advantage‌ ‌of‌ ‌the‌ ‌ ‌performance‌ ‌of‌ ‌modern‌ ‌multiprocessor‌ ‌hardware.‌ ‌For‌ ‌example,‌ ‌in‌ ‌the‌ ‌absence‌ ‌of‌ ‌synchronization,‌ ‌ ‌the‌ ‌Java‌ ‌Memory‌ ‌Model‌ ‌permits‌ ‌the‌ ‌compiler‌ ‌to‌ ‌reorder‌ ‌operations‌ ‌and‌ ‌cache‌ ‌values‌ ‌in‌ ‌registers,‌ ‌and‌ ‌ ‌permits‌ ‌CPUs‌ ‌to‌ ‌reorder‌ ‌operations‌ ‌and‌ ‌cache‌ ‌values‌ ‌in‌ ‌processor-specific‌ ‌caches.‌ ‌For‌ ‌more‌ ‌details,‌ ‌ ‌see‌ ‌Chapter‌ ‌‌16‌.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌3‌.‌1‌.‌ ‌Visibility‌ ‌‌35‌ ‌ ‌In‌ ‌the‌ ‌absence‌ ‌of‌ ‌synchronization,‌ ‌the‌ ‌compiler,‌ ‌processor,‌ ‌and‌ ‌runtime‌ ‌ ‌can‌ ‌do‌ ‌some‌ ‌downright‌ ‌weird‌ ‌things‌ ‌to‌ ‌the‌ ‌order‌ ‌in‌ ‌which‌ ‌operations‌ ‌ap‌ ‌ ‌pear‌ ‌to‌ ‌execute.‌ ‌Attempts‌ ‌to‌ ‌reason‌ ‌about‌ ‌the‌ ‌order‌ ‌in‌ ‌which‌ ‌memory‌ ‌ ‌actions‌ ‌“must”‌ ‌happen‌ ‌in‌ ‌insufficiently‌ ‌synchronized‌ ‌multithreaded‌ ‌pro‌ ‌ ‌grams‌ ‌will‌ ‌almost‌ ‌certainly‌ ‌be‌ ‌incorrect.‌ ‌ ‌NoVisibility‌ ‌‌is‌ ‌about‌ ‌as‌ ‌simple‌ ‌as‌ ‌a‌ ‌concurrent‌ ‌program‌ ‌can‌ ‌get—two‌ ‌ ‌threads‌ ‌and‌ ‌two‌ ‌shared‌ ‌variables—and‌ ‌yet‌ ‌it‌ ‌is‌ ‌still‌ ‌all‌ ‌too‌ ‌easy‌ ‌to‌ ‌come‌ ‌to‌ ‌the‌ ‌ ‌wrong‌ ‌conclusions‌ ‌about‌ ‌what‌ ‌it‌ ‌does‌ ‌or‌ ‌even‌ ‌whether‌ ‌it‌ ‌will‌ ‌terminate.‌ ‌Reason‌ ‌ ‌Licensed‌ ‌by‌ ‌ ‌ing‌ ‌about‌ ‌insufficiently‌ ‌synchronized‌ ‌concurrent‌ ‌programs‌ ‌is‌ ‌prohibitively‌ ‌diffi‌ ‌ ‌cult.‌ ‌ ‌This‌ ‌may‌ ‌all‌ ‌sound‌ ‌a‌ ‌little‌ ‌scary,‌ ‌and‌ ‌it‌ ‌should.‌ ‌Fortunately,‌ ‌there’s‌ ‌an‌ ‌easy‌ ‌ ‌way‌ ‌to‌ ‌avoid‌ ‌these‌ ‌complex‌ ‌issues:‌ ‌‌always‌ ‌use‌ ‌the‌ ‌proper‌ ‌synchronization‌ ‌whenever‌ ‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌data‌ ‌is‌ ‌shared‌ ‌across‌ ‌threads.‌ ‌ ‌3‌.‌1‌.‌1‌ ‌‌Stale‌ ‌data‌ ‌ ‌1821604‌ ‌NoVisibility‌ ‌‌demonstrated‌ ‌one‌ ‌of‌ ‌the‌ ‌ways‌ ‌that‌ ‌insufficiently‌ ‌synchronized‌ ‌pro‌ ‌ ‌grams‌ ‌can‌ ‌cause‌ ‌surprising‌ ‌results:‌ ‌‌stale‌ ‌data‌.‌ ‌When‌ ‌the‌ ‌reader‌ ‌thread‌ ‌examines‌ ‌ ‌ready‌,‌ ‌it‌ ‌may‌ ‌see‌ ‌an‌ ‌out-of-date‌ ‌value.‌ ‌Unless‌ ‌synchronization‌ ‌is‌ ‌used‌ ‌‌every‌ ‌time‌ ‌ ‌a‌ ‌variable‌ ‌is‌ ‌accessed‌,‌ ‌it‌ ‌is‌ ‌possible‌ ‌to‌ ‌see‌ ‌a‌ ‌stale‌ ‌value‌ ‌for‌ ‌that‌ ‌variable.‌ ‌Worse,‌ ‌stal‌ ‌ ‌eness‌ ‌is‌ ‌not‌ ‌all-or-nothing:‌ ‌a‌ ‌thread‌ ‌can‌ ‌see‌ ‌an‌ ‌up-to-date‌ ‌value‌ ‌of‌ ‌one‌ ‌variable‌ ‌ ‌but‌ ‌a‌ ‌stale‌ ‌value‌ ‌of‌ ‌another‌ ‌variable‌ ‌that‌ ‌was‌ ‌written‌ ‌first.‌ ‌ ‌When‌ ‌food‌ ‌is‌ ‌stale,‌ ‌it‌ ‌is‌ ‌usually‌ ‌still‌ ‌edible—just‌ ‌less‌ ‌enjoyable.‌ ‌But‌ ‌stale‌ ‌data‌ ‌ ‌can‌ ‌be‌ ‌more‌ ‌dangerous.‌ ‌While‌ ‌an‌ ‌out-of-date‌ ‌hit‌ ‌counter‌ ‌in‌ ‌a‌ ‌web‌ ‌application‌ ‌ ‌3‌.‌1‌.‌4‌).‌ ‌The‌ ‌Java‌ ‌Memory‌ ‌Model‌ ‌requires‌ ‌fetch‌ ‌and‌ ‌store‌ ‌operations‌ ‌to‌ ‌be‌ ‌atomic,‌ ‌ ‌but‌ ‌for‌ ‌nonvolatile‌ ‌‌long‌ ‌‌and‌ ‌‌double‌ ‌‌variables,‌ ‌the‌ ‌JVM‌ ‌is‌ ‌permitted‌ ‌to‌ ‌treat‌ ‌a‌ ‌ ‌64‌-bit‌ ‌read‌ ‌or‌ ‌write‌ ‌as‌ ‌two‌ ‌separate‌ ‌‌32‌-bit‌ ‌operations.‌ ‌If‌ ‌the‌ ‌reads‌ ‌and‌ ‌writes‌ ‌ ‌occur‌ ‌in‌ ‌different‌ ‌threads,‌ ‌it‌ ‌is‌ ‌therefore‌ ‌possible‌ ‌to‌ ‌read‌ ‌a‌ ‌nonvolatile‌ ‌‌long‌ ‌‌and‌ ‌ ‌get‌ ‌back‌ ‌the‌ ‌high‌ ‌‌32‌ ‌‌bits‌ ‌of‌ ‌one‌ ‌value‌ ‌and‌ ‌the‌ ‌low‌ ‌‌32‌ ‌‌bits‌ ‌of‌ ‌another.‌3‌ ‌‌Thus,‌ ‌even‌ ‌ ‌if‌ ‌you‌ ‌don’t‌ ‌care‌ ‌about‌ ‌stale‌ ‌values,‌ ‌it‌ ‌is‌ ‌not‌ ‌safe‌ ‌to‌ ‌use‌ ‌shared‌ ‌mutable‌ ‌‌long‌ ‌‌and‌ ‌ ‌double‌ ‌‌variables‌ ‌in‌ ‌multithreaded‌ ‌programs‌ ‌unless‌ ‌they‌ ‌are‌ ‌declared‌ ‌‌volatile‌ ‌ ‌or‌ ‌guarded‌ ‌by‌ ‌a‌ ‌lock.‌ ‌ ‌3‌.‌1‌.‌3‌ ‌‌Locking‌ ‌and‌ ‌visibility‌ ‌ ‌Intrinsic‌ ‌locking‌ ‌can‌ ‌be‌ ‌used‌ ‌to‌ ‌guarantee‌ ‌that‌ ‌one‌ ‌thread‌ ‌sees‌ ‌the‌ ‌effects‌ ‌of‌ ‌an‌ ‌ ‌other‌ ‌in‌ ‌a‌ ‌predictable‌ ‌manner,‌ ‌as‌ ‌illustrated‌ ‌by‌ ‌Figure‌ ‌‌3‌.‌1‌.‌ ‌When‌ ‌thread‌ ‌‌A‌ ‌‌exe‌ ‌ ‌cutes‌ ‌a‌ ‌‌synchronized‌ ‌‌block,‌ ‌and‌ ‌subsequently‌ ‌thread‌ ‌‌B‌ ‌‌enters‌ ‌a‌ ‌‌synchronized‌ ‌ ‌block‌ ‌guarded‌ ‌by‌ ‌the‌ ‌same‌ ‌lock,‌ ‌the‌ ‌values‌ ‌of‌ ‌variables‌ ‌that‌ ‌were‌ ‌visible‌ ‌to‌ ‌‌A‌ ‌ ‌prior‌ ‌to‌ ‌releasing‌ ‌the‌ ‌lock‌ ‌are‌ ‌guaranteed‌ ‌to‌ ‌be‌ ‌visible‌ ‌to‌ ‌‌B‌ ‌‌upon‌ ‌acquiring‌ ‌the‌ ‌ ‌3‌.‌ ‌When‌ ‌the‌ ‌Java‌ ‌Virtual‌ ‌Machine‌ ‌Specification‌ ‌was‌ ‌written,‌ ‌many‌ ‌widely‌ ‌used‌ ‌processor‌ ‌architec‌ ‌ ‌tures‌ ‌could‌ ‌not‌ ‌efficiently‌ ‌provide‌ ‌atomic‌ ‌‌64‌-bit‌ ‌arithmetic‌ ‌operations.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌3‌.‌1‌.‌ ‌Visibility‌ ‌‌37‌ ‌‌Thread‌ ‌A‌ ‌ ‌y‌ ‌=‌ ‌1‌ ‌ ‌lock‌ ‌M‌ ‌ ‌x‌ ‌=‌ ‌1‌ ‌ ‌unlock‌ ‌M‌ ‌ ‌Everything‌ ‌ ‌before‌ ‌the‌ ‌ ‌unlock‌ ‌on‌ ‌M...‌ ‌ ‌...‌ ‌is‌ ‌visible‌ ‌to‌ ‌ ‌everything‌ ‌ ‌after‌ ‌the‌ ‌ ‌lock‌ ‌on‌ ‌M‌ ‌ ‌Thread‌ ‌B‌ ‌ ‌lock‌ ‌M‌ ‌ ‌i‌ ‌=‌ ‌x‌ ‌ ‌unlock‌ ‌M‌ ‌j‌ ‌=‌ ‌y‌ ‌ ‌F‌igure‌ ‌3‌.‌1‌.‌ ‌Visibility‌ ‌guarantees‌ ‌for‌ ‌synchronization.‌ ‌ ‌lock.‌ ‌In‌ ‌other‌ ‌words,‌ ‌everything‌ ‌‌A‌ ‌‌did‌ ‌in‌ ‌or‌ ‌prior‌ ‌to‌ ‌a‌ ‌‌synchronized‌ ‌‌block‌ ‌is‌ ‌ ‌visible‌ ‌to‌ ‌‌B‌ ‌‌when‌ ‌it‌ ‌executes‌ ‌a‌ ‌‌synchronized‌ ‌‌block‌ ‌guarded‌ ‌by‌ ‌the‌ ‌same‌ ‌lock.‌ ‌ ‌Without‌ ‌synchronization,‌ ‌there‌ ‌is‌ ‌no‌ ‌such‌ ‌guarantee.‌ ‌ ‌We‌ ‌can‌ ‌now‌ ‌give‌ ‌the‌ ‌other‌ ‌reason‌ ‌for‌ ‌the‌ ‌rule‌ ‌requiring‌ ‌all‌ ‌threads‌ ‌to‌ ‌synchro‌ ‌ ‌nize‌ ‌on‌ ‌the‌ ‌‌same‌ ‌‌lock‌ ‌when‌ ‌accessing‌ ‌a‌ ‌shared‌ ‌mutable‌ ‌variable—to‌ ‌guarantee‌ ‌ ‌that‌ ‌values‌ ‌written‌ ‌by‌ ‌one‌ ‌thread‌ ‌are‌ ‌made‌ ‌visible‌ ‌to‌ ‌other‌ ‌threads.‌ ‌Otherwise,‌ ‌ ‌if‌ ‌a‌ ‌thread‌ ‌reads‌ ‌a‌ ‌variable‌ ‌without‌ ‌holding‌ ‌the‌ ‌appropriate‌ ‌lock,‌ ‌it‌ ‌might‌ ‌see‌ ‌a‌ ‌ ‌stale‌ ‌value.‌ ‌ ‌Locking‌ ‌is‌ ‌not‌ ‌just‌ ‌about‌ ‌mutual‌ ‌exclusion;‌ ‌it‌ ‌is‌ ‌also‌ ‌about‌ ‌memory‌ ‌visi‌ ‌ ‌bility.‌ ‌To‌ ‌ensure‌ ‌that‌ ‌all‌ ‌threads‌ ‌see‌ ‌the‌ ‌most‌ ‌up-to-date‌ ‌values‌ ‌of‌ ‌shared‌ ‌ ‌mutable‌ ‌variables,‌ ‌the‌ ‌reading‌ ‌and‌ ‌writing‌ ‌threads‌ ‌must‌ ‌synchronize‌ ‌on‌ ‌ ‌a‌ ‌common‌ ‌lock.‌ ‌ ‌3‌.‌1‌.‌4‌ ‌‌Volatile‌ ‌variables‌ ‌ ‌The‌ ‌Java‌ ‌language‌ ‌also‌ ‌provides‌ ‌an‌ ‌alternative,‌ ‌weaker‌ ‌form‌ ‌of‌ ‌synchronization,‌ ‌ ‌volatile‌ ‌variables‌,‌ ‌to‌ ‌ensure‌ ‌that‌ ‌updates‌ ‌to‌ ‌a‌ ‌variable‌ ‌are‌ ‌propagated‌ ‌predictably‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌38‌ ‌‌Chapter‌ ‌‌3‌.‌ ‌Sharing‌ ‌Objects‌ ‌ ‌to‌ ‌other‌ ‌threads.‌ ‌When‌ ‌a‌ ‌field‌ ‌is‌ ‌declared‌ ‌‌volatile‌,‌ ‌the‌ ‌compiler‌ ‌and‌ ‌runtime‌ ‌ ‌are‌ ‌put‌ ‌on‌ ‌notice‌ ‌that‌ ‌this‌ ‌variable‌ ‌is‌ ‌shared‌ ‌and‌ ‌that‌ ‌operations‌ ‌on‌ ‌it‌ ‌should‌ ‌not‌ ‌ ‌be‌ ‌reordered‌ ‌with‌ ‌other‌ ‌memory‌ ‌operations.‌ ‌Volatile‌ ‌variables‌ ‌are‌ ‌not‌ ‌cached‌ ‌in‌ ‌ ‌registers‌ ‌or‌ ‌in‌ ‌caches‌ ‌where‌ ‌they‌ ‌are‌ ‌hidden‌ ‌from‌ ‌other‌ ‌processors,‌ ‌so‌ ‌a‌ ‌read‌ ‌of‌ ‌a‌ ‌ ‌volatile‌ ‌variable‌ ‌always‌ ‌returns‌ ‌the‌ ‌most‌ ‌recent‌ ‌write‌ ‌by‌ ‌any‌ ‌thread.‌ ‌ ‌A‌ ‌good‌ ‌way‌ ‌to‌ ‌think‌ ‌about‌ ‌volatile‌ ‌variables‌ ‌is‌ ‌to‌ ‌imagine‌ ‌that‌ ‌they‌ ‌be‌ ‌ ‌have‌ ‌roughly‌ ‌like‌ ‌the‌ ‌‌SynchronizedInteger‌ ‌‌class‌ ‌in‌ ‌Listing‌ ‌‌3‌.‌3‌,‌ ‌replacing‌ ‌reads‌ ‌ ‌and‌ ‌writes‌ ‌of‌ ‌the‌ ‌volatile‌ ‌variable‌ ‌with‌ ‌calls‌ ‌to‌ ‌‌get‌ ‌‌and‌ ‌‌set‌.‌4‌ ‌‌Yet‌ ‌accessing‌ ‌a‌ ‌ ‌volatile‌ ‌variable‌ ‌performs‌ ‌no‌ ‌locking‌ ‌and‌ ‌so‌ ‌cannot‌ ‌cause‌ ‌the‌ ‌executing‌ ‌thread‌ ‌ ‌to‌ ‌block,‌ ‌making‌ ‌volatile‌ ‌variables‌ ‌a‌ ‌lighter-weight‌ ‌synchronization‌ ‌mechanism‌ ‌ ‌than‌ ‌‌synchronized‌.‌5‌ ‌ ‌The‌ ‌visibility‌ ‌effects‌ ‌of‌ ‌volatile‌ ‌variables‌ ‌extend‌ ‌beyond‌ ‌the‌ ‌value‌ ‌of‌ ‌the‌ ‌ ‌volatile‌ ‌variable‌ ‌itself.‌ ‌When‌ ‌thread‌ ‌‌A‌ ‌‌writes‌ ‌to‌ ‌a‌ ‌volatile‌ ‌variable‌ ‌and‌ ‌subse‌ ‌ ‌quently‌ ‌thread‌ ‌‌B‌ ‌‌reads‌ ‌that‌ ‌same‌ ‌variable,‌ ‌the‌ ‌values‌ ‌of‌ ‌‌all‌ ‌‌variables‌ ‌that‌ ‌were‌ ‌ ‌visible‌ ‌to‌ ‌‌A‌ ‌‌prior‌ ‌to‌ ‌writing‌ ‌to‌ ‌the‌ ‌volatile‌ ‌variable‌ ‌become‌ ‌visible‌ ‌to‌ ‌‌B‌ ‌‌after‌ ‌ ‌reading‌ ‌the‌ ‌volatile‌ ‌variable.‌ ‌So‌ ‌from‌ ‌a‌ ‌memory‌ ‌visibility‌ ‌perspective,‌ ‌writing‌ ‌ ‌a‌ ‌volatile‌ ‌variable‌ ‌is‌ ‌like‌ ‌exiting‌ ‌a‌ ‌‌synchronized‌ ‌‌block‌ ‌and‌ ‌reading‌ ‌a‌ ‌volatile‌ ‌ ‌variable‌ ‌is‌ ‌like‌ ‌entering‌ ‌a‌ ‌‌synchronized‌ ‌‌block.‌ ‌However,‌ ‌we‌ ‌do‌ ‌not‌ ‌recommend‌ ‌ ‌relying‌ ‌too‌ ‌heavily‌ ‌on‌ ‌volatile‌ ‌variables‌ ‌for‌ ‌visibility;‌ ‌code‌ ‌that‌ ‌relies‌ ‌on‌ ‌volatile‌ ‌ ‌variables‌ ‌for‌ ‌visibility‌ ‌of‌ ‌arbitrary‌ ‌state‌ ‌is‌ ‌more‌ ‌fragile‌ ‌and‌ ‌harder‌ ‌to‌ ‌understand‌ ‌ ‌than‌ ‌code‌ ‌that‌ ‌uses‌ ‌locking.‌ ‌ ‌Use‌ ‌volatile‌ ‌variables‌ ‌only‌ ‌when‌ ‌they‌ ‌simplify‌ ‌implementing‌ ‌and‌ ‌veri‌ ‌ ‌fying‌ ‌your‌ ‌synchronization‌ ‌policy;‌ ‌avoid‌ ‌using‌ ‌volatile‌ ‌variables‌ ‌when‌ ‌ ‌veryfing‌ ‌correctness‌ ‌would‌ ‌require‌ ‌subtle‌ ‌reasoning‌ ‌about‌ ‌visibility.‌ ‌Good‌ ‌ ‌uses‌ ‌of‌ ‌volatile‌ ‌variables‌ ‌include‌ ‌ensuring‌ ‌the‌ ‌visibility‌ ‌of‌ ‌their‌ ‌own‌ ‌ ‌state,‌ ‌that‌ ‌of‌ ‌the‌ ‌object‌ ‌they‌ ‌refer‌ ‌to,‌ ‌or‌ ‌indicating‌ ‌that‌ ‌an‌ ‌important‌ ‌life‌ ‌ ‌cycle‌ ‌event‌ ‌(such‌ ‌as‌ ‌initialization‌ ‌or‌ ‌shutdown)‌ ‌has‌ ‌occurred.‌ ‌ ‌Listing‌ ‌‌3‌.‌4‌ ‌‌illustrates‌ ‌a‌ ‌typical‌ ‌use‌ ‌of‌ ‌volatile‌ ‌variables:‌ ‌checking‌ ‌a‌ ‌status‌ ‌flag‌ ‌ ‌to‌ ‌determine‌ ‌when‌ ‌to‌ ‌exit‌ ‌a‌ ‌loop.‌ ‌In‌ ‌this‌ ‌example,‌ ‌our‌ ‌anthropomorphized‌ ‌thread‌ ‌ ‌is‌ ‌trying‌ ‌to‌ ‌get‌ ‌to‌ ‌sleep‌ ‌by‌ ‌the‌ ‌time-honored‌ ‌method‌ ‌of‌ ‌counting‌ ‌sheep.‌ ‌For‌ ‌this‌ ‌ ‌example‌ ‌to‌ ‌work,‌ ‌the‌ ‌‌asleep‌ ‌‌flag‌ ‌must‌ ‌be‌ ‌volatile.‌ ‌Otherwise,‌ ‌the‌ ‌thread‌ ‌might‌ ‌ ‌not‌ ‌notice‌ ‌when‌ ‌‌asleep‌ ‌‌has‌ ‌been‌ ‌set‌ ‌by‌ ‌another‌ ‌thread.‌6‌ ‌‌We‌ ‌could‌ ‌instead‌ ‌have‌ ‌ ‌4‌.‌ ‌This‌ ‌analogy‌ ‌is‌ ‌not‌ ‌exact;‌ ‌the‌ ‌memory‌ ‌visibility‌ ‌effects‌ ‌of‌ ‌‌SynchronizedInteger‌ ‌‌are‌ ‌actually‌ ‌ ‌slightly‌ ‌stronger‌ ‌than‌ ‌those‌ ‌of‌ ‌volatile‌ ‌variables.‌ ‌See‌ ‌Chapter‌ ‌‌16‌.‌ ‌ ‌5‌.‌ ‌Volatile‌ ‌reads‌ ‌are‌ ‌only‌ ‌slightly‌ ‌more‌ ‌expensive‌ ‌than‌ ‌nonvolatile‌ ‌reads‌ ‌on‌ ‌most‌ ‌current‌ ‌processor‌ ‌ ‌architectures.‌ ‌ ‌6‌.‌ ‌Debugging‌ ‌tip:‌ ‌For‌ ‌server‌ ‌applications,‌ ‌be‌ ‌sure‌ ‌to‌ ‌always‌ ‌specify‌ ‌the‌ ‌‌-server‌ ‌‌JVM‌ ‌command‌ ‌line‌ ‌ ‌switch‌ ‌when‌ ‌invoking‌ ‌the‌ ‌JVM,‌ ‌even‌ ‌for‌ ‌development‌ ‌and‌ ‌testing.‌ ‌The‌ ‌server‌ ‌JVM‌ ‌performs‌ ‌more‌ ‌ ‌optimization‌ ‌than‌ ‌the‌ ‌client‌ ‌JVM,‌ ‌such‌ ‌as‌ ‌hoisting‌ ‌variables‌ ‌out‌ ‌of‌ ‌a‌ ‌loop‌ ‌that‌ ‌are‌ ‌not‌ ‌modified‌ ‌in‌ ‌ ‌the‌ ‌loop;‌ ‌code‌ ‌that‌ ‌might‌ ‌appear‌ ‌to‌ ‌work‌ ‌in‌ ‌the‌ ‌development‌ ‌environment‌ ‌(client‌ ‌JVM)‌ ‌can‌ ‌break‌ ‌in‌ ‌ ‌the‌ ‌deployment‌ ‌environment‌ ‌(server‌ ‌JVM).‌ ‌For‌ ‌example,‌ ‌had‌ ‌we‌ ‌“forgotten”‌ ‌to‌ ‌declare‌ ‌the‌ ‌variable‌ ‌ ‌asleep‌ ‌‌as‌ ‌‌volatile‌ ‌‌in‌ ‌Listing‌ ‌‌3‌.‌4‌,‌ ‌the‌ ‌server‌ ‌JVM‌ ‌could‌ ‌hoist‌ ‌the‌ ‌test‌ ‌out‌ ‌of‌ ‌the‌ ‌loop‌ ‌(turning‌ ‌it‌ ‌into‌ ‌ ‌an‌ ‌infinite‌ ‌loop),‌ ‌but‌ ‌the‌ ‌client‌ ‌JVM‌ ‌would‌ ‌not.‌ ‌An‌ ‌infinite‌ ‌loop‌ ‌that‌ ‌shows‌ ‌up‌ ‌in‌ ‌development‌ ‌is‌ ‌far‌ ‌ ‌less‌ ‌costly‌ ‌than‌ ‌one‌ ‌that‌ ‌only‌ ‌shows‌ ‌up‌ ‌in‌ ‌production.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌3‌.‌2‌.‌ ‌Publication‌ ‌and‌ ‌escape‌ ‌‌39‌ ‌ ‌used‌ ‌locking‌ ‌to‌ ‌ensure‌ ‌visibility‌ ‌of‌ ‌changes‌ ‌to‌ ‌‌asleep‌,‌ ‌but‌ ‌that‌ ‌would‌ ‌have‌ ‌made‌ ‌ ‌the‌ ‌code‌ ‌more‌ ‌cumbersome.‌ ‌ ‌volatile‌ ‌boolean‌ ‌asleep;‌ ‌ ‌...‌ ‌ ‌while‌ ‌(!asleep)‌ ‌ ‌countSomeSheep();‌ ‌ ‌L‌isting‌ ‌3‌.‌4‌.‌ ‌Counting‌ ‌sheep.‌ ‌ ‌Volatile‌ ‌variables‌ ‌are‌ ‌convenient,‌ ‌but‌ ‌they‌ ‌have‌ ‌limitations.‌ ‌The‌ ‌most‌ ‌common‌ ‌ ‌use‌ ‌for‌ ‌volatile‌ ‌variables‌ ‌is‌ ‌as‌ ‌a‌ ‌completion,‌ ‌interruption,‌ ‌or‌ ‌status‌ ‌flag,‌ ‌such‌ ‌as‌ ‌ ‌the‌ ‌‌asleep‌ ‌‌flag‌ ‌in‌ ‌Listing‌ ‌‌3‌.‌4‌.‌ ‌Volatile‌ ‌variables‌ ‌can‌ ‌be‌ ‌used‌ ‌for‌ ‌other‌ ‌kinds‌ ‌of‌ ‌ ‌state‌ ‌information,‌ ‌but‌ ‌more‌ ‌care‌ ‌is‌ ‌required‌ ‌when‌ ‌attempting‌ ‌this.‌ ‌For‌ ‌example,‌ ‌ ‌the‌ ‌semantics‌ ‌of‌ ‌‌volatile‌ ‌‌are‌ ‌not‌ ‌strong‌ ‌enough‌ ‌to‌ ‌make‌ ‌the‌ ‌increment‌ ‌operation‌ ‌ ‌(‌count++‌)‌ ‌atomic,‌ ‌unless‌ ‌you‌ ‌can‌ ‌guarantee‌ ‌that‌ ‌the‌ ‌variable‌ ‌is‌ ‌written‌ ‌only‌ ‌from‌ ‌ ‌a‌ ‌single‌ ‌thread.‌ ‌(Atomic‌ ‌variables‌ ‌do‌ ‌provide‌ ‌atomic‌ ‌read-modify-write‌ ‌support‌ ‌ ‌and‌ ‌can‌ ‌often‌ ‌be‌ ‌used‌ ‌as‌ ‌“better‌ ‌volatile‌ ‌variables”;‌ ‌see‌ ‌Chapter‌ ‌‌15‌.)‌ ‌ ‌Locking‌ ‌can‌ ‌guarantee‌ ‌both‌ ‌visibility‌ ‌and‌ ‌atomicity;‌ ‌volatile‌ ‌variables‌ ‌can‌ ‌ ‌only‌ ‌guarantee‌ ‌visibility.‌ ‌ ‌You‌ ‌can‌ ‌use‌ ‌volatile‌ ‌variables‌ ‌only‌ ‌when‌ ‌all‌ ‌the‌ ‌following‌ ‌criteria‌ ‌are‌ ‌met:‌ ‌ ‌•‌ ‌Writes‌ ‌to‌ ‌the‌ ‌variable‌ ‌do‌ ‌not‌ ‌depend‌ ‌on‌ ‌its‌ ‌current‌ ‌value,‌ ‌or‌ ‌you‌ ‌can‌ ‌ensure‌ ‌ ‌that‌ ‌only‌ ‌a‌ ‌single‌ ‌thread‌ ‌ever‌ ‌updates‌ ‌the‌ ‌value;‌ ‌ ‌•‌ ‌The‌ ‌variable‌ ‌does‌ ‌not‌ ‌participate‌ ‌in‌ ‌invariants‌ ‌with‌ ‌other‌ ‌state‌ ‌variables;‌ ‌ ‌and‌ ‌ ‌•‌ ‌Locking‌ ‌is‌ ‌not‌ ‌required‌ ‌for‌ ‌any‌ ‌other‌ ‌reason‌ ‌while‌ ‌the‌ ‌variable‌ ‌is‌ ‌being‌ ‌ ‌accessed.‌ ‌ ‌3‌.‌2‌ ‌‌Publication‌ ‌and‌ ‌escape‌ ‌ ‌Publishing‌ ‌‌an‌ ‌object‌ ‌means‌ ‌making‌ ‌it‌ ‌available‌ ‌to‌ ‌code‌ ‌outside‌ ‌of‌ ‌its‌ ‌current‌ ‌scope,‌ ‌ ‌such‌ ‌as‌ ‌by‌ ‌storing‌ ‌a‌ ‌reference‌ ‌to‌ ‌it‌ ‌where‌ ‌other‌ ‌code‌ ‌can‌ ‌find‌ ‌it,‌ ‌returning‌ ‌it‌ ‌ ‌from‌ ‌a‌ ‌nonprivate‌ ‌method,‌ ‌or‌ ‌passing‌ ‌it‌ ‌to‌ ‌a‌ ‌method‌ ‌in‌ ‌another‌ ‌class.‌ ‌In‌ ‌many‌ ‌ ‌situations,‌ ‌we‌ ‌want‌ ‌to‌ ‌ensure‌ ‌that‌ ‌objects‌ ‌and‌ ‌their‌ ‌internals‌ ‌are‌ ‌‌not‌ ‌‌published.‌ ‌ ‌In‌ ‌other‌ ‌situations,‌ ‌we‌ ‌do‌ ‌want‌ ‌to‌ ‌publish‌ ‌an‌ ‌object‌ ‌for‌ ‌general‌ ‌use,‌ ‌but‌ ‌doing‌ ‌so‌ ‌ ‌in‌ ‌a‌ ‌thread-safe‌ ‌manner‌ ‌may‌ ‌require‌ ‌synchronization.‌ ‌Publishing‌ ‌internal‌ ‌state‌ ‌ ‌variables‌ ‌can‌ ‌compromise‌ ‌encapsulation‌ ‌and‌ ‌make‌ ‌it‌ ‌more‌ ‌difficult‌ ‌to‌ ‌preserve‌ ‌ ‌invariants;‌ ‌publishing‌ ‌objects‌ ‌before‌ ‌they‌ ‌are‌ ‌fully‌ ‌constructed‌ ‌can‌ ‌compromise‌ ‌ ‌thread‌ ‌safety.‌ ‌An‌ ‌object‌ ‌that‌ ‌is‌ ‌published‌ ‌when‌ ‌it‌ ‌should‌ ‌not‌ ‌have‌ ‌been‌ ‌is‌ ‌said‌ ‌to‌ ‌ ‌have‌ ‌‌escaped‌.‌ ‌Section‌ ‌‌3‌.‌5‌ ‌‌covers‌ ‌idioms‌ ‌for‌ ‌safe‌ ‌publication;‌ ‌right‌ ‌now,‌ ‌we‌ ‌look‌ ‌at‌ ‌ ‌how‌ ‌an‌ ‌object‌ ‌can‌ ‌escape.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌40‌ ‌‌Chapter‌ ‌‌3‌.‌ ‌Sharing‌ ‌Objects‌ ‌ ‌The‌ ‌most‌ ‌blatant‌ ‌form‌ ‌of‌ ‌publication‌ ‌is‌ ‌to‌ ‌store‌ ‌a‌ ‌reference‌ ‌in‌ ‌a‌ ‌public‌ ‌static‌ ‌ ‌field,‌ ‌where‌ ‌any‌ ‌class‌ ‌and‌ ‌thread‌ ‌could‌ ‌see‌ ‌it,‌ ‌as‌ ‌in‌ ‌Listing‌ ‌‌3‌.‌5‌.‌ ‌The‌ ‌‌initialize‌ ‌ ‌method‌ ‌instantiates‌ ‌a‌ ‌new‌ ‌‌HashSet‌ ‌‌and‌ ‌publishes‌ ‌it‌ ‌by‌ ‌storing‌ ‌a‌ ‌reference‌ ‌to‌ ‌it‌ ‌ ‌into‌ ‌‌knownSecrets‌.‌ ‌ ‌public‌ ‌static‌ ‌Set<Secret>‌ ‌knownSecrets;‌ ‌ ‌public‌ ‌void‌ ‌initialize()‌ ‌{‌ ‌ ‌knownSecrets‌ ‌=‌ ‌new‌ ‌HashSet<Secret>();‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌3‌.‌5‌.‌ ‌Publishing‌ ‌an‌ ‌object.‌ ‌ ‌Publishing‌ ‌one‌ ‌object‌ ‌may‌ ‌indirectly‌ ‌publish‌ ‌others.‌ ‌If‌ ‌you‌ ‌add‌ ‌a‌ ‌‌Secret‌ ‌‌to‌ ‌ ‌the‌ ‌published‌ ‌‌knownSecrets‌ ‌‌set,‌ ‌you’ve‌ ‌also‌ ‌published‌ ‌that‌ ‌‌Secret‌,‌ ‌because‌ ‌any‌ ‌ ‌code‌ ‌can‌ ‌iterate‌ ‌the‌ ‌‌Set‌ ‌‌and‌ ‌obtain‌ ‌a‌ ‌reference‌ ‌to‌ ‌the‌ ‌new‌ ‌‌Secret‌.‌ ‌Similarly,‌ ‌ ‌returning‌ ‌a‌ ‌reference‌ ‌from‌ ‌a‌ ‌nonprivate‌ ‌method‌ ‌also‌ ‌publishes‌ ‌the‌ ‌returned‌ ‌ob‌ ‌ ‌ject.‌ ‌‌UnsafeStates‌ ‌‌in‌ ‌Listing‌ ‌‌3‌.‌6‌ ‌‌publishes‌ ‌the‌ ‌supposedly‌ ‌private‌ ‌array‌ ‌of‌ ‌state‌ ‌ ‌abbreviations.‌ ‌ ‌class‌ ‌UnsafeStates‌ ‌{‌ ‌ ‌private‌ ‌String[]‌ ‌states‌ ‌=‌ ‌new‌ ‌String[]‌ ‌{‌ ‌ ‌"AK",‌ ‌"AL"‌ ‌...‌ ‌ ‌};‌ ‌ ‌public‌ ‌String[]‌ ‌getStates()‌ ‌{‌ ‌return‌ ‌states;‌ ‌}‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌3‌.‌6‌.‌ ‌Allowing‌ ‌internal‌ ‌mutable‌ ‌state‌ ‌to‌ ‌escape.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌ ‌Publishing‌ ‌‌states‌ ‌‌in‌ ‌this‌ ‌way‌ ‌is‌ ‌problematic‌ ‌because‌ ‌any‌ ‌caller‌ ‌can‌ ‌modify‌ ‌its‌ ‌ ‌contents.‌ ‌In‌ ‌this‌ ‌case,‌ ‌the‌ ‌‌states‌ ‌‌array‌ ‌has‌ ‌escaped‌ ‌its‌ ‌intended‌ ‌scope,‌ ‌because‌ ‌ ‌what‌ ‌was‌ ‌supposed‌ ‌to‌ ‌be‌ ‌private‌ ‌state‌ ‌has‌ ‌been‌ ‌effectively‌ ‌made‌ ‌public.‌ ‌ ‌Publishing‌ ‌an‌ ‌object‌ ‌also‌ ‌publishes‌ ‌any‌ ‌objects‌ ‌referred‌ ‌to‌ ‌by‌ ‌its‌ ‌nonprivate‌ ‌ ‌fields.‌ ‌More‌ ‌generally,‌ ‌any‌ ‌object‌ ‌that‌ ‌is‌ ‌‌reachable‌ ‌‌from‌ ‌a‌ ‌published‌ ‌object‌ ‌by‌ ‌ ‌following‌ ‌some‌ ‌chain‌ ‌of‌ ‌nonprivate‌ ‌field‌ ‌references‌ ‌and‌ ‌method‌ ‌calls‌ ‌has‌ ‌also‌ ‌ ‌been‌ ‌published.‌ ‌ ‌From‌ ‌the‌ ‌perspective‌ ‌of‌ ‌a‌ ‌class‌ ‌‌C‌,‌ ‌an‌ ‌‌alien‌ ‌‌method‌ ‌is‌ ‌one‌ ‌whose‌ ‌behavior‌ ‌ ‌is‌ ‌not‌ ‌fully‌ ‌specified‌ ‌by‌ ‌‌C‌.‌ ‌This‌ ‌includes‌ ‌methods‌ ‌in‌ ‌other‌ ‌classes‌ ‌as‌ ‌well‌ ‌as‌ ‌ ‌overrideable‌ ‌methods‌ ‌(neither‌ ‌‌private‌ ‌‌nor‌ ‌‌final‌)‌ ‌in‌ ‌‌C‌ ‌‌itself.‌ ‌Passing‌ ‌an‌ ‌object‌ ‌to‌ ‌ ‌an‌ ‌alien‌ ‌method‌ ‌must‌ ‌also‌ ‌be‌ ‌considered‌ ‌publishing‌ ‌that‌ ‌object.‌ ‌Since‌ ‌you‌ ‌can’t‌ ‌ ‌know‌ ‌what‌ ‌code‌ ‌will‌ ‌actually‌ ‌be‌ ‌invoked,‌ ‌you‌ ‌don’t‌ ‌know‌ ‌that‌ ‌the‌ ‌alien‌ ‌method‌ ‌ ‌won’t‌ ‌publish‌ ‌the‌ ‌object‌ ‌or‌ ‌retain‌ ‌a‌ ‌reference‌ ‌to‌ ‌it‌ ‌that‌ ‌might‌ ‌later‌ ‌be‌ ‌used‌ ‌from‌ ‌ ‌another‌ ‌thread.‌ ‌ ‌Whether‌ ‌another‌ ‌thread‌ ‌actually‌ ‌does‌ ‌something‌ ‌with‌ ‌a‌ ‌published‌ ‌reference‌ ‌ ‌doesn’t‌ ‌really‌ ‌matter,‌ ‌because‌ ‌the‌ ‌risk‌ ‌of‌ ‌misuse‌ ‌is‌ ‌still‌ ‌present.‌7‌ ‌‌Once‌ ‌an‌ ‌ob‌ ‌ ‌7‌.‌ ‌If‌ ‌someone‌ ‌steals‌ ‌your‌ ‌password‌ ‌and‌ ‌posts‌ ‌it‌ ‌on‌ ‌the‌ ‌‌alt.free-passwords‌ ‌‌newsgroup,‌ ‌that‌ ‌infor‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌3‌.‌2‌.‌ ‌Publication‌ ‌and‌ ‌escape‌ ‌‌41‌ ‌ ‌ject‌ ‌escapes,‌ ‌you‌ ‌have‌ ‌to‌ ‌assume‌ ‌that‌ ‌another‌ ‌class‌ ‌or‌ ‌thread‌ ‌may,‌ ‌maliciously‌ ‌or‌ ‌ ‌carelessly,‌ ‌misuse‌ ‌it.‌ ‌This‌ ‌is‌ ‌a‌ ‌compelling‌ ‌reason‌ ‌to‌ ‌use‌ ‌encapsulation:‌ ‌it‌ ‌makes‌ ‌ ‌it‌ ‌practical‌ ‌to‌ ‌analyze‌ ‌programs‌ ‌for‌ ‌correctness‌ ‌and‌ ‌harder‌ ‌to‌ ‌violate‌ ‌design‌ ‌con‌ ‌ ‌straints‌ ‌accidentally.‌ ‌ ‌A‌ ‌final‌ ‌mechanism‌ ‌by‌ ‌which‌ ‌an‌ ‌object‌ ‌or‌ ‌its‌ ‌internal‌ ‌state‌ ‌can‌ ‌be‌ ‌published‌ ‌is‌ ‌ ‌to‌ ‌publish‌ ‌an‌ ‌inner‌ ‌class‌ ‌instance,‌ ‌as‌ ‌shown‌ ‌in‌ ‌‌ThisEscape‌ ‌‌in‌ ‌Listing‌ ‌‌3‌.‌7‌.‌ ‌When‌ ‌ ‌ThisEscape‌ ‌‌publishes‌ ‌the‌ ‌‌EventListener‌,‌ ‌it‌ ‌implicitly‌ ‌publishes‌ ‌the‌ ‌enclosing‌ ‌ ‌ThisEscape‌ ‌‌instance‌ ‌as‌ ‌well,‌ ‌because‌ ‌inner‌ ‌class‌ ‌instances‌ ‌contain‌ ‌a‌ ‌hidden‌ ‌ref‌ ‌ ‌erence‌ ‌to‌ ‌the‌ ‌enclosing‌ ‌instance.‌ ‌ ‌public‌ ‌class‌ ‌ThisEscape‌ ‌{‌ ‌ ‌public‌ ‌ThisEscape(EventSource‌ ‌source)‌ ‌{‌ ‌ ‌source.registerListener(‌ ‌ ‌new‌ ‌EventListener()‌ ‌{‌ ‌ ‌public‌ ‌void‌ ‌onEvent(Event‌ ‌e)‌ ‌{‌ ‌ ‌doSomething(e);‌ ‌ ‌}‌ ‌ ‌});‌ ‌ ‌}‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌3‌.‌7‌.‌ ‌Implicitly‌ ‌allowing‌ ‌the‌ ‌‌this‌ ‌‌reference‌ ‌to‌ ‌escape.‌ ‌‌Don’t‌ ‌do‌ ‌this.‌ ‌ ‌3‌.‌2‌.‌1‌ ‌‌Safe‌ ‌construction‌ ‌practices‌ ‌ ‌ThisEscape‌ ‌‌illustrates‌ ‌an‌ ‌important‌ ‌special‌ ‌case‌ ‌of‌ ‌escape—when‌ ‌the‌ ‌‌this‌ ‌‌ref‌ ‌ ‌erences‌ ‌escapes‌ ‌during‌ ‌construction.‌ ‌When‌ ‌the‌ ‌inner‌ ‌‌EventListener‌ ‌‌instance‌ ‌is‌ ‌ ‌published,‌ ‌so‌ ‌is‌ ‌the‌ ‌enclosing‌ ‌‌ThisEscape‌ ‌‌instance.‌ ‌But‌ ‌an‌ ‌object‌ ‌is‌ ‌in‌ ‌a‌ ‌pre‌ ‌ ‌dictable,‌ ‌consistent‌ ‌state‌ ‌only‌ ‌after‌ ‌its‌ ‌constructor‌ ‌returns,‌ ‌so‌ ‌publishing‌ ‌an‌ ‌object‌ ‌ ‌from‌ ‌within‌ ‌its‌ ‌constructor‌ ‌can‌ ‌publish‌ ‌an‌ ‌incompletely‌ ‌constructed‌ ‌object.‌ ‌This‌ ‌is‌ ‌ ‌true‌ ‌‌even‌ ‌if‌ ‌the‌ ‌publication‌ ‌is‌ ‌the‌ ‌last‌ ‌statement‌ ‌in‌ ‌the‌ ‌constructor.‌ ‌‌If‌ ‌the‌ ‌‌this‌ ‌‌reference‌ ‌ ‌escapes‌ ‌during‌ ‌construction,‌ ‌the‌ ‌object‌ ‌is‌ ‌considered‌ ‌‌not‌ ‌properly‌ ‌constructed‌.‌8‌ ‌ ‌Do‌ ‌not‌ ‌allow‌ ‌the‌ ‌this‌ ‌reference‌ ‌to‌ ‌escape‌ ‌during‌ ‌construction.‌ ‌ ‌A‌ ‌common‌ ‌mistake‌ ‌that‌ ‌can‌ ‌let‌ ‌the‌ ‌‌this‌ ‌‌reference‌ ‌escape‌ ‌during‌ ‌construction‌ ‌ ‌is‌ ‌to‌ ‌start‌ ‌a‌ ‌thread‌ ‌from‌ ‌a‌ ‌constructor.‌ ‌When‌ ‌an‌ ‌object‌ ‌creates‌ ‌a‌ ‌thread‌ ‌from‌ ‌its‌ ‌ ‌constructor,‌ ‌it‌ ‌almost‌ ‌always‌ ‌shares‌ ‌its‌ ‌‌this‌ ‌‌reference‌ ‌with‌ ‌the‌ ‌new‌ ‌thread,‌ ‌either‌ ‌ ‌explicitly‌ ‌(by‌ ‌passing‌ ‌it‌ ‌to‌ ‌the‌ ‌constructor)‌ ‌or‌ ‌implicitly‌ ‌(because‌ ‌the‌ ‌‌Thread‌ ‌‌or‌ ‌ ‌mation‌ ‌has‌ ‌escaped:‌ ‌whether‌ ‌or‌ ‌not‌ ‌someone‌ ‌has‌ ‌(yet)‌ ‌used‌ ‌those‌ ‌credentials‌ ‌to‌ ‌create‌ ‌mischief,‌ ‌your‌ ‌ ‌account‌ ‌has‌ ‌still‌ ‌been‌ ‌compromised.‌ ‌Publishing‌ ‌a‌ ‌reference‌ ‌poses‌ ‌the‌ ‌same‌ ‌sort‌ ‌of‌ ‌risk.‌ ‌ ‌8‌.‌ ‌More‌ ‌specifically,‌ ‌the‌ ‌‌this‌ ‌‌reference‌ ‌should‌ ‌not‌ ‌escape‌ ‌from‌ ‌the‌ ‌‌thread‌ ‌‌until‌ ‌after‌ ‌the‌ ‌constructor‌ ‌ ‌returns.‌ ‌The‌ ‌‌this‌ ‌‌reference‌ ‌can‌ ‌be‌ ‌stored‌ ‌somewhere‌ ‌by‌ ‌the‌ ‌constructor‌ ‌so‌ ‌long‌ ‌as‌ ‌it‌ ‌is‌ ‌not‌ ‌‌used‌ ‌‌by‌ ‌ ‌another‌ ‌thread‌ ‌until‌ ‌after‌ ‌construction.‌ ‌‌SafeListener‌ ‌‌in‌ ‌Listing‌ ‌‌3‌.‌8‌ ‌‌uses‌ ‌this‌ ‌technique.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌42‌ ‌‌Chapter‌ ‌‌3‌.‌ ‌Sharing‌ ‌Objects‌ ‌ ‌Runnable‌ ‌‌is‌ ‌an‌ ‌inner‌ ‌class‌ ‌of‌ ‌the‌ ‌owning‌ ‌object).‌ ‌The‌ ‌new‌ ‌thread‌ ‌might‌ ‌then‌ ‌be‌ ‌ ‌able‌ ‌to‌ ‌see‌ ‌the‌ ‌owning‌ ‌object‌ ‌before‌ ‌it‌ ‌is‌ ‌fully‌ ‌constructed.‌ ‌There’s‌ ‌nothing‌ ‌wrong‌ ‌ ‌with‌ ‌‌creating‌ ‌‌a‌ ‌thread‌ ‌in‌ ‌a‌ ‌constructor,‌ ‌but‌ ‌it‌ ‌is‌ ‌best‌ ‌not‌ ‌to‌ ‌‌start‌ ‌‌the‌ ‌thread‌ ‌im‌ ‌ ‌mediately.‌ ‌Instead,‌ ‌expose‌ ‌a‌ ‌‌start‌ ‌‌or‌ ‌‌initialize‌ ‌‌method‌ ‌that‌ ‌starts‌ ‌the‌ ‌owned‌ ‌ ‌thread.‌ ‌(See‌ ‌Chapter‌ ‌‌7‌ ‌‌for‌ ‌more‌ ‌on‌ ‌service‌ ‌lifecycle‌ ‌issues.)‌ ‌Calling‌ ‌an‌ ‌override‌ ‌ ‌able‌ ‌instance‌ ‌method‌ ‌(one‌ ‌that‌ ‌is‌ ‌neither‌ ‌‌private‌ ‌‌nor‌ ‌‌final‌)‌ ‌from‌ ‌the‌ ‌constructor‌ ‌ ‌can‌ ‌also‌ ‌allow‌ ‌the‌ ‌‌this‌ ‌‌reference‌ ‌to‌ ‌escape.‌ ‌ ‌If‌ ‌you‌ ‌are‌ ‌tempted‌ ‌to‌ ‌register‌ ‌an‌ ‌event‌ ‌listener‌ ‌or‌ ‌start‌ ‌a‌ ‌thread‌ ‌from‌ ‌a‌ ‌con‌ ‌ ‌structor,‌ ‌you‌ ‌can‌ ‌avoid‌ ‌the‌ ‌improper‌ ‌construction‌ ‌by‌ ‌using‌ ‌a‌ ‌private‌ ‌constructor‌ ‌ ‌and‌ ‌a‌ ‌public‌ ‌factory‌ ‌method,‌ ‌as‌ ‌shown‌ ‌in‌ ‌‌SafeListener‌ ‌‌in‌ ‌Listing‌ ‌‌3‌.‌8‌.‌ ‌ ‌public‌ ‌class‌ ‌SafeListener‌ ‌{‌ ‌ ‌private‌ ‌final‌ ‌EventListener‌ ‌listener;‌ ‌ ‌private‌ ‌SafeListener()‌ ‌{‌ ‌ ‌listener‌ ‌=‌ ‌new‌ ‌EventListener()‌ ‌{‌ ‌ ‌public‌ ‌void‌ ‌onEvent(Event‌ ‌e)‌ ‌{‌ ‌ ‌doSomething(e);‌ ‌ ‌}‌ ‌ ‌};‌ ‌ ‌}‌ ‌ ‌public‌ ‌static‌ ‌SafeListener‌ ‌newInstance(EventSource‌ ‌source)‌ ‌{‌ ‌ ‌SafeListener‌ ‌safe‌ ‌=‌ ‌new‌ ‌SafeListener();‌ ‌ ‌source.registerListener(safe.listener);‌ ‌ ‌return‌ ‌safe;‌ ‌ ‌}‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌3‌.‌8‌.‌ ‌Using‌ ‌a‌ ‌factory‌ ‌method‌ ‌to‌ ‌prevent‌ ‌the‌ ‌‌this‌ ‌‌reference‌ ‌from‌ ‌escaping‌ ‌ ‌during‌ ‌construction.‌ ‌ ‌3‌.‌3‌ ‌‌Thread‌ ‌confinement‌ ‌ ‌Accessing‌ ‌shared,‌ ‌mutable‌ ‌data‌ ‌requires‌ ‌using‌ ‌synchronization;‌ ‌one‌ ‌way‌ ‌to‌ ‌avoid‌ ‌ ‌this‌ ‌requirement‌ ‌is‌ ‌to‌ ‌‌not‌ ‌share‌.‌ ‌If‌ ‌data‌ ‌is‌ ‌only‌ ‌accessed‌ ‌from‌ ‌a‌ ‌single‌ ‌thread,‌ ‌ ‌no‌ ‌synchronization‌ ‌is‌ ‌needed.‌ ‌This‌ ‌technique,‌ ‌‌thread‌ ‌confinement‌,‌ ‌is‌ ‌one‌ ‌of‌ ‌the‌ ‌ ‌simplest‌ ‌ways‌ ‌to‌ ‌achieve‌ ‌thread‌ ‌safety.‌ ‌When‌ ‌an‌ ‌object‌ ‌is‌ ‌confined‌ ‌to‌ ‌a‌ ‌thread,‌ ‌ ‌such‌ ‌usage‌ ‌is‌ ‌automatically‌ ‌thread-safe‌ ‌even‌ ‌if‌ ‌the‌ ‌confined‌ ‌object‌ ‌itself‌ ‌is‌ ‌not‌ ‌ ‌[CPJ‌ ‌‌2‌.‌3‌.‌2‌].‌ ‌ ‌Swing‌ ‌uses‌ ‌thread‌ ‌confinement‌ ‌extensively.‌ ‌The‌ ‌Swing‌ ‌visual‌ ‌components‌ ‌and‌ ‌ ‌data‌ ‌model‌ ‌objects‌ ‌are‌ ‌not‌ ‌thread‌ ‌safe;‌ ‌instead,‌ ‌safety‌ ‌is‌ ‌achieved‌ ‌by‌ ‌confining‌ ‌ ‌them‌ ‌to‌ ‌the‌ ‌Swing‌ ‌event‌ ‌dispatch‌ ‌thread.‌ ‌To‌ ‌use‌ ‌Swing‌ ‌properly,‌ ‌code‌ ‌running‌ ‌in‌ ‌ ‌threads‌ ‌other‌ ‌than‌ ‌the‌ ‌event‌ ‌thread‌ ‌should‌ ‌not‌ ‌access‌ ‌these‌ ‌objects.‌ ‌(To‌ ‌make‌ ‌this‌ ‌ ‌easier,‌ ‌Swing‌ ‌provides‌ ‌the‌ ‌‌invokeLater‌ ‌‌mechanism‌ ‌to‌ ‌schedule‌ ‌a‌ ‌‌Runnable‌ ‌‌for‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌3‌.‌3‌.‌ ‌Thread‌ ‌confinement‌ ‌‌43‌ ‌ ‌execution‌ ‌in‌ ‌the‌ ‌event‌ ‌thread.)‌ ‌Many‌ ‌concurrency‌ ‌errors‌ ‌in‌ ‌Swing‌ ‌applications‌ ‌ ‌stem‌ ‌from‌ ‌improper‌ ‌use‌ ‌of‌ ‌these‌ ‌confined‌ ‌objects‌ ‌from‌ ‌another‌ ‌thread.‌ ‌ ‌Another‌ ‌common‌ ‌application‌ ‌of‌ ‌thread‌ ‌confinement‌ ‌is‌ ‌the‌ ‌use‌ ‌of‌ ‌pooled‌ ‌JDBC‌ ‌ ‌(Java‌ ‌Database‌ ‌Connectivity)‌ ‌‌Connection‌ ‌‌objects.‌ ‌The‌ ‌JDBC‌ ‌specification‌ ‌does‌ ‌not‌ ‌ ‌require‌ ‌that‌ ‌‌Connection‌ ‌‌objects‌ ‌be‌ ‌thread-safe.‌9‌ ‌‌In‌ ‌typical‌ ‌server‌ ‌applications,‌ ‌a‌ ‌ ‌thread‌ ‌acquires‌ ‌a‌ ‌connection‌ ‌from‌ ‌the‌ ‌pool,‌ ‌uses‌ ‌it‌ ‌for‌ ‌processing‌ ‌a‌ ‌single‌ ‌request,‌ ‌ ‌and‌ ‌returns‌ ‌it.‌ ‌Since‌ ‌most‌ ‌requests,‌ ‌such‌ ‌as‌ ‌servlet‌ ‌requests‌ ‌or‌ ‌EJB‌ ‌(Enterprise‌ ‌ ‌JavaBeans)‌ ‌calls,‌ ‌are‌ ‌processed‌ ‌synchronously‌ ‌by‌ ‌a‌ ‌single‌ ‌thread,‌ ‌and‌ ‌the‌ ‌pool‌ ‌ ‌will‌ ‌not‌ ‌dispense‌ ‌the‌ ‌same‌ ‌connection‌ ‌to‌ ‌another‌ ‌thread‌ ‌until‌ ‌it‌ ‌has‌ ‌been‌ ‌returned,‌ ‌ ‌this‌ ‌pattern‌ ‌of‌ ‌connection‌ ‌management‌ ‌implicitly‌ ‌confines‌ ‌the‌ ‌‌Connection‌ ‌‌to‌ ‌that‌ ‌ ‌thread‌ ‌for‌ ‌the‌ ‌duration‌ ‌of‌ ‌the‌ ‌request.‌ ‌ ‌Just‌ ‌as‌ ‌the‌ ‌language‌ ‌has‌ ‌no‌ ‌mechanism‌ ‌for‌ ‌enforcing‌ ‌that‌ ‌a‌ ‌variable‌ ‌is‌ ‌guarded‌ ‌ ‌by‌ ‌a‌ ‌lock,‌ ‌it‌ ‌has‌ ‌no‌ ‌means‌ ‌of‌ ‌confining‌ ‌an‌ ‌object‌ ‌to‌ ‌a‌ ‌thread.‌ ‌Thread‌ ‌confinement‌ ‌is‌ ‌ ‌an‌ ‌element‌ ‌of‌ ‌your‌ ‌program’s‌ ‌design‌ ‌that‌ ‌must‌ ‌be‌ ‌enforced‌ ‌by‌ ‌its‌ ‌implementation.‌ ‌ ‌The‌ ‌language‌ ‌and‌ ‌core‌ ‌libraries‌ ‌provide‌ ‌mechanisms‌ ‌that‌ ‌can‌ ‌help‌ ‌in‌ ‌maintaining‌ ‌ ‌thread‌ ‌confinement—local‌ ‌variables‌ ‌and‌ ‌the‌ ‌‌ThreadLocal‌ ‌‌class—but‌ ‌even‌ ‌with‌ ‌ ‌these,‌ ‌it‌ ‌is‌ ‌still‌ ‌the‌ ‌programmer’s‌ ‌responsibility‌ ‌to‌ ‌ensure‌ ‌that‌ ‌thread-confined‌ ‌ ‌objects‌ ‌do‌ ‌not‌ ‌escape‌ ‌from‌ ‌their‌ ‌intended‌ ‌thread.‌ ‌ ‌3‌.‌3‌.‌1‌ ‌‌Ad-hoc‌ ‌thread‌ ‌confinement‌ ‌ ‌Ad-hoc‌ ‌thread‌ ‌confinement‌ ‌‌describes‌ ‌when‌ ‌the‌ ‌responsibility‌ ‌for‌ ‌maintaining‌ ‌thread‌ ‌ ‌confinement‌ ‌falls‌ ‌entirely‌ ‌on‌ ‌the‌ ‌implementation.‌ ‌Ad-hoc‌ ‌thread‌ ‌confinement‌ ‌can‌ ‌ ‌be‌ ‌fragile‌ ‌because‌ ‌none‌ ‌of‌ ‌the‌ ‌language‌ ‌features,‌ ‌such‌ ‌as‌ ‌visibility‌ ‌modifiers‌ ‌or‌ ‌ ‌local‌ ‌variables,‌ ‌helps‌ ‌confine‌ ‌the‌ ‌object‌ ‌to‌ ‌the‌ ‌target‌ ‌thread.‌ ‌In‌ ‌fact,‌ ‌references‌ ‌to‌ ‌ ‌thread-confined‌ ‌objects‌ ‌such‌ ‌as‌ ‌visual‌ ‌components‌ ‌or‌ ‌data‌ ‌models‌ ‌in‌ ‌GUI‌ ‌appli‌ ‌ ‌cations‌ ‌are‌ ‌often‌ ‌held‌ ‌in‌ ‌public‌ ‌fields.‌ ‌ ‌The‌ ‌decision‌ ‌to‌ ‌use‌ ‌thread‌ ‌confinement‌ ‌is‌ ‌often‌ ‌a‌ ‌consequence‌ ‌of‌ ‌the‌ ‌decision‌ ‌ ‌to‌ ‌implement‌ ‌a‌ ‌particular‌ ‌subsystem,‌ ‌such‌ ‌as‌ ‌the‌ ‌GUI,‌ ‌as‌ ‌a‌ ‌single-threaded‌ ‌sub‌ ‌ ‌system.‌ ‌Single-threaded‌ ‌subsystems‌ ‌can‌ ‌sometimes‌ ‌offer‌ ‌a‌ ‌simplicity‌ ‌benefit‌ ‌that‌ ‌ ‌outweighs‌ ‌the‌ ‌fragility‌ ‌of‌ ‌ad-hoc‌ ‌thread‌ ‌confinement.‌10‌ ‌ ‌A‌ ‌special‌ ‌case‌ ‌of‌ ‌thread‌ ‌confinement‌ ‌applies‌ ‌to‌ ‌volatile‌ ‌variables.‌ ‌It‌ ‌is‌ ‌safe‌ ‌to‌ ‌ ‌perform‌ ‌read-modify-write‌ ‌operations‌ ‌on‌ ‌shared‌ ‌volatile‌ ‌variables‌ ‌as‌ ‌long‌ ‌as‌ ‌you‌ ‌ ‌ensure‌ ‌that‌ ‌the‌ ‌volatile‌ ‌variable‌ ‌is‌ ‌only‌ ‌written‌ ‌from‌ ‌a‌ ‌single‌ ‌thread.‌ ‌In‌ ‌this‌ ‌case,‌ ‌ ‌you‌ ‌are‌ ‌confining‌ ‌the‌ ‌‌modification‌ ‌‌to‌ ‌a‌ ‌single‌ ‌thread‌ ‌to‌ ‌prevent‌ ‌race‌ ‌conditions,‌ ‌ ‌and‌ ‌the‌ ‌visibility‌ ‌guarantees‌ ‌for‌ ‌volatile‌ ‌variables‌ ‌ensure‌ ‌that‌ ‌other‌ ‌threads‌ ‌see‌ ‌ ‌the‌ ‌most‌ ‌up-to-date‌ ‌value.‌ ‌ ‌Because‌ ‌of‌ ‌its‌ ‌fragility,‌ ‌ad-hoc‌ ‌thread‌ ‌confinement‌ ‌should‌ ‌be‌ ‌used‌ ‌sparingly;‌ ‌ ‌if‌ ‌possible,‌ ‌use‌ ‌one‌ ‌of‌ ‌the‌ ‌stronger‌ ‌forms‌ ‌of‌ ‌thread‌ ‌confinment‌ ‌(stack‌ ‌confinement‌ ‌ ‌or‌ ‌‌ThreadLocal‌)‌ ‌instead.‌ ‌ ‌9‌.‌ ‌The‌ ‌connection‌ ‌‌pool‌ ‌‌implementations‌ ‌provided‌ ‌by‌ ‌application‌ ‌servers‌ ‌are‌ ‌thread-safe;‌ ‌connection‌ ‌ ‌pools‌ ‌are‌ ‌necessarily‌ ‌accessed‌ ‌from‌ ‌multiple‌ ‌threads,‌ ‌so‌ ‌a‌ ‌non-thread-safe‌ ‌implementation‌ ‌would‌ ‌not‌ ‌ ‌make‌ ‌sense.‌ ‌ ‌10‌.‌ ‌Another‌ ‌reason‌ ‌to‌ ‌make‌ ‌a‌ ‌subsystem‌ ‌single-threaded‌ ‌is‌ ‌deadlock‌ ‌avoidance;‌ ‌this‌ ‌is‌ ‌one‌ ‌of‌ ‌the‌ ‌ ‌primary‌ ‌reasons‌ ‌most‌ ‌GUI‌ ‌frameworks‌ ‌are‌ ‌single-threaded.‌ ‌Single-threaded‌ ‌subsystems‌ ‌are‌ ‌covered‌ ‌ ‌in‌ ‌Chapter‌ ‌‌9‌.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌44‌ ‌‌Chapter‌ ‌‌3‌.‌ ‌Sharing‌ ‌Objects‌ ‌ ‌3‌.‌3‌.‌2‌ ‌‌Stack‌ ‌confinement‌ ‌ ‌Stack‌ ‌confinement‌ ‌‌is‌ ‌a‌ ‌special‌ ‌case‌ ‌of‌ ‌thread‌ ‌confinement‌ ‌in‌ ‌which‌ ‌an‌ ‌object‌ ‌can‌ ‌ ‌only‌ ‌be‌ ‌reached‌ ‌through‌ ‌local‌ ‌variables.‌ ‌Just‌ ‌as‌ ‌encapsulation‌ ‌can‌ ‌make‌ ‌it‌ ‌easier‌ ‌ ‌to‌ ‌preserve‌ ‌invariants,‌ ‌local‌ ‌variables‌ ‌can‌ ‌make‌ ‌it‌ ‌easier‌ ‌to‌ ‌confine‌ ‌objects‌ ‌to‌ ‌a‌ ‌ ‌thread.‌ ‌Local‌ ‌variables‌ ‌are‌ ‌intrinsically‌ ‌confined‌ ‌to‌ ‌the‌ ‌executing‌ ‌thread;‌ ‌they‌ ‌ex‌ ‌ ‌ist‌ ‌on‌ ‌the‌ ‌executing‌ ‌thread’s‌ ‌stack,‌ ‌which‌ ‌is‌ ‌not‌ ‌accessible‌ ‌to‌ ‌other‌ ‌threads.‌ ‌Stack‌ ‌ ‌confinement‌ ‌(also‌ ‌called‌ ‌‌within-thread‌ ‌‌or‌ ‌‌thread-local‌ ‌‌usage,‌ ‌but‌ ‌not‌ ‌to‌ ‌be‌ ‌confused‌ ‌ ‌with‌ ‌the‌ ‌‌ThreadLocal‌ ‌‌library‌ ‌class)‌ ‌is‌ ‌simpler‌ ‌to‌ ‌maintain‌ ‌and‌ ‌less‌ ‌fragile‌ ‌than‌ ‌ ‌ad-hoc‌ ‌thread‌ ‌confinement.‌ ‌ ‌For‌ ‌primitively‌ ‌typed‌ ‌local‌ ‌variables,‌ ‌such‌ ‌as‌ ‌‌numPairs‌ ‌‌in‌ ‌‌loadTheArk‌ ‌‌in‌ ‌List‌ ‌ ‌ing‌ ‌‌3‌.‌9‌,‌ ‌you‌ ‌cannot‌ ‌violate‌ ‌stack‌ ‌confinement‌ ‌even‌ ‌if‌ ‌you‌ ‌tried.‌ ‌There‌ ‌is‌ ‌no‌ ‌way‌ ‌to‌ ‌ ‌obtain‌ ‌a‌ ‌reference‌ ‌to‌ ‌a‌ ‌primitive‌ ‌variable,‌ ‌so‌ ‌the‌ ‌language‌ ‌semantics‌ ‌ensure‌ ‌that‌ ‌ ‌primitive‌ ‌local‌ ‌variables‌ ‌are‌ ‌always‌ ‌stack‌ ‌confined.‌ ‌ ‌public‌ ‌int‌ ‌loadTheArk(Collection<Animal>‌ ‌candidates)‌ ‌{‌ ‌ ‌SortedSet<Animal>‌ ‌animals;‌ ‌ ‌int‌ ‌numPairs‌ ‌=‌ ‌0;‌ ‌ ‌Animal‌ ‌candidate‌ ‌=‌ ‌null;‌ ‌ ‌//‌ ‌animals‌ ‌confined‌ ‌to‌ ‌method,‌ ‌don’t‌ ‌let‌ ‌them‌ ‌escape!‌ ‌ ‌animals‌ ‌=‌ ‌new‌ ‌TreeSet<Animal>(new‌ ‌SpeciesGenderComparator());‌ ‌ ‌animals.addAll(candidates);‌ ‌ ‌for‌ ‌(Animal‌ ‌a‌ ‌:‌ ‌animals)‌ ‌{‌ ‌ ‌if‌ ‌(candidate‌ ‌==‌ ‌null‌ ‌||‌ ‌!candidate.isPotentialMate(a))‌ ‌ ‌candidate‌ ‌=‌ ‌a;‌ ‌ ‌else‌ ‌{‌ ‌ ‌ark.load(new‌ ‌AnimalPair(candidate,‌ ‌a));‌ ‌ ‌++numPairs;‌ ‌ ‌candidate‌ ‌=‌ ‌null;‌ ‌ ‌}‌ ‌ ‌}‌ ‌ ‌return‌ ‌numPairs;‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌3‌.‌9‌.‌ ‌Thread‌ ‌confinement‌ ‌of‌ ‌local‌ ‌primitive‌ ‌and‌ ‌reference‌ ‌variables.‌ ‌ ‌Maintaining‌ ‌stack‌ ‌confinement‌ ‌for‌ ‌object‌ ‌references‌ ‌requires‌ ‌a‌ ‌little‌ ‌more‌ ‌as‌ ‌ ‌sistance‌ ‌from‌ ‌the‌ ‌programmer‌ ‌to‌ ‌ensure‌ ‌that‌ ‌the‌ ‌referent‌ ‌does‌ ‌not‌ ‌escape.‌ ‌In‌ ‌ ‌loadTheArk‌,‌ ‌we‌ ‌instantiate‌ ‌a‌ ‌‌TreeSet‌ ‌‌and‌ ‌store‌ ‌a‌ ‌reference‌ ‌to‌ ‌it‌ ‌in‌ ‌‌animals‌.‌ ‌At‌ ‌ ‌this‌ ‌point,‌ ‌there‌ ‌is‌ ‌exactly‌ ‌one‌ ‌reference‌ ‌to‌ ‌the‌ ‌‌Set‌,‌ ‌held‌ ‌in‌ ‌a‌ ‌local‌ ‌variable‌ ‌and‌ ‌ ‌therefore‌ ‌confined‌ ‌to‌ ‌the‌ ‌executing‌ ‌thread.‌ ‌However,‌ ‌if‌ ‌we‌ ‌were‌ ‌to‌ ‌publish‌ ‌a‌ ‌ref‌ ‌ ‌erence‌ ‌to‌ ‌the‌ ‌‌Set‌ ‌‌(or‌ ‌any‌ ‌of‌ ‌its‌ ‌internals),‌ ‌the‌ ‌confinement‌ ‌would‌ ‌be‌ ‌violated‌ ‌and‌ ‌ ‌the‌ ‌animals‌ ‌would‌ ‌escape.‌ ‌ ‌Using‌ ‌a‌ ‌non-thread-safe‌ ‌object‌ ‌in‌ ‌a‌ ‌within-thread‌ ‌context‌ ‌is‌ ‌still‌ ‌thread-safe.‌ ‌ ‌However,‌ ‌be‌ ‌careful:‌ ‌the‌ ‌design‌ ‌requirement‌ ‌that‌ ‌the‌ ‌object‌ ‌be‌ ‌confined‌ ‌to‌ ‌the‌ ‌ ‌executing‌ ‌thread,‌ ‌or‌ ‌the‌ ‌awareness‌ ‌that‌ ‌the‌ ‌confined‌ ‌object‌ ‌is‌ ‌not‌ ‌thread-safe,‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌3‌.‌3‌.‌ ‌Thread‌ ‌confinement‌ ‌‌45‌ ‌ ‌often‌ ‌exists‌ ‌only‌ ‌in‌ ‌the‌ ‌head‌ ‌of‌ ‌the‌ ‌developer‌ ‌when‌ ‌the‌ ‌code‌ ‌is‌ ‌written.‌ ‌If‌ ‌the‌ ‌assumption‌ ‌of‌ ‌within-thread‌ ‌usage‌ ‌is‌ ‌not‌ ‌clearly‌ ‌documented,‌ ‌future‌ ‌maintainers‌ ‌might‌ ‌mistakenly‌ ‌allow‌ ‌the‌ ‌object‌ ‌to‌ ‌escape.‌ ‌ ‌3‌.‌3‌.‌3‌ ‌‌ThreadLocal‌ ‌ ‌A‌ ‌more‌ ‌formal‌ ‌means‌ ‌of‌ ‌maintaining‌ ‌thread‌ ‌confinement‌ ‌is‌ ‌‌ThreadLocal‌,‌ ‌which‌ ‌allows‌ ‌you‌ ‌to‌ ‌associate‌ ‌a‌ ‌per-thread‌ ‌value‌ ‌with‌ ‌a‌ ‌value-holding‌ ‌object.‌ ‌‌Thread‌ ‌Local‌ ‌‌provides‌ ‌‌get‌ ‌‌and‌ ‌‌set‌ ‌‌accessor‌ ‌methods‌ ‌that‌ ‌maintain‌ ‌a‌ ‌separate‌ ‌copy‌ ‌of‌ ‌the‌ ‌value‌ ‌for‌ ‌each‌ ‌thread‌ ‌that‌ ‌uses‌ ‌it,‌ ‌so‌ ‌a‌ ‌‌get‌ ‌‌returns‌ ‌the‌ ‌most‌ ‌recent‌ ‌value‌ ‌passed‌ ‌to‌ ‌set‌ ‌‌from‌ ‌the‌ ‌currently‌ ‌executing‌ ‌thread‌.‌ ‌ ‌Licensed‌ ‌by‌ ‌ ‌Thread-local‌ ‌variables‌ ‌are‌ ‌often‌ ‌used‌ ‌to‌ ‌prevent‌ ‌sharing‌ ‌in‌ ‌designs‌ ‌based‌ ‌on‌ ‌mutable‌ ‌Singletons‌ ‌or‌ ‌global‌ ‌variables.‌ ‌For‌ ‌example,‌ ‌a‌ ‌single-threaded‌ ‌applica‌ ‌tion‌ ‌might‌ ‌maintain‌ ‌a‌ ‌global‌ ‌database‌ ‌connection‌ ‌that‌ ‌is‌ ‌initialized‌ ‌at‌ ‌startup‌ ‌to‌ ‌avoid‌ ‌having‌ ‌to‌ ‌pass‌ ‌a‌ ‌‌Connection‌ ‌‌to‌ ‌every‌ ‌method.‌ ‌Since‌ ‌JDBC‌ ‌connections‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌may‌ ‌not‌ ‌be‌ ‌thread-safe,‌ ‌a‌ ‌multithreaded‌ ‌application‌ ‌that‌ ‌uses‌ ‌a‌ ‌global‌ ‌connection‌ ‌without‌ ‌additional‌ ‌coordination‌ ‌is‌ ‌not‌ ‌thread-safe‌ ‌either.‌ ‌By‌ ‌using‌ ‌a‌ ‌‌ThreadLocal‌ ‌to‌ ‌store‌ ‌the‌ ‌JDBC‌ ‌connection,‌ ‌as‌ ‌in‌ ‌‌ConnectionHolder‌ ‌‌in‌ ‌Listing‌ ‌‌3‌.‌10‌,‌ ‌each‌ ‌thread‌ ‌ ‌will‌ ‌have‌ ‌its‌ ‌own‌ ‌connection.‌ ‌ ‌1821604‌ ‌private‌ ‌static‌ ‌ThreadLocal<Connection>‌ ‌connectionHolder‌ ‌ ‌=‌ ‌new‌ ‌ThreadLocal<Connection>()‌ ‌{‌ ‌ ‌public‌ ‌Connection‌ ‌initialValue()‌ ‌{‌ ‌ ‌return‌ ‌DriverManager.getConnection(DB_URL);‌ ‌ ‌}‌ ‌ ‌};‌ ‌ ‌public‌ ‌static‌ ‌Connection‌ ‌getConnection()‌ ‌{‌ ‌ ‌return‌ ‌connectionHolder.get();‌ ‌ ‌}‌ ‌ ‌L‌isting‌ ‌3‌.‌10‌.‌ ‌Using‌ ‌‌ThreadLocal‌ ‌‌to‌ ‌ensure‌ ‌thread‌ ‌confinement.‌ ‌ ‌This‌ ‌technique‌ ‌can‌ ‌also‌ ‌be‌ ‌used‌ ‌when‌ ‌a‌ ‌frequently‌ ‌used‌ ‌operation‌ ‌requires‌ ‌a‌ ‌ ‌temporary‌ ‌object‌ ‌such‌ ‌as‌ ‌a‌ ‌buffer‌ ‌and‌ ‌wants‌ ‌to‌ ‌avoid‌ ‌reallocating‌ ‌the‌ ‌temporary‌ ‌ ‌object‌ ‌on‌ ‌each‌ ‌invocation.‌ ‌For‌ ‌example,‌ ‌before‌ ‌Java‌ ‌‌5‌.‌0‌,‌ ‌‌Integer.toString‌ ‌‌used‌ ‌a‌ ‌ ‌ThreadLocal‌ ‌‌to‌ ‌store‌ ‌the‌ ‌‌12‌-byte‌ ‌buffer‌ ‌used‌ ‌for‌ ‌formatting‌ ‌its‌ ‌result,‌ ‌rather‌ ‌than‌ ‌ ‌using‌ ‌a‌ ‌shared‌ ‌static‌ ‌buffer‌ ‌(which‌ ‌would‌ ‌require‌ ‌locking)‌ ‌or‌ ‌allocating‌ ‌a‌ ‌new‌ ‌ ‌buffer‌ ‌for‌ ‌each‌ ‌invocation.‌11‌ ‌ ‌When‌ ‌a‌ ‌thread‌ ‌calls‌ ‌‌ThreadLocal.get‌ ‌‌for‌ ‌the‌ ‌first‌ ‌time,‌ ‌‌initialValue‌ ‌‌is‌ ‌con‌ ‌ ‌sulted‌ ‌to‌ ‌provide‌ ‌the‌ ‌initial‌ ‌value‌ ‌for‌ ‌that‌ ‌thread.‌ ‌Conceptually,‌ ‌you‌ ‌can‌ ‌think‌ ‌ ‌of‌ ‌a‌ ‌‌ThreadLocal<T>‌ ‌‌as‌ ‌holding‌ ‌a‌ ‌‌Map<Thread,T>‌ ‌‌that‌ ‌stores‌ ‌the‌ ‌thread-specific‌ ‌ ‌11‌.‌ ‌This‌ ‌technique‌ ‌is‌ ‌unlikely‌ ‌to‌ ‌be‌ ‌a‌ ‌performance‌ ‌win‌ ‌unless‌ ‌the‌ ‌operation‌ ‌is‌ ‌performed‌ ‌very‌ ‌fre‌ ‌ ‌quently‌ ‌or‌ ‌the‌ ‌allocation‌ ‌is‌ ‌unusually‌ ‌expensive.‌ ‌In‌ ‌Java‌ ‌‌5‌.‌0‌,‌ ‌it‌ ‌was‌ ‌replaced‌ ‌with‌ ‌the‌ ‌more‌ ‌straight‌ ‌ ‌forward‌ ‌approach‌ ‌of‌ ‌allocating‌ ‌a‌ ‌new‌ ‌buffer‌ ‌for‌ ‌every‌ ‌invocation,‌ ‌suggesting‌ ‌that‌ ‌for‌ ‌something‌ ‌as‌ ‌ ‌mundane‌ ‌as‌ ‌a‌ ‌temporary‌ ‌buffer,‌ ‌it‌ ‌is‌ ‌not‌ ‌a‌ ‌performance‌ ‌win.‌ ‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice.‌ ‌Java‌ ‌Concurrency‌ ‌in‌ ‌Practice,‌ ‌ISBN:‌ ‌0321349601‌ ‌ ‌Prepared‌ ‌for‌ ‌Salesh.fbsi.Kumar@fidelity.co.in,‌ ‌Salesh‌ ‌Kumar‌ ‌ ‌Copyright‌ ‌©‌ ‌2006‌ ‌Pearson‌ ‌Education,‌ ‌Inc..‌ ‌This‌ ‌download‌ ‌file‌ ‌is‌ ‌made‌ ‌available‌ ‌for‌ ‌personal‌ ‌use‌ ‌only‌ ‌and‌ ‌is‌ ‌subject‌ ‌to‌ ‌the‌ ‌Terms‌ ‌of‌ ‌Service.‌ ‌Any‌ ‌other‌ ‌use‌ ‌requires‌ ‌prior‌ ‌written‌ ‌consent‌ ‌from‌ ‌the‌ ‌copyright‌ ‌owner.‌ ‌Unauthorized‌ ‌use,‌ ‌reproduction‌ ‌and/or‌ ‌distribution‌ ‌are‌ ‌strictly‌ ‌prohibited‌ ‌and‌ ‌violate‌ ‌applicable‌ ‌laws.‌ ‌All‌ ‌rights‌ ‌reserved.‌ ‌ ‌46‌ ‌‌Chapter‌ ‌‌3‌.‌ ‌Sharing‌ ‌Objects‌ ‌ ‌values,‌ ‌though‌ ‌this‌ ‌is‌ ‌not‌ ‌how‌ ‌it‌ ‌is‌ ‌actually‌ ‌implemented.‌ ‌The‌ ‌thread-specific‌ ‌ ‌values‌ ‌are‌ ‌stored‌ ‌in‌ ‌the‌ ‌‌Thread‌ ‌‌object‌ ‌itself;‌ ‌when‌ ‌the‌ ‌thread‌ ‌terminates,‌ ‌the‌ ‌ ‌thread-specific‌ ‌values‌ ‌can‌ ‌be‌ ‌garbage‌ ‌collected.‌ ‌ ‌If‌ ‌you‌ ‌are‌ ‌porting‌ ‌a‌ ‌single-threaded‌ ‌application‌ ‌to‌ ‌a‌ ‌multithreaded‌ ‌environ‌ ‌ ‌ment,‌ ‌you‌ ‌can‌ ‌preserve‌ ‌thread‌ ‌safety‌ ‌by‌ ‌converting‌ ‌shared‌ ‌global‌ ‌variables‌ ‌into‌ ‌ ‌ThreadLocal‌s,‌ ‌if‌ ‌the‌ ‌semantics‌ ‌of‌ ‌the‌ ‌shared‌ ‌globals‌ ‌permits‌ ‌this;‌ ‌an‌ ‌application‌ ‌ ‌wide‌ ‌cache‌ ‌would‌ ‌not‌ ‌be‌ ‌as‌ ‌useful‌ ‌if‌ ‌it‌ ‌were‌ ‌turned‌ ‌into‌ ‌a‌ ‌number‌ ‌of‌ ‌thread-local‌ ‌ ‌caches.‌ ‌ ‌ThreadLocal‌ ‌‌is‌ ‌widely‌ ‌used‌ ‌in‌ ‌implementing‌ ‌application‌ ‌frameworks.‌ ‌For‌ ‌ex‌ ‌ ‌ample,‌ ‌J‌2‌EE‌ ‌containers‌ ‌associate‌ ‌a‌ ‌transaction‌ ‌context‌ ‌with‌ ‌an‌ ‌executing‌ ‌thread‌ ‌ ‌for‌ ‌the‌ ‌duration‌ ‌of‌ ‌an‌ ‌EJB‌ ‌call.‌ ‌This‌ ‌is‌ ‌easily‌ ‌implemented‌ ‌using‌ ‌a‌ ‌static‌ ‌‌Thread‌ ‌ ‌Local‌ ‌‌holding‌ ‌the‌ ‌transaction‌ ‌context:‌ ‌when‌ ‌framework‌ ‌code‌ ‌needs‌ ‌to‌ ‌determine‌ ‌ ‌what‌ ‌transaction‌ ‌is‌ ‌currently‌ ‌running,‌ ‌it‌ ‌fetches‌ ‌the‌ ‌transaction‌ ‌context‌ ‌from‌ ‌this‌ ‌ ‌ThreadLocal‌.‌ ‌This‌ ‌is‌ ‌convenient‌ ‌in‌ ‌that‌ ‌it‌ ‌reduces‌ ‌the‌ ‌need‌ ‌to‌ ‌pass‌ ‌execution‌ ‌ ‌context‌ ‌information‌ ‌into‌ ‌every‌ ‌method,‌ ‌but‌ ‌couples‌ ‌any‌ ‌code‌ ‌that‌ ‌uses‌ ‌this‌ ‌mech‌ ‌ ‌anism‌ ‌to‌ ‌the‌ ‌framework.‌ ‌ ‌It‌ ‌is‌ ‌easy‌ ‌to‌ ‌abuse‌ ‌‌ThreadLocal‌ ‌‌by‌ ‌treating‌ ‌its‌ ‌thread‌ ‌confinement‌ ‌property‌ ‌as‌ ‌ ‌a‌ ‌license‌ ‌to‌ ‌use‌ ‌global‌ ‌variables‌ ‌or‌ ‌as‌ ‌a‌ ‌means‌ ‌of‌ ‌creating‌ ‌“hidden”‌ ‌method‌ ‌argu‌ ‌ ‌ments.‌ ‌Like‌ ‌global‌ ‌variables,‌ ‌thread-local‌ ‌variables‌ ‌can‌ ‌detract‌ ‌from‌ ‌reusability‌ ‌ ‌and‌ ‌introduce‌ ‌hidden‌ ‌couplings‌ ‌among‌ ‌classes,‌ ‌and‌ ‌should‌ ‌therefore‌ ‌be‌ ‌used‌ ‌ ‌with‌ ‌care.‌ ‌ ‌3‌.‌4‌ ‌‌Immutability‌ ‌ ‌The‌ ‌other‌ ‌end-run‌ ‌around‌ ‌the‌ ‌need‌ ‌to‌ ‌synchronize‌ ‌is‌ ‌to‌ ‌use‌ ‌‌immutable‌ ‌‌objects‌ ‌ ‌[EJ‌ ‌Item‌ ‌‌13‌].‌ ‌Nearly‌ ‌all‌ ‌the‌ ‌atomicity‌ ‌and‌ ‌visibility‌ ‌hazards‌ ‌we’ve‌ ‌described‌ ‌so‌ ‌ ‌far,‌ ‌such‌ ‌as‌ ‌seeing‌ ‌stale‌ ‌values,‌ ‌losing‌ ‌updates,‌ ‌or‌ ‌observing‌ ‌an‌ ‌object‌ ‌to‌ ‌be‌ ‌in‌ ‌ ‌an‌ ‌inconsistent‌ ‌state,‌ ‌have‌ ‌to‌ ‌do‌ ‌with‌ ‌the‌ ‌vagaries‌ ‌of‌ ‌multiple‌ ‌threads‌ ‌trying‌ ‌to‌ ‌ ‌access‌ ‌the‌ ‌same‌ ‌mutable‌ ‌state‌ ‌at‌ ‌the‌ ‌same‌ ‌time.‌ ‌If‌ ‌an‌ ‌object’s‌ ‌state‌ ‌cannot‌ ‌be‌ ‌ ‌modified,‌ ‌these‌ ‌risks‌ ‌and‌ ‌complexities‌ ‌simply‌ ‌go‌ ‌away.‌ ‌ ‌An‌ ‌immutable‌ ‌object‌ ‌is‌ ‌one‌ ‌whose‌ ‌state‌ ‌cannot‌ ‌be‌ ‌changed‌ ‌after‌ ‌construction.‌ ‌ ‌Immutable‌ ‌objects‌ ‌are‌ ‌inherently‌ ‌thread-safe;‌ ‌their‌ ‌invariants‌ ‌are‌ ‌established‌ ‌by‌ ‌ ‌the‌ ‌constructor,‌ ‌and‌ ‌if‌ ‌their‌ ‌state‌ ‌cannot‌ ‌be‌ ‌changed,‌ ‌these‌ ‌invariants‌ ‌always‌ ‌hold.‌ ‌ ‌Immutable‌ ‌objects‌ ‌are‌ ‌always‌ ‌thread-safe.‌ ‌ ‌Immutable‌ ‌objects‌ ‌are‌ ‌‌simple‌.‌ ‌They‌ ‌can‌ ‌only‌ ‌be‌ ‌in‌ ‌one‌ ‌state,‌ ‌which‌ ‌is‌ ‌carefully‌ ‌ ‌controlled‌ ‌by‌ ‌the‌ ‌constructor.‌ ‌One‌ ‌of‌ ‌the‌ ‌most‌ ‌difficult‌ ‌elements‌ ‌of‌ ‌program‌ ‌ ‌design‌ ‌is‌ ‌reasoning‌ ‌about‌ ‌the‌ ‌possible‌ ‌states‌ ‌of‌ ‌complex‌ ‌objects.‌ ‌Reasoning‌ ‌about‌ ‌ ‌17 of 79111098765432112345678910OutlineHeadings you add to the document will appear here.Table of Contents1821604This page intentionally left blankContentsI Fundamentals 13II Structuring Concurrent Applications 111III Liveness, Performance, and Testing 203Contents xiIV Advanced Topics 275Listings5.4 Iteration with client-side locking. . . . . . . . . . . . . . . . . . . . . 825.6 Iteration hidden within string concatenation. Don’t do this. ..... 84tests. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 966.4 Web server using a thread pool. . . . . . . . . . . . . . . . . . . . . . 1186.8 Web server with shutdown support. . . . . . . . . . . . . . . . . . . 1226.10 Rendering page elements sequentially. . . . .............. 125xiv Listings7.5 Using interruption for cancellation. . .................. 1417.17 Shutdown with poison pill. . . . . . . .................. 156call. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1587.26 Registering a shutdown hook to stop the logging service. ...... 1658.9 Thread pool extended with logging and timing. . .......... 1808.18 Solver that recognizes when no solution exists. . . . . . . . . . . . . 188Licensed bySalesh Kumar182160411.8 Hash-based map using lock striping. . . . . . . . . . . . . . . . . . . 23812.7 Testing for resource leaks. . . . . . . . . . . . . . . . . . . . . . . . . 25812.9 Test method to verify thread pool expansion. . . . . . . . . . . . . . 259xvi Listings14.11 Bounded buffer using explicit condition variables. . . . . . . . . . . 30914.13 Canonical forms for acquisition and release in AQS. . . . ...... 312PrefaceHow to use this bookCode examplesJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 0321349601xx PrefaceAcknowledgmentsIntroduction1.1 A (very) brief history of concurrency1.2 Benefits of threads1.2.1 Exploiting multiple processors1.2.2 Simplicity of modeling1.2.3 Simplified handling of asynchronous eventsJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496011.2.4 More responsive user interfacesLicensed bySalesh Kumar18216041.3 Risks of threads1.3.1 Safety hazards6 Chapter 1\. Introduction/** Returns a unique value. */Listing 1.1\. Non-thread-safe sequence generator.diagrams usually depict the worst case2 and are intended to show theJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496011.3\. Risks of threads 7tations documenting thread safety are useful to multiple audiences. If a class isFigure 1.1\. (Exactly why this works is the subject of Chapters 2 and 3.)1.3.2 Liveness hazards1.3.3 Performance hazards1.4 Threads are everywhereso in a thread-safe manner, but so must any other classes that access that data. Often10 Chapter 1\. IntroductionJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496011.4\. Threads are everywhere 11This page intentionally left blankFundamentalsThis page intentionally left blankLicensed by1821604vides exclusive locking, but the term “synchronization” also includes the use of16 Chapter 2\. Thread SafetyJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496012.1 What is thread safety?18 Chapter 2\. Thread SafetySince any single-threaded program is also a valid multithreaded program, it2.1.1 Example: a stateless servletListing 2.1\. A stateless servlet.Java Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496012.2\. Atomicity 192.2 Atomicity2.2.2.2.1 Race conditionsfail in unpredictable ways. UnsafeCountingFactorizer has both race conditions and data races. SeeJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496012.2.2 Example: race conditions in lazy initializationListing 2.3\. Race condition in lazy initialization. Don’t do this.22 Chapter 2\. Thread Safety2.2.3 Compound actions2.3\. Locking 23for effecting atomic state transitions on numbers and object references. By replac2.3 LockingJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 0321349601Listing 2.5.always holds. When multiple variables participate in an invariant, they are notJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496012.3\. Locking 25Licensed bySalesh Kumar1821604by the normal control path or by throwing an exception out of the block. The26 Chapter 2\. Thread Safety2.3.2 ReentrancyJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496012.4\. Guarding state with locks 272.4 Guarding state with locksJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 0321349601Java Concurrency in Practice. Java Concurrency in Practice, ISBN: 0321349601that goes off every ten minutes, saving the program state to a file.factors are guarded by the servlet object’s intrinsic lock.If synchronization is the cure for race conditions, why not just declare evThis attempt at a put-if-absent operation has a race condition, even though2.5 Liveness and performance30 Chapter 2\. Thread Safetyguard each state variable with the servlet object’s intrinsic lock, and that policysimple, coarse-grained approach restored safety, but at a high price.counters constitute shared mutable state as well, we must use synchronizationListing 2.8\. Servlet that caches its last request and result.for effecting atomic operations on a single variable, but since we are already usingity (synchronizing the entire method) and concurrency (synchronizing the shortare “short enough”.balance can usually be found.Sharing Objects3.1 Visibilitydata without synchronization. Two threads, the main thread and the reader34 Chapter 3\. Sharing Objectsprint zero, or never terminate at all! Because it does not use adequate synchromain thread will be visible to the reader thread.Listing 3.1\. Sharing variables without synchronization. Don’t do this.those writes happen in the opposite order—or not at all.Java Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496013.1\. Visibility 35Licensed bySalesh Kumar1821604grams can cause surprising results: stale data. When the reader thread examinesmay or may not see that update.values.Java Concurrency in Practice. Java Concurrency in Practice, ISBN: 032134960136 Chapter 3\. Sharing ObjectsListing 3.2\. Non-thread-safe mutable integer holder.3.1.2 Nonatomic 64-bit operations3.1.4). The Java Memory Model requires fetch and store operations to be atomic,64-bit read or write as two separate 32-bit operations. If the reads and writes3.1.3 Locking and visibilityJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496013.1\. Visibility 37 Thread AFigure 3.1\. Visibility guarantees for synchronization.3.1.4 Volatile variables38 Chapter 3\. Sharing Objects6\. Debugging tip: For server applications, be sure to always specify the -server JVM command lineJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496013.2\. Publication and escape 39the code more cumbersome.state information, but more care is required when attempting this. For example,3.2 Publication and escapeListing 3.5\. Publishing an object.returning a reference from a nonprivate method also publishes the returned obabbreviations.Listing 3.6\. Allowing internal mutable state to escape. Don’t do this.erence to the enclosing instance.3.2.1 Safe construction practicesis to start a thread from a constructor. When an object creates a thread from its42 Chapter 3\. Sharing Objectsthread. (See Chapter 7 for more on service lifecycle issues.) Calling an override3.3 Thread confinement3.3.1 Ad-hoc thread confinementJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496013.3.2 Stack confinementad-hoc thread confinement.therefore confined to the executing thread. However, if we were to publish a refLicensed by1821604using a shared static buffer (which would require locking) or allocating a newsulted to provide the initial value for that thread. Conceptually, you can thinkJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 0321349601ample, J2EE containers associate a transaction context with an executing threadwhat transaction is currently running, it fetches the transaction context from this3.4 Immutabilitysince final fields can hold references to mutable objects.Immutable objects can still use mutable objects internally to manage theirbecome accessible to code other than the constructor and its caller.Java Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496013.4.1 Final fieldsto change.3.5\. Safe publication 49other threads.3.5 Safe publication50 Chapter 3\. Sharing Objects3.5.1 Improper publication: when good objects go badiom in Listing 3.14, and a thread other than the publishing thread were to call3.5\. Safe publication 51Listing 3.15\. Class at risk of failure if not properly published.with improperly published objects. Other threads could see a stale value for the3.5.2 Immutable objects and initialization safetyJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 032134960152 Chapter 3\. Sharing Objects3.5.3 Safe publication idioms• Storing a reference to it into a field that is properly guarded by aThe internal synchronization in thread-safe collections means that placing andirectly or via an iterator);any thread that retrieves it from the collection;publishes it to any thread that retrieves it from the queue.3.5\. Safe publication 533.5.4 Effectively immutable objectsyou may be able to eliminate the locking that would otherwise be required whenlast login time of each user:ing them.Java Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496013.5.5 Mutable objects3.5.6 Sharing objects safelyLicensed bySalesh Kumar1821604An object’s state starts with its fields. If they are all of primitive type, thethe object has fields that are references to other objects, its state will encompass56 Chapter 4\. Composing Objects4.1.1 Gathering synchronization requirements4.1.2 State-dependent operations4.1.3 State ownership58 Chapter 4\. Composing Objectsservlets where they can register and retrieve application objects by name withthe servlet container must be thread-safe, because it will necessarily be accessed4.2 Instance confinementJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 0321349601together to make a class thread-safe even when its component state variables areListing 4.2\. Using confinement to ensure thread safety.60 Chapter 4\. Composing Objectsand ensure that all clients follow the protocol of acquiring the appropriate lockInstance confinement is one of the easiest ways to build thread-safe classes.4.2.1 The Java monitor patternand exiting a synchronized block are even called monitorenter and monitorexit, and Java’s built-inJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 03213496014.2\. Instance confinement 614.2.2 Example: tracking fleet vehicles4.5 for representing the vehicle locations.4.3 Delegating thread safetystateless object, and the resulting composite object was still thread-safe. Since thein it. For the same reason, populating the HashMap in deepCopy via a copy constructor wouldn’t workJava Concurrency in Practice. Java Concurrency in Practice, ISBN: 0321349601Changes byExplore  AfrikaansAzərbaycanBahasa IndonesiaBahasa MelayuCatalàČeštinaCymraegDanskDeutschSchweizer HochdeutschEestiEnglish (United Kingdom)English (United States)EspañolEspañol (Latinoamérica)EuskaraFilipinoFrançaisFrançais (Canada)GalegoHrvatskiIsizuluÍslenskaItalianoKiswahiliLatviešuLietuviųMagyarMaltiမြန်မာစာNederlandsNorsk (Nynorsk)Norsk (Bokmål)PolskiPortuguês (Brasil)Português (Portugal)RomânăSlovenčinaSlovenščinaSuomiSvenskaTiếng ViệtTürkçeбеларускаяБългарскиҚазақМонголРусскийСрпскиУкраїнськаΕλληνικάհայերենעבריתاردوالعربيةفارسیनेपालीमराठीहिन्दीবাংলাਪੰਜਾਬੀગુજરાતીதமிழ்తెలుగుಕನ್ನಡമലയാളംසිංහලไทยລາວქართულადአማርኛខ្មែរ中文（中国）中文（台灣）中文（香港）日本語한국어Export options disabledShareUnlock(J)New►OpenCtrl+OMake a copySave as Google Docs(U)Email►Download►Make available offlineVersion history►RenameMoveAdd shortcut to Drive(,)Edit description(Y)Ctrl+Shift+EMove to trashPublish to the webDocument details(B)Language►Page setupPrint previewPrintCtrl+PExport options disabledUndoCtrl+ZRedoCtrl+YCutCtrl+XCopyCtrl+CPasteCtrl+VPaste without formattingCtrl+Shift+VDeleteSelect allCtrl+AFind and replaceCtrl+HPrint layoutMode►Zoom►Show rulerShow document outlineCtrl+Alt+A Ctrl+Alt+HShow equation toolbarShow section breaksShow increased menu spacingFull screenImage►Table►Drawing►Chart(Q)►Horizontal lineFootnoteCtrl+Alt+FSpecial charactersEquationHeaders & footers►Page numbers►Break►LinkCtrl+KCommentCtrl+Alt+MBookmarkTable of contents►Left-to-right textRight-to-left textText(S)►Paragraph styles►Align & indent►Line spacing►Columns►Bullets & numbering►Headers & footers►Headers & footersPage numbersPage orientation(3)Table(2)►Image►Clear formattingCtrl+\Borders & lines(Q)►Spelling and grammar►Word countCtrl+Shift+CReview suggested editsCtrl+Alt+O Ctrl+Alt+UNewCompare documentsCitations(K)ExploreCtrl+Alt+Shift+ILinked objectsDictionaryCtrl+Shift+YTranslate documentVoice typingCtrl+Shift+SScript editorPreferencesAccessibility settingsActivity dashboard(Z)Activity dashboard privacyNotifications(J)![](//ssl.gstatic.com/docs/common/addon_docs_promo.svg)Do more with DocsLooking for even more Docs features? Get a few add-ons.Document add-onsGet add-onsManage add-ons<input type="text" role="combobox" aria-autocomplete="list" class="docs-omnibox-input jfk-textinput label-input-label" placeholder="Search the menus (Alt+/)" aria-label="Search the menus (Alt+/)" style="user-select: none;">Docs HelpTrainingUpdatesHelp Docs improveReport abuse/copyrightPrivacy PolicyTerms of ServiceKeyboard shortcutsCtrl+/Speak►Edits►Comments►Footnote►Headings►Graphics►List►Link►Table►Section►Misspelling►Formatting►Show live editsCtrl+Alt+Shift+RUpload from computerSearch the webDrivePhotosBy URLCameraSingle1.151.5DoubleCustomAdd space before paragraphAdd space after paragraphCustom spacingKeep with nextKeep lines togetherPrevent single lines1pt2pt3pt4pt8pt12pt16pt24pt0pt0.5pt0.75pt1pt1.5pt2.25pt3pt4.5pt6ptUpload from computerSearch the webDrivePhotosBy URLCamera[Turn on screen reader support](#)Link copied to clipboardApply 'Normal text'Ctrl+Alt+0Update 'Normal text' to matchApply 'Title'Update 'Title' to matchApply 'Subtitle'Update 'Subtitle' to matchApply 'Heading 1'Ctrl+Alt+1Update 'Heading 1' to matchApply 'Heading 2'Ctrl+Alt+2Update 'Heading 2' to matchApply 'Heading 3'Ctrl+Alt+3Update 'Heading 3' to matchApply 'Heading 4'Ctrl+Alt+4Update 'Heading 4' to matchApply 'Heading 5'Ctrl+Alt+5Update 'Heading 5' to matchApply 'Heading 6'Ctrl+Alt+6Update 'Heading 6' to matchSave as my default stylesUse my default stylesReset styles

<table class="scb-tooltip-contents">

<tbody>

<tr>

<td>Private to only me</td>

</tr>

</tbody>

</table>

(1) Android Dev NotesWhy are some users anonymous? [Learn more](http://support.google.com/drive/?hl=en&p=anonymous_users)<textarea class="docs-chat-edit-box label-input-label" role="textbox" aria-controls="docs-chat-messages" tabindex="0" placeholder="Type here to chat" aria-label="Type here to chat" disabled=""></textarea>Google AccountAndroid Dev Notesawesomedevnotes@gmail.comDocument detailsUnable to get the details at this time.EditingEdit document directlySuggestingEdits become suggestionsViewingRead or print final documentSpeak►Edits►Comments►Footnote►Headings►Graphics►List►Link►Table►Section►Misspelling►Formatting►Show live editsCtrl+Alt+Shift+RMore fontsAmatic SCArialCaveat►Comfortaa►Comic Sans MSCourier NewEB Garamond►GeorgiaImpactLobsterLora►Lucida SansMerriweather►Montserrat►Nunito►Oswald►PacificoPalatinoPlayfair Display►Roboto►Roboto Mono►Spectral►TimesTimes New RomanTrebuchet MSVerdanaExploreExplore<input class="jfk-textinput docs-explore-searchbar-labelinput label-input-label" type="text" placeholder="Search your docs and the web" aria-label="Search your docs and the web" role="textbox" aria-autocomplete="list">WebImagesDriveCreate smarter documentsTo see related information and images, try adding more content to your document[Learn more](https://support.google.com/docs/?p=docs_explore&hl=en)Can't load Explore contentRetryName current versionSee version historyCtrl+Alt+Shift+HMicrosoft Word (.docx)Microsoft Word (.doc)OpenDocument Format (.odt)Rich Text Format (.rtf)PDF Document (.pdf)Plain Text (.txt)Web Page (.html, zipped)EPUB Publication (.epub)50 Chapter 3\. Sharing ObjectsOriginal emailReply with this fileOpen original messageCompose new messageEmail this fileEmail collaborators
